diff -urN zaptel-1.4.11.org/kernel/cwain/cwain.c zaptel-1.4.11/kernel/cwain/cwain.c
--- zaptel-1.4.11.org/kernel/cwain/cwain.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/cwain.c	2008-07-16 22:06:17.184808735 +0200
@@ -0,0 +1,2236 @@
+/*
+ * cwain.c - Zaptel driver for the Junghanns.NET E1 card
+ *
+ * c.w.a.i.n. == card without an interesting name
+ *
+ * single/double E1 board
+ *
+ * Copyright (C) 2004, 2005, 2006, 2007 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <zaptel.h>
+#include "cwain.h"
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+#if CONFIG_PCI
+
+static int ports=-1; /* autodetect */
+static int debug=0;
+static int hw_hdlc=1;
+static int hdlcnet=0;
+static int pwm0 = 0x50;	/* TX level */
+static int pwm1 = 0x50; /* RX level */
+static int dacs = 1; /* 0 = no dacs, 1 = oncard dacs */
+static int require_ext_clock = 0;
+static struct zt_cwain *cwain_span_list = NULL;
+static int cwain_span_count = 0;
+static struct zt_cwain_card *cwain_card_list = NULL;
+static int cwain_card_count = 0;
+static struct pci_dev *multi_cwain = NULL;
+static spinlock_t cwain_span_registerlock = SPIN_LOCK_UNLOCKED;
+static spinlock_t cwain_card_registerlock = SPIN_LOCK_UNLOCKED;
+
+static int ztcwain_shutdown(struct zt_span *span);
+
+int cwain_waitbusy(struct zt_cwain *cwaintmp) {
+    int x=1000;
+    while (x-- && (cwain_inb(cwaintmp,cwain_R_STATUS) & 1));
+    if (x < 0) {
+	printk(KERN_CRIT "cwain: really busy waiting!\n");
+	return -1;
+    } else {
+	if ((x < 990) && (cwaintmp->ticks > 500)) {
+	    printk(KERN_CRIT "cwain: waited %d\n", 1000 - x);
+	}
+	return 0;
+    }
+}
+
+void cwain_unregister_zap_span(struct zt_cwain *cwainspan) {
+    if (!cwainspan) {
+	printk(KERN_INFO "cwain: shutting down NULL span!\n");
+	return;
+    }
+    if(cwainspan->span.flags & ZT_FLAG_RUNNING) {
+        ztcwain_shutdown(&cwainspan->span);
+        if (debug)
+            printk(KERN_INFO "cwain: shutdown span %d.\n",cwainspan->cardno);
+    }
+    if(cwainspan->span.flags & ZT_FLAG_REGISTERED) {
+        zt_unregister(&cwainspan->span);
+        if (debug)
+    	printk(KERN_INFO "cwain: unregistered span %d.\n",cwainspan->cardno);
+    }
+}
+
+void cwain_shutdown_span(struct zt_cwain *cwainspan) {
+    
+    if (!cwainspan) {
+	printk(KERN_INFO "cwain: shutting down NULL span!\n");
+	return;
+    }
+
+    if (cwainspan->pci_io == NULL) {
+	return;
+    }
+
+    if (debug)
+	printk(KERN_INFO "cwain: shutting down span %d (cardID %d) at %p.\n",cwainspan->cardno,cwainspan->cardID,cwainspan->pci_io);
+
+    // turn off irqs
+
+    // softreset
+    cwain_outb(cwainspan,cwain_R_CIRM,0x8);
+    cwain_outb(cwainspan,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwainspan);
+
+    cwain_outb(cwainspan,cwain_R_IRQMSK_MISC, 0); 
+    cwain_outb(cwainspan,cwain_R_IRQ_CTRL, 0); 
+
+    pci_write_config_word(cwainspan->pcidev, PCI_COMMAND, 0);	// disable memio
+
+    if (cwainspan->pcidev != NULL) {
+        pci_disable_device(cwainspan->pcidev);
+	cwainspan->pcidev = NULL;
+    }
+
+}
+
+void cwain_shutdown_card(struct zt_cwain_card *cwaintmp) {
+    unsigned long flags = 0;
+    int i = 0;
+    
+    if (!cwaintmp) {
+	printk(KERN_INFO "cwain: shutting down NULL card!\n");
+	return;
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+
+    // turn off irqs
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQ_CTRL, 0); 
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQMSK_MISC, 0); 
+
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	cwain_unregister_zap_span(cwaintmp->span[i]);
+    }
+
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	release_region(cwaintmp->span[i]->ioport, 8);
+	cwaintmp->span[i]->ioport = 0;
+	iounmap((void *) cwaintmp->span[i]->pci_io);
+	cwaintmp->span[i]->pci_io = NULL;
+	release_mem_region((unsigned long)cwaintmp->span[i]->pci_io_phys, 256);
+    }
+
+    if (cwaintmp->spans == 2) {
+	free_irq(cwaintmp->span[1]->irq,cwaintmp);
+    }
+    free_irq(cwaintmp->irq,cwaintmp);
+}
+
+void cwain_doLEDs(struct zt_cwain *cwaintmp) {
+    /*
+     O1 O3 (red)
+     O2 O4 (green)
+    */
+    if (!(cwaintmp->span.flags & ZT_FLAG_RUNNING)) {
+	return;
+    }
+    if ((cwaintmp->type == 0xb553) || (cwaintmp->type == 0xb554) || (cwaintmp->type == 0xb555)) {
+	/* sync status */
+	if (((cwaintmp->sync_sta & 0x07) == 0x07) && cwaintmp->sync) {
+	    cwaintmp->leds[0] = 1;    
+	    cwaintmp->leds[1] = 0;    
+	} else {
+	    cwaintmp->leds[0] = 0;    
+	    cwaintmp->leds[1] = 1;    
+	}
+	/* multiframe alignment */
+	if ((cwaintmp->sync_sta & 0x20) == 0x20) {
+    	    cwaintmp->leds[2] = 1;    
+	    cwaintmp->leds[3] = 0;    
+	} else {
+	    if ((cwaintmp->span.lineconfig & ZT_CONFIG_CRC4) && cwaintmp->sync) {
+		/* CRC4 requested */
+		cwaintmp->leds[2] = 0;    
+		cwaintmp->leds[3] = 1;    
+	    } else {
+		/* no CRC4, disable 3 and 4 */
+		cwaintmp->leds[2] = 1;    
+		cwaintmp->leds[3] = 1;    
+	    }
+	}
+	cwain_outb(cwaintmp,cwain_R_GPIO_OUT1,(cwaintmp->leds[0] | (cwaintmp->leds[1] << 1) | (cwaintmp->leds[2] << 2) | (cwaintmp->leds[3] << 3)));
+    }
+}
+
+void cwain_reset_pcm(struct zt_cwain *cwaintmp, int master, int int_clock) {
+    /* PCM reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x20);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+    
+    if (master) {
+	cwain_outb(cwaintmp,cwain_R_PCM_MD0, 0x91);
+        cwain_outb(cwaintmp,cwain_R_PCM_MD1, 0x20);
+	if (int_clock) {
+	    cwain_outb(cwaintmp,cwain_R_PCM_MD0, 0xA1);
+    	    cwain_outb(cwaintmp,cwain_R_PCM_MD2, 0x04);
+	} else {
+	    cwain_outb(cwaintmp,cwain_R_PCM_MD0, 0xA1);
+    	    cwain_outb(cwaintmp,cwain_R_PCM_MD2, 0x00);
+	}
+    } else {
+    	cwain_outb(cwaintmp,cwain_R_PCM_MD0, 0x90);
+	cwain_outb(cwaintmp,cwain_R_PCM_MD1, 0x20);
+    }
+}
+
+void cwain_reset_span(struct zt_cwain *cwaintmp) {
+
+    pci_write_config_word(cwaintmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY | PCI_COMMAND_IO);	// enable memio
+
+    cwain_reset_pcm(cwaintmp,0,0);
+    
+    /* E1 reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x40);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+
+    /* soft reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x10);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+
+    /* 128 byte B chans, 4096 byte D chans */
+    if (hdlcnet) {
+	cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x3E);
+    } else {
+	cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x36);
+    }
+
+
+    cwain_outb(cwaintmp,cwain_R_BRG_PCM_CFG,0x0); 
+    cwain_outb(cwaintmp,cwain_R_CTRL,0x0); 
+
+    /* no blinky blink */
+    if (cwaintmp->type == 0xb555) {
+	cwain_outb(cwaintmp,cwain_R_GPIO_SEL,0x20 | 0x10 | 0x02);
+	cwain_outb(cwaintmp,cwain_R_GPIO_EN1,0x0f);
+	cwain_outb(cwaintmp,cwain_R_GPIO_EN0,0x08 | 0x04);
+    } else {
+	cwain_outb(cwaintmp,cwain_R_GPIO_SEL,0x20 | 0x10);
+	cwain_outb(cwaintmp,cwain_R_GPIO_EN1,0x0f);
+    }
+    cwain_outb(cwaintmp,cwain_R_GPIO_OUT1,0x0f);
+
+    /* IRQs off */
+    cwain_outb(cwaintmp,cwain_R_IRQMSK_MISC,0x0); 
+    cwain_outb(cwaintmp,cwain_R_IRQ_CTRL,0x0); 
+
+    cwaintmp->leds[0] = 1;    
+    cwaintmp->leds[1] = 1;    
+    cwaintmp->leds[2] = 1;    
+    cwaintmp->leds[3] = 1;    
+    
+    cwaintmp->ticks = 0;
+    cwaintmp->clicks = 0;
+}
+
+struct zt_cwain_card *cwain_get_card(unsigned int pcibus) {
+    struct zt_cwain_card *cwaintmp = cwain_card_list;
+    spin_lock(&cwain_card_registerlock);
+    while (cwaintmp) {
+	if (cwaintmp->pcibus == pcibus) {
+	    break;
+	}
+	cwaintmp = cwaintmp->next;
+    }
+    spin_unlock(&cwain_card_registerlock);
+    return cwaintmp;
+}
+
+
+void cwain_register_card(struct zt_cwain_card *cwaincard) {
+    spin_lock(&cwain_card_registerlock);
+    if (cwaincard != NULL) {
+	cwaincard->prev = NULL;
+	cwaincard->next = cwain_card_list;
+	if (cwain_card_list) {
+	    cwain_card_list->prev = cwaincard;
+	}
+	cwain_card_list = cwaincard;
+	cwain_card_count++;
+    } else {
+	printk(KERN_INFO "cwain: trying to register NULL card.\n");
+    }
+    spin_unlock(&cwain_card_registerlock);
+}
+
+int cwain_register_span(struct zt_cwain *cwainspan) {
+    struct zt_cwain_card *cwaintmp;
+    spin_lock(&cwain_span_registerlock);
+    if (cwainspan != NULL) {
+	cwainspan->prev = NULL;
+	cwainspan->next = cwain_span_list;
+	if (cwain_span_list) {
+	    cwain_span_list->prev = cwainspan;
+	}
+	cwain_span_list = cwainspan;
+	cwainspan->cardno = ++cwain_span_count;
+    } else {
+	printk(KERN_INFO "cwain: trying to register NULL span.\n");
+    }
+    spin_unlock(&cwain_span_registerlock);
+
+    if (cwainspan->type == 0xb553) {
+	cwaintmp = kmalloc(sizeof(struct zt_cwain_card),GFP_KERNEL);
+	if (!cwaintmp) {
+	    printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	    return -1;
+	}
+	memset(cwaintmp, 0x0, sizeof(struct zt_cwain_card));
+	
+	spin_lock_init(&cwaintmp->lock);
+	cwaintmp->pcibus = cwainspan->pcibus;
+	cwaintmp->span[0] = cwainspan;
+	cwaintmp->syncs[0] = -1;
+	cwaintmp->spans = 1;
+	cwaintmp->cardID = cwainspan->cardID;
+	cwain_register_card(cwaintmp);
+	printk(KERN_INFO
+	        "cwain: Junghanns.NET singleE1 PCI ISDN card configured at mem %lx IRQ %d HZ %d CardID %d\n",
+	          (unsigned long) cwainspan->pci_io,
+	        cwaintmp->span[0]->irq, HZ, cwainspan->cardID);
+    } else {
+	cwaintmp = cwain_get_card(cwainspan->pcibus);
+	if (!cwaintmp) {
+	    cwaintmp = kmalloc(sizeof(struct zt_cwain_card),GFP_KERNEL);
+	    if (!cwaintmp) {
+		printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	        return -1;
+	    }
+	    memset(cwaintmp, 0x0, sizeof(struct zt_cwain_card));
+	
+	    spin_lock_init(&cwaintmp->lock);
+	    cwaintmp->pcibus = cwainspan->pcibus;
+//	    cwaintmp->spans = cwainspan->type - 46419;
+	    cwaintmp->spans = (cwainspan->type & (2321 * 20)) - 46419;
+	    cwaintmp->span[0] = cwainspan;
+	    cwaintmp->cardID = cwainspan->cardID;
+	    cwaintmp->syncs[0] = -1;
+	    cwain_register_card(cwaintmp);
+	} else {
+	    cwaintmp->spans = (cwainspan->type & (2321 * 20)) - 46418;
+	    if (cwainspan->cardID < cwaintmp->cardID) {
+		cwaintmp->cardID = cwainspan->cardID;
+		cwaintmp->span[1] = cwaintmp->span[0];
+		cwaintmp->syncs[1] = cwaintmp->syncs[0];
+	        cwaintmp->span[0] = cwainspan;
+	    } else {
+	        cwaintmp->span[1] = cwainspan;
+		cwaintmp->syncs[1] = -1;
+	    }
+	    printk(KERN_INFO
+	        "cwain: Junghanns.NET doubleE1 PCI ISDN %d.0 card configured at mem (%lx / %lx) IRQ %d HZ %d CardID (%d / %d) bus %#x\n",
+	        (cwainspan->type - 0xb553),  (unsigned long) cwaintmp->span[0]->pci_io, (unsigned long) cwaintmp->span[1]->pci_io,
+	        cwaintmp->span[0]->irq, HZ, cwaintmp->span[0]->cardID, cwaintmp->span[1]->cardID, cwaintmp->pcibus);
+	}
+    }
+    return 0;
+}
+
+static void cwain_dfifo_check(struct zt_cwain *cwaintmp) {
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    unsigned char f1=1,f2=1;
+    unsigned char of1=0,of2=0;
+    int space = 0;
+    int len;
+    int chan;
+    int fifo = 0x1f;
+    unsigned long flags;
+    int frames = 0;
+
+    if (hdlcnet) {
+	chan = 0;
+    } else {
+	chan = 15;
+    }
+    
+
+    /* calculate how much data we can allow zaptel to transmit */
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    /* select tx fifo */
+
+    cwain_outb(cwaintmp,cwain_R_FIFO, fifo << 1);    
+    cwain_waitbusy(cwaintmp);
+
+    while ((oz1 != z1) && (oz2 != z2)) {
+        oz1 = z1;
+        oz2 = z2;
+    	z1 = cwain_inw(cwaintmp,cwain_A_Z1) & 0xfff;
+	z2 = cwain_inw(cwaintmp,cwain_A_Z2) & 0xfff;
+    }
+    
+    len = z1-(z2 & 0xfff);
+    if (len < 0) {
+        len += cwain_DFIFO_SIZE;
+    }
+    space = cwain_DFIFO_SIZE - len;
+
+    if (((debug > 2) && (space < cwain_DFIFO_SIZE)) || (space == 0)) {
+        printk(KERN_INFO "cwain: card %d TX fifo %d space now %d\n", cwaintmp->cardno, fifo, space);
+    }    
+    cwaintmp->chans[chan].maxbytes2transmit = space;
+
+
+    /* calculate how many frames are in the receive fifo */
+
+    /* select rx fifo */
+    cwain_outb(cwaintmp,cwain_R_FIFO,(fifo << 1) | 1);    
+    cwain_waitbusy(cwaintmp);
+
+    while ((of1 != f1) && (of2 != f2)) {
+        of1 = f1;
+        of2 = f2;
+        f1 = cwain_inb(cwaintmp,cwain_A_F1) & 0xf;
+        f2 = cwain_inb(cwaintmp,cwain_A_F2) & 0xf;
+    }
+
+    frames = f1 - f2;
+    if (frames < 0) {
+	frames += cwain_DFIFO_FRAMES;
+    }
+    cwaintmp->drx = frames;
+
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+
+    if ((frames > 0) && (debug > 3))
+	printk(KERN_INFO "\ncwain: %d frames in RX fifo\n", frames);
+}
+
+static int cwain_dfifo_tx(struct zt_cwain *cwaintmp) {
+    int chan;
+    int x=0;
+    char fifo = 0;
+    unsigned long flags = 0;
+    
+    fifo = 0x1F;
+
+    if (hdlcnet) {
+	chan = 0;
+    } else {
+	chan = 15;
+    }
+
+    if (cwaintmp->chans[chan].bytes2transmit < 1) {
+	return 0;
+    } else {
+	spin_lock_irqsave(&cwaintmp->lock,flags);
+	/* select fifo */
+	cwain_outb(cwaintmp,cwain_R_FIFO,fifo << 1);    
+	cwain_waitbusy(cwaintmp);
+
+	if (((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3)))
+	    printk(KERN_INFO "cwain: card %d TX [ ", cwaintmp->cardno);
+	/* copy frame to fifo */
+    	for (x=0;x<cwaintmp->chans[chan].bytes2transmit;x++) {
+	    if (((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3)))
+	        printk("%#x ",cwaintmp->dtxbuf[x]);
+    	    cwain_outb(cwaintmp,cwain_A_FIFO_DATA0,cwaintmp->dtxbuf[x]);
+	}
+	if (((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3)))
+	    printk("]\n");
+	if (((debug > 2 ) && hdlcnet) || ((!hdlcnet) && (debug > 3)))
+    	    printk(KERN_INFO "ztx %d bytes\n",cwaintmp->chans[chan].bytes2transmit);
+
+	if (cwaintmp->chans[chan].eoftx == 1) {
+	    /* transmit HDLC frame */
+    	    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x1);    
+    	    cwain_waitbusy(cwaintmp);
+	    if ((debug > 3 ) && hdlcnet)
+    		printk(KERN_INFO "cwain: TX flag\n");
+	}
+	spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    }
+    return 0;
+}
+
+static int cwain_fifo_tx(struct zt_cwain *cwaintmp, char fifo) {
+    int chan,f;
+    unsigned long flags = 0;
+
+    if (hw_hdlc) {
+	if (fifo <= 14) {
+	    chan = fifo;
+	} else {
+	    chan = fifo + 1;
+	}
+    } else {
+	chan = fifo;
+    }
+
+    if (dacs && (cwaintmp->ts_rx[chan] > -1)) {
+	/* dont transmit when we receive from the pcm bus */
+	return 0;
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+	/* select fifo */
+	cwain_outb(cwaintmp,cwain_R_FIFO,0x80 | (fifo << 1));    
+	cwain_waitbusy(cwaintmp);
+    
+	for (f=0; f < (cwain_FRAME_SIZE/4); f++) {
+	    cwain_outdw(cwaintmp,cwain_A_FIFO_DATA0,*((unsigned int *) &cwaintmp->ftxbuf[chan][f * 4]));
+	}
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    return 0;
+}
+
+static int cwain_dfifo_rx(struct zt_cwain *cwaintmp) {
+    int chan;
+    unsigned char data,stat;
+    int len,i = 0;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    char fifo = 0;
+    unsigned long flags = 0;
+
+    fifo = 0x1F;
+    if (hdlcnet) {
+	chan = 0;
+    } else {
+	chan = 15;
+    }
+    
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    /* select fifo */
+    cwain_outb(cwaintmp,cwain_R_FIFO,(fifo << 1) | 1);    
+    cwain_waitbusy(cwaintmp);
+    
+    while ((oz1 != z1) && (oz2 != z2)) {
+        oz1 = z1;
+        oz2 = z2;
+    	z1 = cwain_inw(cwaintmp,cwain_A_Z1) & 0xfff;
+	z2 = cwain_inw(cwaintmp,cwain_A_Z2) & 0xfff;
+    }
+    
+    len = z1-(z2 & 0xfff);
+    if (len < 0) {
+        len += cwain_DFIFO_SIZE;
+    }
+
+    if (len > cwain_DFIFO_SIZE) {
+	printk(KERN_INFO "\ncwain: buffer overflow in D channel RX!\n");
+	cwaintmp->chans[chan].bytes2receive = 0;
+	cwaintmp->chans[chan].eofrx = 0;
+    } else {
+	if ((((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3))) && (cwaintmp->sync))
+	    printk(KERN_INFO "cwain: card %d RX [ ", cwaintmp->cardno);
+	for (i=0; i<len; i++) {
+    	    data = cwain_inb(cwaintmp,cwain_A_FIFO_DATA0);
+	    cwaintmp->drxbuf[i] = data;
+	    if ((((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3))) && (cwaintmp->sync))
+		printk("%#x ",data);
+	}
+	if ((((debug > 3 ) && hdlcnet) || ((!hdlcnet) && (debug > 3))) && (cwaintmp->sync))
+	    printk("] %d bytes\n", i);
+	cwaintmp->chans[chan].bytes2receive = i;
+	cwaintmp->chans[chan].eofrx = 1;
+    }
+
+    stat = cwain_inb(cwaintmp,cwain_A_FIFO_DATA0);
+    if (stat != 0x0) {
+	// bad CRC, skip it
+	if (cwaintmp->sync) {
+	    printk(KERN_INFO "cwain: BAD CRC for hdlc frame on card %d (cardID %d) stat %#x len %d\n",cwaintmp->cardno, cwaintmp->cardID, stat, i);
+	}
+	cwaintmp->chans[chan].bytes2receive = 0;
+	cwaintmp->chans[chan].eofrx = 0;
+//	zt_qevent_nolock(&cwaintmp->chans[chan], ZT_EVENT_BADFCS);
+    }
+    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x1);    
+    cwain_waitbusy(cwaintmp);
+
+    /* frame received */
+    cwaintmp->drx--;
+    if (!cwaintmp->sync) {
+	cwaintmp->chans[chan].bytes2receive = 0;
+	cwaintmp->chans[chan].eofrx = 0;
+	stat = 0xff;
+    }
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    if (stat == 0) {
+	return 1;
+    } else {
+	return 0;
+    }
+}
+
+static int cwain_fifo_rx(struct zt_cwain *cwaintmp, char fifo) {
+    int chan;
+    unsigned int data;
+    int len = 0,i,f,flen = 0;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    int mumbojumbo=0;
+    unsigned long flags = 0;
+    int x = 1000;
+
+    if (hw_hdlc) {
+	if (fifo <= 14) {
+	    chan = fifo;
+	} else {
+	    chan = fifo + 1;
+	}
+    } else {
+	chan = fifo;
+    }
+
+    // select rx fifo
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+	// no hdlc, transparent data
+	cwain_outb(cwaintmp,cwain_R_FIFO,0x80 | (fifo << 1) | 1);    
+        cwain_waitbusy(cwaintmp);
+    
+	while (x-- && ((oz1 != z1) && (oz2 != z2))) {
+	    len = z1 - z2;
+	    if (len < 0) {
+		len += cwain_FIFO_SIZE;
+	    }
+	    flen = len;
+	    if (len > cwain_FIFO_HW) {
+		mumbojumbo = len - (cwain_FIFO_HW - cwain_FRAME_SIZE);
+	        len = cwain_FRAME_SIZE;
+	    }
+	    oz1 = z1;
+	    oz2 = z2;
+	    z1 = cwain_inw(cwaintmp,cwain_A_Z1) & 0x7f;
+    	    z2 = cwain_inw(cwaintmp,cwain_A_Z2) & 0x7f;
+	}
+	if (x < 500) {
+	    printk(KERN_CRIT "cwain: prevented endless loop\n");
+	}
+    
+	if (mumbojumbo > 0) {
+	    for (i=0;i<(mumbojumbo/4);i++) {
+    		data = cwain_indw(cwaintmp,cwain_A_FIFO_DATA0);
+	    }
+	    cwaintmp->clicks++;
+	}
+	if (len < cwain_FRAME_SIZE) {
+	    /* dont get nervous here */
+	    if ((cwaintmp->clicks > 600) && (cwaintmp->span.alarms == ZT_ALARM_NONE)) {
+		printk(KERN_INFO "cwain: cardID %d not enough to receive (%d bytes), fifo %d\n",cwaintmp->cardID, len, fifo);
+	    }
+	    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+	    return 0;
+	} else {
+	    for (f=0;f<(cwain_FRAME_SIZE / 4);f++) {
+		*((unsigned int *) &cwaintmp->frxbuf[chan][f*4]) = cwain_indw(cwaintmp,cwain_A_FIFO_DATA0);
+	    }
+	}
+
+
+	/* dont get nervous here */
+	if (((cwaintmp->clicks > 50) || (debug > 3)) && ((cwaintmp->span.alarms == ZT_ALARM_NONE) && (mumbojumbo > 0))) {
+	    printk(KERN_INFO "cwain: span %d dropped audio fifo %d mj %d flen %d z1 %d z2 %d\n", cwaintmp->cardID, fifo, mumbojumbo, flen, z1, z2);
+	    cwaintmp->clicks = 0;
+	}
+//    printk(KERN_INFO "s/t port %d, channel %d, dbufi=%d, f1=%d, f2=%d, z1=%d, z2=%d  => len = %d stat=%#x, hdlc=%d\n",stport,chan,cwaintmp->st[stport].dbufi,f1,f2,z1,z2,len,stat,hdlc);    
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    return 0;
+}
+
+void cwain_set_master(struct zt_cwain_card *cwaintmp, int span) {
+    int i=0;
+    unsigned long flags = 0;
+
+    if (cwaintmp->syncsrc == span) return;
+    
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    /* disable the old master */
+    for (i=0; i < cwaintmp->spans; i++) {
+	if (cwaintmp->master[i]) {
+	    /* enable PCM slave mode, PCM128 */
+	    cwain_reset_pcm(cwaintmp->span[i],0,0);
+	    cwaintmp->master[i] = 0;
+	}
+    }
+
+    /* enable the new master */
+    if (cwaintmp->syncs[span] > 0) {
+        /* enable PCM master mode, PCM128, synced to E1 receive */
+	cwain_reset_pcm(cwaintmp->span[span],1,0);
+	if (debug)
+	    printk(KERN_INFO "cwain: cardID %d span %d, PCM master E1 sync\n", cwaintmp->cardID, span);
+    } else {
+        /* enable PCM master mode, PCM128, free running */
+	cwain_reset_pcm(cwaintmp->span[span],1,1);
+	if (debug)
+	    printk(KERN_INFO "cwain: cardID %d span %d, PCM master internal clock\n", cwaintmp->cardID, span);
+    }
+
+    /* reset the slaves */
+    for (i=0; i < cwaintmp->spans; i++) {
+	if (i != span) {
+	    /* enable PCM slave mode, PCM128 */
+	    cwain_reset_pcm(cwaintmp->span[i],0,0);
+	    cwaintmp->master[i] = 0;
+	}
+    }
+    
+    cwaintmp->master[span] = 1;
+    cwaintmp->syncsrc = span;
+
+    /* restore pcm assignments !!! */
+
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+}
+
+void cwain_check_timing(struct zt_cwain_card *cwaintmp) {
+    int i=0;
+    int bestsync = 42;
+    int sync_ok = 0;
+
+    for (i=0; i < cwaintmp->spans; i++) {
+	if (cwaintmp->span[i]->span.lineconfig & ZT_CONFIG_CRC4) {
+	    /* CRC4 requested */
+	    sync_ok = 0x27;
+	} else {
+	    /* doubleframing requested */
+	    sync_ok = 0x07;
+	}    
+        if ((cwaintmp->syncs[i] > 0) && ((cwaintmp->span[i]->sync_sta & sync_ok) == sync_ok)) {
+    	    if (bestsync < cwaintmp->spans) {
+		if (cwaintmp->syncs[i] < cwaintmp->syncs[bestsync]) {
+	    	    bestsync = i;
+		}
+	    } else {
+	        bestsync = i;
+	    }
+	}
+    }
+
+    if (cwaintmp->syncsrc >= 0) {
+	if (debug > 3)
+	    printk(KERN_INFO "cwain: bestsync %d cwaintmp->syncsrc %d\n", bestsync, cwaintmp->syncsrc);
+	
+	if (bestsync == cwaintmp->syncsrc) {
+	    if (debug > 3)
+		printk(KERN_INFO "cwain: already on best syncsrc %d\n", bestsync);
+	    return;
+	}
+
+	/* if we have a better syncsrc */
+	if (bestsync < cwaintmp->spans) {
+	    if (debug)
+		printk(KERN_INFO "cwain: found better syncsrc %d\n", bestsync);
+	    cwain_set_master(cwaintmp, bestsync);
+	    return;		    
+	}
+    }
+
+    /* if reelection failed, find internal sync source, if not forbidden! */
+    if ((cwaintmp->syncsrc == -1) && !require_ext_clock) {
+	/* no master yet */
+	if (debug > 3)
+	    printk(KERN_INFO "cwain: no clocksource found cardID %d\n", cwaintmp->cardID);
+	for (i=0; i < cwaintmp->spans; i++) {
+	    /* find the first internal source */
+	    if (debug > 3)
+	        printk(KERN_INFO "cwain: cwaintmp->syncs[%d] = %d\n", i, cwaintmp->syncs[i]);
+	    if (cwaintmp->syncs[i] == 0) {
+		if (debug)
+		    printk(KERN_INFO "cwain: using internal clock of span %d\n", i);
+		cwain_set_master(cwaintmp, i);
+		return;
+	    }
+	}
+    }
+
+    /* if we have no internal sync source the only thing we can do is to enable any of the possible sync sources*/
+    if (cwaintmp->syncsrc == -1) {
+	/* find the first possible sync source with framing */
+        for (i=0; i < cwaintmp->spans; i++) {
+	    if (cwaintmp->syncs[i] > 0) {
+		if (debug)
+		    printk(KERN_INFO "cwain: desperately using clock of span %d\n", i);
+		cwain_set_master(cwaintmp, i);
+		break;
+	    }
+	}
+    }
+}
+
+
+static void cwain_assign(struct zt_cwain_card *cwaincard, int src_span, int src_chan, int dst_span, int dst_chan, int timeslot, int use_pcm_bus) {
+    int dst_fifo = dst_chan - 1; 
+    int src_fifo = src_chan - 1; 
+    int src_hfc_chan = src_chan;
+    int dst_hfc_chan = dst_chan;
+    struct zt_cwain *cwain_src = NULL, *cwain_dst = NULL;
+    unsigned long flags = 0;
+    /*  hw_hdlc == 1
+	fifo    00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 >< 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
+	time 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+	chan    00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
+
+	 hw_hdlc == 0
+	fifo    00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
+	time 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+	chan    00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
+    */
+
+    if (hw_hdlc) {
+	if (dst_chan > 0x10) {
+	    dst_fifo--; 
+	}
+	if (src_chan > 0x10) {
+	    src_fifo--; 
+	}
+    }
+
+    if (cwaincard) {
+	cwain_src = cwaincard->span[src_span];
+	cwain_dst = cwaincard->span[dst_span];
+    } else {
+	return;
+    }
+    
+    if (debug)
+	printk(KERN_INFO "cwain: assign(src_span %d (ID %d), src_chan %d, dst_span %d (ID %d), dst_chan %d, use_pcm_bus %d, timeslot %d\n", src_span, cwain_src->cardID, src_chan, dst_span, cwain_dst->cardID, dst_chan, use_pcm_bus, timeslot);
+    
+    spin_lock_irqsave(&cwaincard->lock,flags);
+
+	/* assign the data received from the hfc-channel "src_hfc_chan" to transmit pcm slot "timeslot" on pin STIO1 */
+	/* TX up */
+	cwain_outb(cwain_src,cwain_R_FIFO, src_fifo << 1); 
+        cwain_waitbusy(cwain_src);
+	cwain_outb(cwain_src,cwain_R_INC_RES_FIFO,0x2);
+        cwain_waitbusy(cwain_src);
+        cwain_outb(cwain_src,cwain_A_CON_HDLC,0xC2);
+        cwain_outb(cwain_src,cwain_A_CHANNEL,src_hfc_chan << 1); 
+
+        cwain_outb(cwain_src,cwain_R_SLOT,timeslot << 1);
+	if (use_pcm_bus) {
+	    cwain_outb(cwain_src,cwain_A_SL_CFG, (src_hfc_chan << 1) | 0 | 0x80);
+	} else {
+	    cwain_outb(cwain_src,cwain_A_SL_CFG, (src_hfc_chan << 1) | 0 | 0x40);
+	}
+        cwain_src->ts_tx[src_chan - 1] = timeslot;
+
+	/* assign the data received from the receive pcm slot "timeslot" on pin STIO1 to the hfc-channel "dst_hfc_chan"*/
+	/* RX down */ 
+	cwain_outb(cwain_dst,cwain_R_FIFO, (dst_fifo << 1) | 1);
+        cwain_waitbusy(cwain_dst);
+	cwain_outb(cwain_dst,cwain_R_INC_RES_FIFO,0x2);
+        cwain_waitbusy(cwain_dst);
+        cwain_outb(cwain_dst,cwain_A_CHANNEL,(dst_hfc_chan << 1) | 1);
+        cwain_outb(cwain_dst,cwain_A_CON_HDLC,0xC2);
+    
+        cwain_outb(cwain_dst,cwain_R_SLOT,(timeslot << 1) | 1); 
+        if (use_pcm_bus) {
+    	    cwain_outb(cwain_dst,cwain_A_SL_CFG, (dst_hfc_chan << 1) | 1 | 0xC0);
+	} else {
+	    cwain_outb(cwain_dst,cwain_A_SL_CFG, (dst_hfc_chan << 1) | 1 | 0x40);
+	}
+        cwain_dst->ts_rx[dst_chan - 1] = timeslot;
+// printk(KERN_INFO "cwain: span %d ts_tx[%d] = %d\n", src_span, src_chan - 1, timeslot);
+// printk(KERN_INFO "cwain: span %d ts_rx[%d] = %d\n", dst_span, dst_chan - 1, timeslot);
+
+    spin_unlock_irqrestore(&cwaincard->lock,flags);
+}
+
+static void cwain_unassign(struct zt_cwain *cwaintmp, int chan, int timeslot, int lock) {
+    int fifo = chan - 1;
+    int hfc_chan = chan;
+    unsigned long flags = 0;
+
+    if (hw_hdlc && (chan > 0x10)) {
+	fifo--; 
+    }
+
+    if (lock) spin_lock_irqsave(&cwaintmp->lock,flags);
+
+	/* unassign from_where we receive and to_where we transmit */
+	
+
+	/* we were transmitting on cwaintmp->ts_tx[chan - 1] */
+        cwain_outb(cwaintmp,cwain_R_SLOT, cwaintmp->ts_tx[chan - 1] << 1); 
+	cwain_outb(cwaintmp,cwain_A_SL_CFG, 0x0);
+        cwaintmp->ts_tx[chan - 1] = -1;
+
+	/* we were receiving on cwaintmp->ts_rx[chan - 1] */
+        cwain_outb(cwaintmp,cwain_R_SLOT, (cwaintmp->ts_rx[chan - 1] << 1) | 1); 
+	cwain_outb(cwaintmp,cwain_A_SL_CFG, 0x0);
+        cwaintmp->ts_rx[chan - 1] = -1;
+
+	/* restore our tx fifo */
+	cwain_outb(cwaintmp,cwain_R_FIFO,fifo << 1);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+	cwain_outb(cwaintmp,cwain_A_CHANNEL,hfc_chan  << 1);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+
+	/* restore our rx fifo */
+	cwain_outb(cwaintmp,cwain_R_FIFO,(fifo << 1) | 1);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+	cwain_outb(cwaintmp,cwain_A_CHANNEL,(hfc_chan << 1) | 1);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	
+//  printk(KERN_INFO "cwain: ts_tx[%d] = %d\n", chan - 1, -1);
+// printk(KERN_INFO "cwain: ts_rx[%d] = %d\n", chan - 1, -1);
+    if (lock) spin_unlock_irqrestore(&cwaintmp->lock,flags);
+}
+
+
+static int ztcwain_dacs(struct zt_chan *dst, struct zt_chan *src) {
+	struct zt_cwain *cwaintmp = NULL;
+	int use_pcm_bus = 0;
+	int timeslot = 0;
+	if (hdlcnet) return -1;
+	if (!dacs) return -1;
+
+	if (src) {
+		cwaintmp = src->pvt;
+
+		if ((src->pvt != dst->pvt) && (src->span->pvt != dst->span->pvt)) {
+		    if (dacs == 2) {
+			if (debug)
+			    printk("cwain: Assigning %d/%d -> %d/%d, different cards!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+			timeslot = src->channo;
+			use_pcm_bus = 1;
+		    } else {
+			if (debug)
+			    printk("cwain: Not Assigning %d/%d -> %d/%d, different cards!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+			return -1;
+		    }
+		} else {
+		    if (debug)
+			printk("cwain: Assigning %d/%d -> %d/%d, same cwain card!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+			timeslot = src->channo;
+/*		    if (dacs == 2) {
+			timeslot = src->channo;
+		    } else {
+			timeslot = (src->span->offset * 30) + (src->chanpos - 1);
+		    } */
+		    if (src->span == dst->span) {
+			use_pcm_bus = 0;
+		    } else {
+			use_pcm_bus = 1;
+		    }
+		}
+	
+		if (hw_hdlc && ((src->chanpos == 16) || (dst->chanpos == 16))) {
+		    if (debug)
+			printk("cwain: Not Assigning D-channel %d/%d -> %d/%d!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+		} else {
+		    cwain_assign(src->span->pvt, src->span->offset, src->chanpos, dst->span->offset, dst->chanpos, timeslot, use_pcm_bus);
+		    if (debug)
+			printk("cwain: Assigning channel %d/%d -> %d/%d!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+		}
+	} else {
+		cwaintmp = dst->pvt;
+		if (hw_hdlc && (dst->chanpos == 16)) {
+		    if (debug)
+			printk("cwain: Not Unassigning D-channel %d/%d!\n", dst->span->offset, dst->chanpos);
+		} else {
+			timeslot = dst->channo;
+/*		    if (dacs == 2) {
+			timeslot = dst->channo;
+		    } else {
+			timeslot = (dst->span->offset * 30) + (dst->chanpos - 1);
+		    } */
+//	    printk(KERN_INFO "cwain: unassing chan %d ts_rx %d ts_tx %d ?\n", dst->chanpos - 1, cwaintmp->ts_rx[dst->chanpos - 1], cwaintmp->ts_tx[dst->chanpos - 1]);
+		    if ((cwaintmp->ts_rx[dst->chanpos - 1] > -1) || (cwaintmp->ts_tx[dst->chanpos - 1] > -1)) {
+		        cwain_unassign(cwaintmp, dst->chanpos, timeslot, 1);
+			if (debug)
+			    printk("cwain: Unassigning channel %d/%d!\n", dst->span->offset, dst->chanpos);
+		    }
+		}
+	}
+	return 0;
+}
+
+static inline void cwain_isr_run(struct zt_cwain *cwaintmp, int ticks) {
+    int dchan;
+    int chan = 0;
+
+    if (cwaintmp->span.flags & ZT_FLAG_RUNNING) {
+
+	if (hdlcnet) {
+	    dchan = 0;
+	} else {
+	    dchan = 15;
+	}
+	cwaintmp->chans[dchan].bytes2transmit = 0;
+	cwaintmp->chans[dchan].eoftx = 0;
+	if (hw_hdlc) {
+	    cwain_dfifo_check(cwaintmp);
+	}
+
+        /* oh zaptel! tell us what to transmit... */
+        zt_transmit(&cwaintmp->span);
+
+	if (hdlcnet) {
+
+	        if (cwaintmp->sync) {
+		    cwain_dfifo_tx(cwaintmp);
+		}
+
+		/* d-chan data */
+		while (cwaintmp->drx > 0) {
+		    cwaintmp->chans[dchan].bytes2receive = 0;
+		    cwaintmp->chans[dchan].eofrx = 0;
+		    if (debug > 3)
+		        printk(KERN_CRIT "drx = %d\n", cwaintmp->drx);
+		    if (cwain_dfifo_rx(cwaintmp)) {
+			zt_receive(&(cwaintmp->span)); // XXX
+		    }
+		}
+		cwaintmp->chans[dchan].bytes2receive = 0;
+		cwaintmp->chans[dchan].eofrx = 0;
+	} else {
+	    if (hw_hdlc) {
+		/* B chans 1-15 mapped to fifos 0-14 */
+	        /* B chans 17-31 mapped to fifos 15-29 */
+		for (chan=0; chan < 31; chan++) {
+		    /* copy to fbuffer */
+	    	    if ((ticks < 1) || (ticks > 8)) {
+			printk(KERN_INFO "cwain: whicked ticks make whicked tricks (%d)\n",cwaintmp->ticks);
+		    } else {
+			if (chan != dchan) {
+			    memcpy(&cwaintmp->ftxbuf[chan][(ticks-1)*8], cwaintmp->txbuf[chan], ZT_CHUNKSIZE);
+			}
+		    }
+		}
+	
+	        if (cwaintmp->sync) {
+		    cwain_dfifo_tx(cwaintmp);
+		}
+
+    		cwaintmp->chans[dchan].bytes2receive = 0;
+		cwaintmp->chans[dchan].bytes2transmit = 0;
+		cwaintmp->chans[dchan].eofrx = 0;
+		cwaintmp->chans[dchan].eoftx = 0;
+
+		for (chan=0; chan < 31; chan++) {
+		    /* copy from fbuffer */
+		    if (chan != dchan) {
+			memcpy(cwaintmp->rxbuf[chan], &cwaintmp->frxbuf[chan][(ticks-1)*8], ZT_CHUNKSIZE);
+		        zt_ec_chunk(&cwaintmp->span.chans[chan], cwaintmp->span.chans[chan].readchunk, cwaintmp->span.chans[chan].writechunk);
+		    }
+		}
+
+		/* d-chan data */
+		if (cwaintmp->drx > 0) {
+		    if (debug > 3)
+			printk(KERN_CRIT "drx = %d\n", cwaintmp->drx);
+		    cwain_dfifo_rx(cwaintmp);
+		}
+	    } else {
+		/* software HDLC */
+        	for (chan=0; chan < 31; chan++) {
+        	    /* copy to fbuffer */
+            	    if ((ticks < 1) || (ticks > 8)) {
+                	printk(KERN_INFO "cwain: whicked ticks make whicked tricks (%d)\n",cwaintmp->ticks);
+            	    } else {
+                	memcpy(&cwaintmp->ftxbuf[chan][(ticks-1)*8], cwaintmp->txbuf[chan], ZT_CHUNKSIZE);
+            	    }
+        	}
+
+        	for (chan=0; chan < 31; chan++) {
+            	    /* copy from fbuffer */
+            	    memcpy(cwaintmp->rxbuf[chan], &cwaintmp->frxbuf[chan][(ticks-1)*8], ZT_CHUNKSIZE);
+            	    zt_ec_chunk(&cwaintmp->span.chans[chan], cwaintmp->span.chans[chan].readchunk, cwaintmp->span.chans[chan].writechunk);
+        	}
+	    }
+	}
+	/* oh zaptel! thou shall receive! */
+	zt_receive(&(cwaintmp->span));
+    }
+}
+
+static inline void cwain_isr_err(struct zt_cwain *cwaintmp) {
+    unsigned long flags = 0;
+    unsigned short crc, vio, ebit, fas;
+    unsigned short rx_slip, tx_slip;
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    crc = (cwain_inb(cwaintmp, cwain_R_CRC_ECH) << 8) | cwain_inb(cwaintmp, cwain_R_CRC_ECL);
+    vio = (cwain_inb(cwaintmp, cwain_R_VIO_ECH) << 8) | cwain_inb(cwaintmp, cwain_R_VIO_ECL);
+    ebit = (cwain_inb(cwaintmp, cwain_R_E_ECH) << 8) | cwain_inb(cwaintmp, cwain_R_E_ECL);
+    fas = (cwain_inb(cwaintmp, cwain_R_FAS_ECH) << 8) | cwain_inb(cwaintmp, cwain_R_FAS_ECL);
+    rx_slip = cwain_inb(cwaintmp, cwain_R_SLIP) & 0x01;
+    tx_slip = (cwain_inb(cwaintmp, cwain_R_SLIP) >> 4) & 0x01;
+    if (cwaintmp->sync) {
+        if (rx_slip) {
+	    cwain_outb(cwaintmp,cwain_R_RX_OFFS,0x06);
+	    if (debug)
+		printk(KERN_INFO "cwain: cardID %d detected RX slip\n", cwaintmp->cardID);
+	}
+	if (tx_slip) {
+	    cwain_outb(cwaintmp,cwain_R_TX_OFFS,0x06);
+	    if (debug)
+    		printk(KERN_INFO "cwain: cardID %d detected TX slip\n", cwaintmp->cardID);
+	}
+    }
+
+    cwaintmp->span.crc4count += crc;
+    cwaintmp->span.bpvcount += vio;
+    cwaintmp->span.ebitcount += ebit;
+    cwaintmp->span.fascount += fas;
+			
+    if ((debug > 3) && (crc || vio || ebit || fas)) 
+        printk(KERN_INFO "cwain: CRC4 %d BPVIOL %d EBIT %d FAS %d\n", cwaintmp->span.crc4count, cwaintmp->span.bpvcount, cwaintmp->span.ebitcount, cwaintmp->span.fascount);
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+}
+						    		    
+
+static inline void cwain_audio_run(struct zt_cwain *cwaintmp) {
+    int fifo=0;
+    
+    if (cwaintmp->wdp) {
+	if (cwaintmp->wdp == 0x04) {
+	    cwaintmp->wdp = 0x08;
+	} else {
+	    cwaintmp->wdp = 0x04;
+	}
+	cwain_outb(cwaintmp, cwain_R_GPIO_OUT0, cwaintmp->wdp);
+    }
+    
+    if (hdlcnet) return;
+    
+    if (hw_hdlc) {
+	for (fifo=0; fifo < 30; fifo++) {
+	    /* B tx */
+	    cwain_fifo_tx(cwaintmp, fifo);
+	}
+
+	for (fifo=0; fifo < 30; fifo++) {
+	    /* B rx */
+	    cwain_fifo_rx(cwaintmp, fifo);
+	}
+    } else {
+	/* software HDLC */
+	for (fifo=0; fifo < 31; fifo++) {
+	    /* B tx */
+	    cwain_fifo_tx(cwaintmp, fifo);
+	}
+
+	for (fifo=0; fifo < 31; fifo++) {
+	    /* B rx */
+	    cwain_fifo_rx(cwaintmp, fifo);
+	}
+    }
+}
+
+int cwain_isr_sync(struct zt_cwain *cwainspan) {
+    unsigned char sync_sta;
+    unsigned char sync_ok = 0;
+    unsigned char jatt_sta = 0;
+    unsigned long flags = 0;
+//    int chan = 0;
+    int res = 0; /* assume no l1event */
+
+    if (!cwainspan->span.flags & ZT_FLAG_RUNNING) {
+	return res;
+    }
+
+    spin_lock_irqsave(&cwainspan->lock,flags);
+    sync_sta = cwain_inb(cwainspan, cwain_R_SYNC_STA);
+
+    if ((!cwainspan->sync) || (sync_sta != cwainspan->sync_sta)) {
+
+	if (debug > 2)
+	    printk(KERN_CRIT "cwain: cardID %d R_SYNC_STA =%#x\n", cwainspan->cardID, sync_sta);
+
+	if (cwainspan->span.lineconfig & ZT_CONFIG_CRC4) {
+	    if ((sync_sta & 0x80) == 0x80) {
+		/* reset MFA detection */
+		cwain_outb(cwainspan ,cwain_R_RX_SL0_CFG1,0x41);
+	    } else if ((sync_sta & 0x27) == 0x27) {
+		if (((cwainspan->sync_sta & 0x27) != 0x27) && cwainspan->span.syncsrc) {
+		    /* sync achieved, restart JATT */
+/*		    if (debug)
+			printk(KERN_INFO "cwain: %d starting jitter attenuator\n", cwainspan->cardID); */
+//		    cwain_outb(cwainspan, cwain_R_JATT_CFG,0x9c);
+		}
+		sync_ok = 0x27;
+	    } else {
+		sync_ok = 0x00;
+	    }
+	} else {
+	    if ((sync_sta & 0x07) == 0x07) {
+		if (((cwainspan->sync_sta & 0x7) != 0x7) && cwainspan->span.syncsrc) {
+		    /* sync achieved, restart JATT */
+	/*	    if (debug)
+			printk(KERN_INFO "cwain: %d starting jitter attenuator\n", cwainspan->cardID); */
+//		    cwain_outb(cwainspan, cwain_R_JATT_CFG,0x9c);
+		}
+		sync_ok = 0x07;
+	    } else {
+		sync_ok = 0x00;
+	    }
+	}
+
+	cwainspan->sync_sta = sync_sta;
+
+	if (cwainspan->span.syncsrc) {
+	    jatt_sta = cwain_inb(cwainspan, cwain_R_JATT_STA);
+	    if ((jatt_sta & 0x60) != 0x60) {
+		if (debug > 2)
+		    printk(KERN_INFO "cwain: %d jitter attenuator %#x\n", cwainspan->cardID, (jatt_sta & 0x60) >> 5);
+		sync_ok = 0x00;
+	    } else if (!cwainspan->sync && sync_ok) {
+		if (debug)
+		    printk(KERN_CRIT "cwain: %d jitter attenuator %#x ok!\n", cwainspan->cardID, (jatt_sta & 0x60) >> 5);
+	    }
+	}
+
+	if (sync_ok && (!cwainspan->sync)) {
+	    if (debug)
+	        printk(KERN_INFO "cwain: cardID %d link up\n", cwainspan->cardID);
+
+	    cwain_outb(cwainspan,cwain_R_RX_OFFS,0x06);
+	    cwain_outb(cwainspan,cwain_R_TX_OFFS,0x06);
+
+	    cwainspan->span.crc4count = 0;
+    	    cwainspan->span.bpvcount = 0;
+	    cwainspan->span.ebitcount = 0;
+    	    cwainspan->span.fascount = 0;
+	    cwainspan->span.alarms = ZT_ALARM_NONE;
+	    zt_alarm_notify(&cwainspan->span);
+	    res = 1;
+	}
+	if (!sync_ok && cwainspan->sync) {
+	    if (debug)
+	        printk(KERN_INFO "cwain: cardID %d link down\n", cwainspan->cardID);
+	    
+	    cwainspan->span.crc4count = 0;
+    	    cwainspan->span.bpvcount = 0;
+	    cwainspan->span.ebitcount = 0;
+    	    cwainspan->span.fascount = 0;
+	    cwainspan->span.alarms = ZT_ALARM_RED;
+	    zt_alarm_notify(&cwainspan->span);
+	    res = 1;
+	}
+
+	cwainspan->sync = sync_ok;
+	if (sync_ok) {
+	    switch (cwainspan->type) {
+		case 0xb553:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET singleE1 PCI ISDN %d (cardID %d) SYNCED",cwainspan->cardno,cwainspan->cardID);
+	    	    break;
+    		case 0xb554:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET doubleE1 PCI ISDN %d (cardID %d) (1 E1 port) SYNCED",cwainspan->cardno,cwainspan->cardID);
+		    break;
+    		case 0xb555:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET doubleE1 PCI ISDN 2.0 %d (cardID %d) (1 E1 port) SYNCED",cwainspan->cardno,cwainspan->cardID);
+		    break;
+	    }
+	} else {
+	    switch (cwainspan->type) {
+		case 0xb553:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET singleE1 PCI ISDN %d (cardID %d) NO SYNC (sync_sta = %#x)",cwainspan->cardno,cwainspan->cardID, sync_sta);
+		    break;
+    		case 0xb554:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET doubleE1 PCI ISDN %d (cardID %d) (1 E1 port) NO SYNC (sync_sta = %#x)",cwainspan->cardno,cwainspan->cardID, sync_sta);
+	    	    break;
+    		case 0xb555:
+		    snprintf(cwainspan->span.desc, sizeof(cwainspan->span.desc), "Junghanns.NET doubleE1 PCI ISDN 2.0 %d (cardID %d) (1 E1 port) NO SYNC (sync_sta = %#x)",cwainspan->cardno,cwainspan->cardID, sync_sta);
+	    	    break;
+	    }
+	}
+	cwain_doLEDs(cwainspan);
+    }
+    spin_unlock_irqrestore(&cwainspan->lock,flags);
+    return res;
+}
+
+static int ztcwain_proc_read(struct zt_span *span, char *output) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    struct zt_cwain *cwaintmp;
+    unsigned long flags;
+    unsigned char fstate;
+
+    if (cwaincard == NULL) {
+	printk(KERN_CRIT "cwain: cwaincard == NULL!\n");
+	return 0;
+    }
+    cwaintmp = cwaincard->span[span->offset];
+    if (cwaintmp == NULL) {
+	printk(KERN_CRIT "cwain: cwaintmp == NULL!\n");
+	return 0;
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+	fstate = cwain_inb(cwaintmp, cwain_R_E1_RD_STA);
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    return sprintf(output, "cwain: span state = F%d.", fstate & 0x7);
+}
+
+/* called locked */
+int cwain_isr_fifo(struct zt_cwain *cwainspan, unsigned char status) {
+    unsigned char irq_foview,fi;
+
+    if (status & 0x80) {
+	/* fifo irq */
+	irq_foview = cwain_inb(cwainspan,cwain_R_IRQ_OVIEW);
+	if (irq_foview & 0x80) {
+	    fi = cwain_inb(cwainspan,cwain_R_IRQ_FIFO_BL7);
+	    if (fi & 0x80) {
+		if (debug > 4)
+		    printk(KERN_CRIT "cwain: fifo 31 RX irq for D channel cardID %d\n", cwainspan->cardID);
+	    }
+	    if (fi & 0x40) {
+		if (debug > 4)
+		    printk(KERN_CRIT "cwain: fifo 31 TX irq for D channel cardID %d\n", cwainspan->cardID);
+	    }
+	}
+	return 1;
+    }
+    return 0;
+}
+
+ZAP_IRQ_HANDLER(cwain_dummy_interrupt) {
+    struct zt_cwain_card *cwaintmp = dev_id;
+    if (!cwaintmp) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    if (debug > 3)
+	printk(KERN_INFO "cwain: dummy irq\n");
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+
+ZAP_IRQ_HANDLER(cwain_interrupt) {
+    struct zt_cwain_card *cwaintmp = dev_id;
+    unsigned char status, status2, status_tmp, irq_misc, irq_misc2 = 0;
+    unsigned long flags;
+    int i = 0;
+    int l1event = 0;
+    
+    if (!cwaintmp || cwaintmp->dead) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    
+    spin_lock_irqsave(&(cwaintmp->lock),flags);
+	status = cwain_inb(cwaintmp->span[0],cwain_R_STATUS);
+	status2 = 0;
+
+	for (i=0;i<cwaintmp->spans;i++) {
+	    if (i == 0) {
+		status_tmp = status;
+	    } else {
+		status_tmp = cwain_inb(cwaintmp->span[i],cwain_R_STATUS);
+		status2 = status_tmp;
+	    }
+	    cwain_isr_fifo(cwaintmp->span[i], status_tmp);
+	}
+    spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+
+    if (!(status & 0x80) && !(status & 0x40)) {
+	// it's not us!
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    // misc irq
+    if (status & 0x40) {
+	spin_lock_irqsave(&(cwaintmp->lock),flags);
+	    irq_misc = cwain_inb(cwaintmp->span[0],cwain_R_IRQ_MISC);
+	spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+	if (irq_misc & 0x2)  {
+	    /* cwain timer */
+	    cwaintmp->ticks++;
+	    if (cwaintmp->ticks == 1) {
+		for (i=0;i<cwaintmp->spans;i++) {
+		    cwain_audio_run(cwaintmp->span[i]);
+		}
+	    }
+	    for (i=0;i<cwaintmp->spans;i++) {
+		cwain_isr_run(cwaintmp->span[i], cwaintmp->ticks);
+	    }
+	    if (cwaintmp->ticks == (cwain_FRAME_SIZE / ZT_CHUNKSIZE)) {
+		cwaintmp->ticks = 0;
+	    }
+	} 
+	if (irq_misc & 0x1) {
+	    /* state machine */
+	    if (debug > 4)
+		printk(KERN_INFO "cwain: state machine irq\n");
+	    l1event++;
+	}
+	if (irq_misc & 0x10) {
+	    for (i=0;i<cwaintmp->spans;i++) {
+	        cwain_isr_err(cwaintmp->span[i]);
+	    }
+    	    if (l1event == 0) {
+		/* just in case we missed it */
+		for (i=0;i<cwaintmp->spans;i++) {
+    	    	    l1event += cwain_isr_sync(cwaintmp->span[i]);
+    		}
+	    }
+	}
+    }
+
+    // misc irq
+    if (status2 & 0x40) {
+	if (cwaintmp->spans == 2) {
+	    spin_lock_irqsave(&(cwaintmp->lock),flags);
+		irq_misc2 = cwain_inb(cwaintmp->span[1],cwain_R_IRQ_MISC);
+	    spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+	}
+	if (irq_misc2 & 0x1) {
+	    /* state machine 2 */
+	    if (debug > 4)
+		printk(KERN_INFO "cwain: state machine 2 irq\n");
+	    l1event++;
+	}
+    }
+
+    if (l1event > 0) {
+//	printk(KERN_INFO "cwain: l1event %d\n", l1event);
+    	for (i=0;i<cwaintmp->spans;i++) {
+    	    cwain_isr_sync(cwaintmp->span[i]);
+    	}
+        if (cwaintmp->spans == 2) {
+    	    cwain_check_timing(cwaintmp);
+        }
+    }
+
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+static int ztcwain_open(struct zt_chan *chan) {
+//    printk(KERN_INFO "cwain: channel %d opened.\n",chan->channo);
+#ifndef LINUX26
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztcwain_close(struct zt_chan *chan) {
+//    printk(KERN_INFO "cwain: channel %d closed.\n",chan->channo);
+#ifndef LINUX26
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztcwain_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int ztcwain_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int ztcwain_startup(struct zt_span *span) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    struct zt_cwain *cwaintmp;
+    unsigned long flags;
+    int alreadyrunning;
+    int i=0;
+    int idx = 0;
+
+//    printk(KERN_INFO "cwain: startup spanno %d offset %d\n", span->spanno, span->offset);
+
+    if (cwaincard == NULL) {
+	printk(KERN_CRIT "cwain: cwaincard == NULL!\n");
+	return 0;
+    }
+
+    cwaintmp = cwaincard->span[span->offset];
+    if (cwaintmp == NULL) {
+	printk(KERN_CRIT "cwain: cwaintmp == NULL!\n");
+	return 0;
+    }
+
+    
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+//    printk(KERN_CRIT "already running %d flags %d\n", alreadyrunning, span->flags);
+
+    if (!alreadyrunning) {
+	for (i=0; i<31 ; i++) {
+	    cwaintmp->ts_rx[i] = -1;
+	    cwaintmp->ts_tx[i] = -1;
+	}
+
+	if (hdlcnet) {
+		span->chans[0].flags &= ~ZT_FLAG_HDLC;
+		span->chans[0].flags |= ZT_FLAG_BRIDCHAN; /* yes! */
+
+    		memset(cwaintmp->dtxbuf,0x0,sizeof(cwaintmp->dtxbuf));
+		span->chans[0].writechunk = cwaintmp->dtxbuf;
+
+		cwaintmp->chans[0].maxbytes2transmit = 248;
+//		cwaintmp->chans[0].maxbytes2transmit = 64;
+
+		memset(cwaintmp->drxbuf,0x0,sizeof(cwaintmp->drxbuf));
+    		span->chans[0].readchunk = cwaintmp->drxbuf;
+	} else {
+	    if (hw_hdlc) {
+		span->chans[15].flags &= ~ZT_FLAG_HDLC;
+		span->chans[15].flags |= ZT_FLAG_BRIDCHAN; /* yes! */
+    
+		/* setup B channel buffers (8 bytes each) */
+		for (i=0; i<31 ; i++) {
+		    if (i != 15) {
+		        memset(cwaintmp->rxbuf[i],0x0,sizeof(cwaintmp->rxbuf[i]));
+    			memset(cwaintmp->txbuf[i],0x0,sizeof(cwaintmp->txbuf[i]));
+    		        span->chans[i].readchunk = cwaintmp->rxbuf[i];
+			span->chans[i].writechunk = cwaintmp->txbuf[i];
+		    }
+		}
+		/* setup D channel buffer */
+    		memset(cwaintmp->dtxbuf,0x0,sizeof(cwaintmp->dtxbuf));
+		span->chans[15].writechunk = cwaintmp->dtxbuf;
+		cwaintmp->chans[15].maxbytes2transmit = sizeof(cwaintmp->dtxbuf) / 2;
+
+		memset(cwaintmp->drxbuf,0x0,sizeof(cwaintmp->drxbuf));
+    		span->chans[15].readchunk = cwaintmp->drxbuf;
+	    } else {
+		/* software HDLC */
+    		/* setup B channel buffers (8 bytes each) */
+    	        for (i=0; i<31 ; i++) {
+        	    memset(cwaintmp->rxbuf[i],0x0,sizeof(cwaintmp->rxbuf[i]));
+    		    memset(cwaintmp->txbuf[i],0x0,sizeof(cwaintmp->txbuf[i]));
+        	    span->chans[i].readchunk = cwaintmp->rxbuf[i];
+        	    span->chans[i].writechunk = cwaintmp->txbuf[i];
+    		}	    
+	    }
+	}
+	span->flags |= ZT_FLAG_RUNNING;
+    } else {
+	printk(KERN_CRIT "already running\n");
+	return 0;
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    /* irqs off */
+    cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0); 
+
+    if (hdlcnet) {
+	    /* map ts 1 to 31 to fifo 31 */
+	    /* TX fifo */
+//	cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x3E);
+	    cwain_outb(cwaintmp,cwain_R_FIRST_FIFO,0x1F << 1);
+	    cwain_waitbusy(cwaintmp);
+	    
+	    idx = 0;
+	    for (i=1; i<=31; i++) {
+		cwain_outb(cwaintmp,cwain_R_FSM_IDX, idx++);
+		cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+		if (i == 31) {
+		    cwain_outb(cwaintmp,cwain_A_FIFO_SEQ, (0x1F << 1) | 1);
+//		    if (debug) printk(KERN_INFO "cwain: cardID %d fsm_idx %d channel %d fifo_seq %#x\n", cwaintmp->cardID, idx - 1, i , (0x1f << 1) | 1);
+		} else {
+		    cwain_outb(cwaintmp,cwain_A_FIFO_SEQ, 0x1F << 1);
+//		    if (debug) printk(KERN_INFO "cwain: cardID %d fsm_idx %d channel %d fifo_seq %#x\n", cwaintmp->cardID, idx - 1, i  ,0x1f << 1);
+		}
+	    }
+
+	    /* map ts 1 to 31 to fifo 31 */
+	    /* RX fifo */
+	    
+	    for (i=1; i<=31; i++) {
+		cwain_outb(cwaintmp,cwain_R_FSM_IDX, idx++);
+		cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+		if (i == 31) {
+		    cwain_outb(cwaintmp,cwain_A_FIFO_SEQ, 0x40);
+//		    if (debug) printk(KERN_INFO "cwain: cardID %d fsm_idx %d channel %d fifo_seq %#x\n", cwaintmp->cardID, idx - 1, i,  0x40);
+		} else {
+		    cwain_outb(cwaintmp,cwain_A_FIFO_SEQ, (0x1F << 1) | 1);
+//		    if (debug) printk(KERN_INFO "cwain: cardID %d fsm_idx %d channel %d fifo_seq %#x\n", cwaintmp->cardID, idx - 1, i,  (0x1f << 1) | 1);
+		}
+	    }
+
+//	cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x36);
+
+	cwain_outb(cwaintmp,cwain_R_FIFO,0x1F << 1);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0xc);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK, 0x1);
+
+	cwain_outb(cwaintmp,cwain_R_FIFO,(0x1F << 1) | 1);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0xc);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK, 0x1);
+
+//	cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x3E);
+
+    } else {
+	if (hw_hdlc) {
+	    /* setup D-FIFO TX */
+	    cwain_outb(cwaintmp,cwain_R_FIFO,0x1F << 1);
+	    cwain_waitbusy(cwaintmp);
+    	    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    	    cwain_waitbusy(cwaintmp);
+    	    cwain_outb(cwaintmp,cwain_A_CON_HDLC,0xd);
+	    cwain_outb(cwaintmp,cwain_A_SUBCH_CFG,0x0);
+    	    cwain_outb(cwaintmp,cwain_A_CHANNEL,0x10 << 1);
+	    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+
+            /* setup D-FIFO RX */
+	    cwain_outb(cwaintmp,cwain_R_FIFO,(0x1F << 1) | 1);
+    	    cwain_waitbusy(cwaintmp);
+	    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    	    cwain_waitbusy(cwaintmp);
+    	    cwain_outb(cwaintmp,cwain_A_CON_HDLC,0xd);
+    	    cwain_outb(cwaintmp,cwain_A_SUBCH_CFG,0x0);
+    	    cwain_outb(cwaintmp,cwain_A_CHANNEL,(0x10 << 1) | 1);
+    	    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+
+    	    /* setup B-FIFOs TX */
+    	    /* map ts 1 to 15 to fifos 0 to 14 */
+	    for (i=1; i<16 ; i++) {
+		cwain_outb(cwaintmp,cwain_R_FIFO,(i - 1) << 1);
+		cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+		cwain_waitbusy(cwaintmp);
+		cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+		cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+		cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    	    }
+	    /* map ts 17 to 31 to fifos 15 to 29 */
+    	    for (i=17; i<32 ; i++) {
+		cwain_outb(cwaintmp,cwain_R_FIFO,(i - 2) << 1);
+		cwain_waitbusy(cwaintmp);
+    	        cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+	        cwain_waitbusy(cwaintmp);
+    	        cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+	        cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+	        cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	    }
+
+	    /* setup B-FIFOs RX */
+	    /* map ts 1 to 15 to fifos 0 to 14 */
+	    for (i=1; i<16 ; i++) {
+		cwain_outb(cwaintmp,cwain_R_FIFO,((i-1) << 1) | 1);
+    	        cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    	        cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+    	        cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+    		cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	    }
+    	    /* map ts 17 to 31 to fifos 15 to 29 */
+	    for (i=17; i<32 ; i++) {
+		cwain_outb(cwaintmp,cwain_R_FIFO,((i-2) << 1) | 1);
+    	        cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    		cwain_waitbusy(cwaintmp);
+    		cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+    		cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+	        cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	    }
+	} else {
+	    /* software HDLC */
+    	    /* setup B-FIFOs TX */
+    	    for (i=1; i<32 ; i++) {
+        	cwain_outb(cwaintmp,cwain_R_FIFO,(i - 1) << 1);
+        	cwain_waitbusy(cwaintmp);
+        	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+        	cwain_waitbusy(cwaintmp);
+        	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+        	cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+        	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    	    }
+    	    /* setup B-FIFOs RX */
+    	    for (i=1; i<32 ; i++) {
+        	cwain_outb(cwaintmp,cwain_R_FIFO,((i-1) << 1) | 1);
+        	cwain_waitbusy(cwaintmp);
+        	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+        	cwain_waitbusy(cwaintmp);
+		cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+        	cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+        	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    	    }
+
+	}
+    }
+
+    if (debug)
+        printk(KERN_INFO "cwain: starting card %d span %d/%d.\n",cwaintmp->cardno,span->spanno,span->offset);
+
+    if (cwaincard->spans == 1) {
+	cwain_set_master(cwaincard, 0);
+    }
+    
+    /* setup E1 amplitude */
+    cwain_outb(cwaintmp,cwain_R_PWM_MD,0x20);
+    cwain_outb(cwaintmp,cwain_R_PWM0,pwm0);
+    cwain_outb(cwaintmp,cwain_R_PWM1,pwm1);
+
+    /* setup E1 transceiver */
+    cwain_outb(cwaintmp,cwain_R_TX_SL0,0xf8);
+    cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG0,0x00); /* semiautomatic mode */
+
+    cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG0,0x6); 
+
+    if (cwaintmp->span.lineconfig & ZT_CONFIG_AMI) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x82);
+	cwain_outb(cwaintmp,cwain_R_RX0,0x02);
+    } else if (cwaintmp->span.lineconfig & ZT_CONFIG_HDB3) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x81);
+	cwain_outb(cwaintmp,cwain_R_RX0,0x01);
+    }
+    cwain_outb(cwaintmp,cwain_R_TX1,0x60); /* transmitter mode */
+
+    cwain_outb(cwaintmp,cwain_R_LOS0,0x0f);
+    cwain_outb(cwaintmp,cwain_R_LOS1,0x0f);
+
+    if (cwaintmp->span.lineconfig & ZT_CONFIG_CRC4) {
+	/* crc4 multiframe */
+	cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG1,0x31);
+	cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG1,0x03);
+    } else {
+	/* doubleframe */
+	cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG1,0x0);
+	cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG1,0x0);
+    }
+
+
+    /* automatic JATT */
+    cwain_outb(cwaintmp, cwain_R_JATT_CFG,0x9c);
+    
+    /* setup sync mode */    
+    if (cwaincard->syncs[span->offset] > 0) {
+	cwain_outb(cwaintmp,cwain_R_SYNC_CTRL,0x2); // phase offset arb.
+	cwain_outb(cwaintmp,cwain_R_SYNC_OUT,0x00); // sync from e1 tx
+	/* layer 1, here we go! */
+	cwain_outb(cwaintmp,cwain_R_E1_WR_STA,0x00);
+    } else {
+	cwain_outb(cwaintmp,cwain_R_SYNC_CTRL,0x5); // pcm_f0IO
+	cwain_outb(cwaintmp,cwain_R_SYNC_OUT,0x00); // sync from e1 tx
+	/* layer 1, up! */
+	cwain_outb(cwaintmp,cwain_R_E1_WR_STA,0x11);
+    }
+
+    /* elastic buffer offsets */
+    cwain_outb(cwaintmp,cwain_R_RX_OFFS,0x06);
+    cwain_outb(cwaintmp,cwain_R_TX_OFFS,0x06);
+    
+    cwaintmp->sync = 0;
+    cwaintmp->sync_sta = 0;
+    
+    /* enable irqs */
+    if (!span->offset) {
+	cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 8 | 1); 
+    } else {
+	cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0x1); 
+    }
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    return 0;
+}
+
+static int ztcwain_shutdown(struct zt_span *span) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    struct zt_cwain *cwaintmp;
+    unsigned long flags;
+    int alreadyrunning;
+    int i=0;
+    
+    if (cwaincard == NULL) {
+	printk(KERN_CRIT "cwain: cwaincard == NULL!\n");
+	return 0;
+    }
+
+    cwaintmp = cwaincard->span[span->offset];
+    if (cwaintmp == NULL) {
+	printk(KERN_CRIT "cwain: cwaintmp == NULL!\n");
+	return 0;
+    }
+
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	return 0;
+    }
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+
+//    printk(KERN_CRIT "cwain: stopping card %d span %d/%d.\n",cwaintmp->cardno,span->spanno,span->offset);
+
+    // turn off irqs for all fifos
+    if (hdlcnet) {
+	    cwain_outb(cwaintmp,cwain_R_FIFO,(0x1F << 1) | 1);
+	    cwain_waitbusy(cwaintmp);
+	    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    } else {
+	/* disable FIFO TX */
+	for (i=0; i<0x20 ; i++) {
+	    cwain_outb(cwaintmp,cwain_R_FIFO,i << 1);
+	    cwain_waitbusy(cwaintmp);
+	    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	}
+
+	/* disable FIFO RX */
+        for (i=0; i<0x20 ; i++) {
+	    cwain_outb(cwaintmp,cwain_R_FIFO,(i << 1) | 1);
+    	    cwain_waitbusy(cwaintmp);
+    	    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+	}
+    }
+
+    /* Deactivate Layer 1 */
+    cwain_outb(cwaintmp,cwain_R_E1_WR_STA,0x10);
+
+    /* Disable transmit */
+    if (cwaintmp->span.lineconfig & ZT_CONFIG_AMI) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x02);
+    } else if (cwaintmp->span.lineconfig & ZT_CONFIG_HDB3) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x01);
+    }
+
+    cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0); 
+    cwain_inb(cwaintmp,cwain_R_STATUS);
+
+    cwain_outb(cwaintmp,cwain_R_GPIO_EN0,0x00);
+    cwain_outb(cwaintmp,cwain_R_GPIO_EN1,0x00);
+
+
+    span->flags &= ~ZT_FLAG_RUNNING;
+
+
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+
+//    printk(KERN_CRIT "cwain: card %d span %d/%d down.\n",cwaintmp->cardno,span->spanno,span->offset);
+    return 0;
+}
+
+static int ztcwain_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int ztcwain_chanconfig(struct zt_chan *chan,int sigtype) {
+//    printk(KERN_INFO "chan_config sigtype=%d\n", sigtype);
+    return 0;
+}
+
+static int ztcwain_spanconfig(struct zt_span *span,struct zt_lineconfig *lc) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    int alreadyrunning;
+
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+
+    if (!alreadyrunning) {
+	span->lineconfig = lc->lineconfig;
+	span->syncsrc = lc->sync;
+
+	cwaincard->syncs[span->offset] = lc->sync;
+	cwaincard->syncsrc = -1;
+    }
+//    printk(KERN_INFO "span_config %d lineconfig=%d syncsrc=%d\n", span->spanno, lc->lineconfig, lc->sync);
+//    cwain_check_timing(cwaincard);
+    return 0;
+}
+
+static int ztcwain_initialize(struct zt_cwain *cwaintmp, struct zt_cwain_card *cwaincard, int offset) {
+    int i=0;
+    
+	memset(&cwaintmp->span,0,sizeof(struct zt_span)); // you never can tell...
+	sprintf(cwaintmp->span.name,"cwain/%d",cwaintmp->cardno);
+	switch (cwaintmp->type) {
+	    case 0xb553:
+		snprintf(cwaintmp->span.desc, sizeof(cwaintmp->span.desc), "Junghanns.NET singleE1 PCI ISDN %d (cardID %d)",cwaintmp->cardno,cwaintmp->cardID);
+		break;
+	    case 0xb554:
+		snprintf(cwaintmp->span.desc, sizeof(cwaintmp->span.desc), "Junghanns.NET doubleE1 PCI ISDN %d (cardID %d) (1 E1 port)",cwaintmp->cardno,cwaintmp->cardID);
+		break;
+	    case 0xb555:
+		snprintf(cwaintmp->span.desc, sizeof(cwaintmp->span.desc), "Junghanns.NET doubleE1 PCI ISDN 2.0 %d (cardID %d) (1 E1 port)",cwaintmp->cardno,cwaintmp->cardID);
+		cwaintmp->wdp = 0x04;
+		break;
+	    default:
+		return -1;
+	}
+        cwaintmp->span.spanconfig = ztcwain_spanconfig;
+        cwaintmp->span.chanconfig = ztcwain_chanconfig;
+        cwaintmp->span.startup = ztcwain_startup;
+        cwaintmp->span.shutdown = ztcwain_shutdown;
+        cwaintmp->span.maint = ztcwain_maint;
+        cwaintmp->span.rbsbits = ztcwain_rbsbits;
+        cwaintmp->span.open = ztcwain_open;
+        cwaintmp->span.close = ztcwain_close;
+        cwaintmp->span.ioctl = ztcwain_ioctl;
+        cwaintmp->span.proc_read = ztcwain_proc_read;
+	cwaintmp->span.dacs = ztcwain_dacs;
+
+        cwaintmp->span.chans = cwaintmp->chans;
+	if (hdlcnet) {
+	    cwaintmp->span.channels = 1;
+	} else {
+	    cwaintmp->span.channels = 31;
+	}
+        cwaintmp->span.deflaw = ZT_LAW_ALAW;
+        cwaintmp->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_HDB3 | ZT_CONFIG_CCS; 
+        init_waitqueue_head(&cwaintmp->span.maintq);
+        cwaintmp->span.pvt = cwaincard;
+        cwaintmp->span.offset = offset;
+
+	for (i=0; i < cwaintmp->span.channels; i++) {
+	    memset(&(cwaintmp->chans[i]),0x0,sizeof(struct zt_chan));
+	    sprintf(cwaintmp->chans[i].name,"cwain%d/%d",cwain_span_count + 1,i + 1);
+	    cwaintmp->chans[i].pvt = cwaintmp;
+	    cwaintmp->chans[i].sigcap =  ZT_SIG_CLEAR | ZT_SIG_DACS;
+	    cwaintmp->chans[i].chanpos = i + 1; 
+	}
+
+	if (zt_register(&cwaintmp->span,0)) {
+	    printk(KERN_INFO "cwain: unable to register zaptel span!\n");
+	    return -1;
+	}
+//	 printk(KERN_INFO "cwain: registered zaptel span %d.\n",s+1);
+
+    return 0;
+}
+
+int cwain_reset_card(struct zt_cwain_card *cwaintmp) {
+    unsigned long flags;
+    int i = 0;
+
+    cwaintmp->irq = cwaintmp->span[0]->irq;
+    
+    if (cwaintmp->spans == 2) {
+	if (request_irq(cwaintmp->irq, cwain_interrupt, ZAP_IRQ_SHARED, "cwain2", cwaintmp)) {
+    	    printk(KERN_WARNING "cwain: unable to register irq\n");
+	    return -1;
+	}
+	if (request_irq(cwaintmp->span[1]->irq, cwain_dummy_interrupt, ZAP_IRQ_SHARED, "cwaindummy", cwaintmp)) {
+    	    printk(KERN_WARNING "cwain: unable to register irq\n");
+	    return -1;
+	}
+    } else {
+	if (request_irq(cwaintmp->irq, cwain_interrupt, ZAP_IRQ_SHARED, "cwain", cwaintmp)) {
+    	    printk(KERN_WARNING "cwain: unable to register irq\n");
+	    return -1;
+	}
+    }
+
+    spin_lock_irqsave(&(cwaintmp->lock),flags);
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	cwain_reset_span(cwaintmp->span[i]);
+    }
+
+    /* no master yet, force reelection */
+    cwaintmp->syncsrc = -1;
+    
+#if (ZT_CHUNKSIZE == 32)
+    /* set up the timer 250 Hz, zaptel timing */
+    cwain_outb(cwaintmp->span[0],cwain_R_TI_WD, 0x4);
+#endif
+#if (ZT_CHUNKSIZE == 8)
+    /* set up the timer 1 khz, zaptel timing */
+    cwain_outb(cwaintmp->span[0],cwain_R_TI_WD, 0x2);
+#endif
+
+    if (cwaintmp->spans == 2) {
+//	cwain_outb(cwaintmp->span[1],cwain_R_IRQMSK_MISC, 0x1); 
+	cwain_outb(cwaintmp->span[1],cwain_R_IRQMSK_MISC, 0x0); 
+    }
+    /* enable timer interrupts */
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQMSK_MISC, 0x13); 
+
+    /* Finally enable IRQ output */
+//    cwain_outb(cwaintmp->span[0],cwain_R_IRQ_CTRL, 0x8 | 0x1); 
+
+    spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+    return 0;
+}
+
+int cwain_find_spans(unsigned int pcidid) {
+    struct pci_dev *tmp;
+    struct zt_cwain *cwaintmp = NULL;
+    int i=0;
+    unsigned char dips=0;
+    int cid=0;
+    int modes=0;
+    tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_cwain);
+    while (tmp != NULL) {
+	multi_cwain = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_cwain = NULL;
+	    return -1;
+	}
+
+	cwaintmp = kmalloc(sizeof(struct zt_cwain),GFP_KERNEL);
+	if (!cwaintmp) {
+	    printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -ENOMEM;
+	}
+	memset(cwaintmp, 0x0, sizeof(struct zt_cwain));
+	
+	spin_lock_init(&cwaintmp->lock);
+	cwaintmp->pcidev = tmp;
+	cwaintmp->pcibus = tmp->bus->number;
+	cwaintmp->pcidevfn = tmp->devfn; 
+
+
+	cwaintmp->pci_io_phys = (char *) tmp->resource[1].start;
+	if (!cwaintmp->pci_io_phys) {
+	    printk(KERN_WARNING "cwain: no iomem!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "cwain: PCI device has no irq!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+	cwaintmp->ioport = tmp->resource[0].start;
+	if (!cwaintmp->ioport) {
+	    printk(KERN_WARNING "cwain: no ioport!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+	if (!request_region(cwaintmp->ioport, 8, "cwain")) {
+	    printk(KERN_WARNING "cwain: couldnt request io range!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+	if (!request_mem_region((unsigned long) cwaintmp->pci_io_phys, 256, "cwain")) {
+	    printk(KERN_WARNING "cwain: couldnt request io mem range!\n");
+	    release_region(cwaintmp->ioport, 8);
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+        cwaintmp->irq = tmp->irq;
+
+	cwaintmp->pci_io = ioremap((ulong) cwaintmp->pci_io_phys, 256);
+			       
+	/* enable memio */
+	pci_write_config_word(cwaintmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY | PCI_COMMAND_IO);	
+
+	/* disable interrupts */
+	cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0); 
+
+        if (((tmp->subsystem_device==0xb553)|| (tmp->subsystem_device==0xb554) || (tmp->subsystem_device==0xb555))&& (pcidid == PCI_DEVICE_ID_CCD_E)) {
+	    dips = (cwain_inb(cwaintmp,cwain_R_GPI_IN0) >> 5);
+	    cid = 7;
+	    for (i=0;i<3;i++) {
+	        if ((dips & (1 << i)) != 0) {
+	    	cid -= (1 << (2-i));
+	        }
+	    }
+//		printk(KERN_INFO "DIPS = %#x CID= %#x\n",dips,cid);
+        } else {
+	    cid = 0xff;
+        }
+
+	if (ports == -1) {
+    	    if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_E)) {
+		modes = (cwain_inb(cwaintmp,cwain_R_GPI_IN0) >> 4) & 0x01;
+	    } else {
+		modes = 0; // assume TE mode
+	    }
+	} else {
+	    modes = ports >> cwain_span_count;
+	}
+
+
+	cwaintmp->cardID = cid;
+	cwaintmp->type = tmp->subsystem_device;
+
+	if ((modes & 1) != 0) {
+	    cwaintmp->nt_mode = 1;
+	} else {
+	    cwaintmp->nt_mode = 0;
+	}
+
+	cwain_register_span(cwaintmp);
+
+	tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_cwain);
+    }
+    return 0;
+}
+
+
+int cwain_sort_cards(void) {
+    int changed=0,tmpcardno;
+    struct zt_cwain_card *tmpcard,*tmpcard2;
+    spin_lock(&cwain_card_registerlock);
+    do {
+	changed = 0;
+	tmpcard = cwain_card_list;
+	while (tmpcard != NULL) {
+	    if (tmpcard->prev) {
+		if (tmpcard->prev->cardID > tmpcard->cardID) {
+		    tmpcardno = tmpcard->prev->cardno;
+		    tmpcard->prev->cardno = tmpcard->cardno; 
+		    tmpcard->cardno = tmpcardno;
+		
+		    tmpcard2 = tmpcard->prev;
+		    if (tmpcard2->prev) {
+			tmpcard2->prev->next = tmpcard;
+		    } else {
+			cwain_card_list = tmpcard;
+		    }
+		    if (tmpcard->next) {
+			tmpcard->next->prev = tmpcard2;
+		    } 
+		    tmpcard2->next = tmpcard->next;
+		    tmpcard->prev = tmpcard2->prev;
+		    tmpcard->next = tmpcard2;
+		    tmpcard2->prev = tmpcard;
+		    changed = 1;
+		    tmpcard = tmpcard2;
+		}
+	    }
+	    tmpcard = tmpcard->next;
+	}
+    } while (changed == 1);
+    spin_unlock(&cwain_card_registerlock);
+    return 0;
+}
+
+int cwain_zap_cards(void) {
+    struct zt_cwain_card *tmpcard = cwain_card_list;
+    int i=0;
+    int res=0;
+    while (tmpcard != NULL) {
+	for (i=0; i<tmpcard->spans; i++) {
+	    ztcwain_initialize(tmpcard->span[i], tmpcard, i);
+	}
+	res = cwain_reset_card(tmpcard);
+	tmpcard = tmpcard->next;
+    }
+    return res;
+}
+
+
+int init_module(void) {
+    if (hdlcnet) {
+	hw_hdlc = 1; /* otherwise it makes no sense at all... */
+	dacs = 0;
+    }
+    multi_cwain = NULL;
+    cwain_find_spans(PCI_DEVICE_ID_CCD_E);
+    cwain_sort_cards();
+    cwain_zap_cards();
+    if (cwain_card_count == 0) {
+	printk(KERN_INFO "cwain: no cwain cards found.\n");
+    } else {
+	printk(KERN_INFO "cwain: %d cwain card(s) in this box, %d E1 ports total, hw_hdcl = %d, dacs =%d, require_ext_clock = %d, ZT_CHUNKSIZE = %d, timer = %d.\n", cwain_card_count, cwain_span_count, hw_hdlc, dacs, require_ext_clock, ZT_CHUNKSIZE, cwain_TIMER_INT);
+    }
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct zt_cwain_card *tmpcard,*tmplist;
+    struct zt_cwain *tmpspan,*spanlist;
+    int i=0;
+    int j=0;
+    
+    tmplist = cwain_card_list;
+    tmpcard = NULL;
+    while (tmplist) {
+	tmpcard = tmplist;
+	tmplist = tmplist->next;
+
+	tmpcard->dead = 1;
+	cwain_shutdown_card(tmpcard);
+	kfree(tmpcard);
+	i++;
+    }
+
+    spanlist = cwain_span_list;
+    tmpspan = NULL;
+    while (spanlist) {
+	tmpspan = spanlist;
+	spanlist = spanlist->next;
+	kfree(tmpspan);
+	j++;
+    }
+    printk(KERN_INFO "cwain: shutdown %d spans, %d cwain cards.\n", j, i);
+}
+#endif
+
+#ifdef LINUX26
+module_param(ports, int, 0600);
+module_param(debug, int, 0600);
+module_param(hw_hdlc, int, 0600);
+module_param(hdlcnet, int, 0600);
+module_param(pwm0, int, 0600);
+module_param(pwm1, int, 0600);
+module_param(dacs, int, 0600);
+module_param(require_ext_clock, int, 0600);
+#else
+MODULE_PARM(ports,"i");
+MODULE_PARM(debug,"i");
+MODULE_PARM(hw_hdlc,"i");
+MODULE_PARM(hdlcnet,"i");
+MODULE_PARM(pwm0,"i");
+MODULE_PARM(pwm1,"i");
+MODULE_PARM(dacs,"i");
+MODULE_PARM(require_ext_clock,"i");
+#endif
+
+MODULE_DESCRIPTION("cwain zaptel driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urN zaptel-1.4.11.org/kernel/cwain/cwain.h zaptel-1.4.11/kernel/cwain/cwain.h
--- zaptel-1.4.11.org/kernel/cwain/cwain.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/cwain.h	2008-07-16 22:06:17.184808735 +0200
@@ -0,0 +1,252 @@
+#define cwain_FIFO_SIZE	128
+#define cwain_DFIFO_SIZE	4096
+#define cwain_DFIFO_FRAMES	0x10
+#define cwain_FRAME_SIZE 16	/* has to be %4==0 */
+#define cwain_FIFO_HW cwain_FRAME_SIZE * 2 + ZT_CHUNKSIZE
+#define cwain_TIMER_INT	(8000 / ZT_CHUNKSIZE)
+
+
+typedef struct zt_cwain {
+    /* pci resources */
+    unsigned int irq;
+    unsigned int iomem;
+    unsigned long ioport;
+    unsigned char *pci_io;
+    void *pci_io_phys;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    unsigned int type;
+
+    /* lock to protect the structure */
+    spinlock_t lock;
+    int cardID;
+    unsigned char cardno;
+    
+    /* ticks and clicks, fish and chips */
+    unsigned int ticks;
+    unsigned int clicks;
+    unsigned char nt_mode;
+    unsigned char sync_sta;
+    unsigned char sync;
+    int syncmode;
+    
+    /* blinky blink */
+    unsigned char leds[4];
+    unsigned int wdp;
+
+    /* B chan buffers */
+    unsigned char rxbuf[31][ZT_CHUNKSIZE];
+    unsigned char txbuf[31][ZT_CHUNKSIZE];
+
+    signed short ts_rx[31];
+    signed short ts_tx[31];
+
+    /* buffers */
+    unsigned char frxbuf[31][cwain_FRAME_SIZE];
+    unsigned char ftxbuf[31][cwain_FRAME_SIZE];
+    
+    /* number of RXed dchan frames */
+    unsigned char drx;
+    /* D chan buffer */
+    unsigned char drxbuf[cwain_DFIFO_SIZE];
+    unsigned char dtxbuf[cwain_DFIFO_SIZE];
+
+
+    /* zaptel resources */
+    struct zt_span span;
+    struct zt_chan chans[31];
+
+    /* more zaptel stuff */
+    unsigned int usecount;
+    int spantype;
+    int spanflags;
+
+    /* linked list */
+    struct zt_cwain *next;
+    struct zt_cwain *prev;
+
+} zt_cwain;
+
+typedef struct zt_cwain_card {
+    /* lock to protect the structure */
+    spinlock_t lock;
+
+    unsigned int spans;
+    unsigned int dead;
+    int cardID;
+    unsigned char cardno;
+    unsigned int ticks;
+
+    struct zt_cwain *span[2];
+    int syncsrc;
+    int syncs[2];
+    int master[2];
+    
+    unsigned int irq;   
+    unsigned int pcibus;
+
+    /* linked list */
+    struct zt_cwain_card *next;
+    struct zt_cwain_card *prev;
+} zt_cwain_card;
+
+#define cwain_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define cwain_inb(a,b) (readb((a)->pci_io+(b)))
+
+#define cwain_outw(a,b,c) (writew((c),(a)->pci_io+(b)))
+#define cwain_inw(a,b) (readw((a)->pci_io+(b)))
+
+#define cwain_outdw(a,b,c) (writel((c),(a)->pci_io+(b)))
+#define cwain_indw(a,b) (readl((a)->pci_io+(b)))
+
+
+/* Write only registers */
+#define cwain_A_CH_MSK		0xF4
+#define cwain_A_CHANNEL 	0xFC
+#define cwain_A_CON_HDLC	0xFA
+#define cwain_A_CONF		0xD1
+#define cwain_A_FIFO_SEQ	0xFD
+#define cwain_R_INC_RES_FIFO	0x0E
+#define cwain_A_IRQ_MSK		0xFF
+#define cwain_A_SL_CFG		0xD0
+#define cwain_A_SUBCH_CFG	0xFB
+#define cwain_R_BERT_WD_MD	0x1B
+#define cwain_R_BRG_PCM_CFG	0x02
+#define cwain_R_CIRM		0x00
+#define cwain_R_CONF_EN		0x18
+#define cwain_R_CTRL		0x01
+#define cwain_R_DTMF		0x1C
+#define cwain_R_DTMF_N		0x1D
+#define cwain_R_E1_WR_STA	0x20
+#define cwain_R_FIFO_MD		0x0D
+#define cwain_R_FIFO		0x0F
+#define cwain_R_FIRST_FIFO	0x0B
+#define cwain_R_FSM_IDX		0x0F
+#define cwain_R_GPIO_EN0	0x42
+#define cwain_R_GPIO_EN1	0x43
+#define cwain_R_GPIO_OUT0	0x40
+#define cwain_R_GPIO_OUT1	0x41
+#define cwain_R_GPIO_SEL	0x44
+#define cwain_R_IRQ_CTRL	0x13
+#define cwain_R_IRQMSK_MISC	0x11
+#define cwain_R_JATT_CFG	0x2F
+#define cwain_R_LOS0		0x22
+#define cwain_R_LOS1		0x23
+#define cwain_R_PCM_MD0		0x14
+#define cwain_R_PCM_MD1		0x15
+#define cwain_R_PCM_MD2		0x15
+#define cwain_R_PWM_MD		0x46
+#define cwain_R_PWM0		0x38
+#define cwain_R_PWM1		0x39
+#define cwain_R_RAM_ADDR0	0x08
+#define cwain_R_RAM_ADDR1	0x09
+#define cwain_R_RAM_ADDR2	0x0A
+#define cwain_R_RAM_MISC	0x0C
+#define cwain_R_RX_OFFS		0x30
+#define cwain_R_RX_SL0_CFG0	0x25
+#define cwain_R_RX_SL0_CFG1	0x26
+#define cwain_R_RX0		0x24
+#define cwain_R_SH0H		0x15
+#define cwain_R_SH0L		0x15
+#define cwain_R_SH1H		0x15
+#define cwain_R_SH1L		0x15
+#define cwain_R_SL_SEL0		0x15
+#define cwain_R_SL_SEL1		0x15
+#define cwain_R_SL_SEL2		0x15
+#define cwain_R_SL_SEL3		0x15
+#define cwain_R_SL_SEL4		0x15
+#define cwain_R_SL_SEL5		0x15
+#define cwain_R_SL_SEL6		0x15
+#define cwain_R_SL_SEL7		0x15
+#define cwain_R_SLOT		0x10
+#define cwain_R_SYNC_CTRL	0x35
+#define cwain_R_SYNC_OUT	0x31
+#define cwain_R_TI_WD		0x1A
+#define cwain_R_TX_OFFS		0x34
+#define cwain_R_TX_SL0_CFG0	0x2C
+#define cwain_R_TX_SL0_CFG1	0x2E
+#define cwain_R_TX_SL0		0x2D
+#define cwain_R_TX0		0x28
+#define cwain_R_TX1		0x29
+
+#define cwain_R_TX_FR0		0x2C
+#define cwain_R_TX_FR1		0x2D
+#define cwain_R_TX_FR2		0x2E
+
+#define cwain_R_RX_FR0		0x25
+#define cwain_R_RX_FR1		0x26
+
+/* Read only registers */
+#define cwain_A_F1		0x0C
+#define cwain_A_F12		0x0C
+#define cwain_A_F2		0x0D
+#define cwain_A_Z1		0x04
+#define cwain_A_Z12		0x04
+#define cwain_A_Z1H		0x05
+#define cwain_A_Z1L		0x04
+#define cwain_A_Z2		0x06
+#define cwain_A_Z2H		0x07
+#define cwain_A_Z2L		0x06
+#define cwain_R_BERT_ECH	0x1B
+#define cwain_R_BERT_ECL	0x1A
+#define cwain_R_BERT_STA	0x17
+#define cwain_R_CHIP_ID		0x16
+#define cwain_R_CHIP_RV		0x1F
+#define cwain_R_CONF_OFLOW	0x14
+#define cwain_R_CRC_ECH		0x35
+#define cwain_R_CRC_ECL		0x34
+#define cwain_R_E_ECH		0x37
+#define cwain_R_E_ECL		0x36
+#define cwain_R_E1_RD_STA	0x20
+#define cwain_R_F0_CNTH		0x19
+#define cwain_R_F0_CNTL		0x18
+#define cwain_R_FAS_ECH		0x31
+#define cwain_R_FAS_ECL		0x30
+#define cwain_R_GPI_IN0		0x44
+#define cwain_R_GPI_IN1		0x45
+#define cwain_R_GPI_IN2		0x46
+#define cwain_R_GPI_IN3		0x47
+#define cwain_R_GPIO_IN0	0x40
+#define cwain_R_GPIO_IN1	0x41
+#define cwain_R_INT_DATA	0x88
+#define cwain_R_IRQ_FIFO_BL0	0xC8
+#define cwain_R_IRQ_FIFO_BL1	0xC9
+#define cwain_R_IRQ_FIFO_BL2	0xCA
+#define cwain_R_IRQ_FIFO_BL3	0xCB
+#define cwain_R_IRQ_FIFO_BL4	0xCC
+#define cwain_R_IRQ_FIFO_BL5	0xCD
+#define cwain_R_IRQ_FIFO_BL6	0xCE
+#define cwain_R_IRQ_FIFO_BL7	0xCF
+#define cwain_R_IRQ_MISC	0x11
+#define cwain_R_IRQ_OVIEW	0x10
+#define cwain_R_JATT_STA	0x2B
+#define cwain_R_RAM_USE		0x15
+#define cwain_R_RX_SL0_0	0x25
+#define cwain_R_RX_SL0_1	0x26
+#define cwain_R_RX_SL0_2	0x27
+#define cwain_R_SA6_VAL13_ECH	0x39
+#define cwain_R_SA6_VAL13_ECL	0x38
+#define cwain_R_SA6_VAL23_ECH	0x3B
+#define cwain_R_SA6_VAL23_ECL	0x3A
+#define cwain_R_SLIP		0x2C
+#define cwain_R_STATUS		0x1C
+#define cwain_R_SYNC_STA	0x24
+#define cwain_R_VIO_ECH		0x33
+#define cwain_R_VIO_ECL		0x32
+
+
+/* Read/Write registers */
+#define cwain_A_FIFO_DATA0_NOINC	0x84
+#define cwain_A_FIFO_DATA0	0x80
+#define cwain_A_FIFO_DATA1_NOINC	0x84
+#define cwain_A_FIFO_DATA1	0x80
+#define cwain_A_FIFO_DATA2_NOINC	0x84
+#define cwain_A_FIFO_DATA2	0x80
+#define cwain_R_RAM_DATA	0xC0
+
+#define PCI_DEVICE_ID_CCD_E	0x30b1
+
+#define CLKDEL_TE	0xe	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0xc	/* CLKDEL in NT mode */
+
diff -urN zaptel-1.4.11.org/kernel/cwain/Kbuild zaptel-1.4.11/kernel/cwain/Kbuild
--- zaptel-1.4.11.org/kernel/cwain/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/Kbuild	2008-07-16 22:19:27.544401160 +0200
@@ -0,0 +1,9 @@
+obj-m += cwain.o
+
+FIRM_DIR	:= ../../firmware
+
+EXTRA_CFLAGS := -I$(src)/.. -Wno-undef
+
+ifeq ($(HOTPLUG_FIRMWARE),yes)
+  EXTRA_CFLAGS+=-DHOTPLUG_FIRMWARE
+endif
diff -urN zaptel-1.4.11.org/kernel/cwain/Makefile zaptel-1.4.11/kernel/cwain/Makefile
--- zaptel-1.4.11.org/kernel/cwain/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/Makefile	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,88 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel")
+
+CFLAGS+=-I. $(ZAP) -DRELAXED_LOCKING -O2 -g -Wall #-DBLINKYBLINK
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -DRELAXED_LOCKING -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP) 
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+OBJS=cwain.o
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+MODULES=cwain
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+linux26:
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+obj-m := $(OBJS)
+
+cwain.o: cwain.c cwain.h 
+	$(CC) -c cwain.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	
+testlinux24: all
+	modprobe zaptel
+	insmod ./cwain.o
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod cwain zaptel
+
+testlinux26: all
+	modprobe zaptel
+	insmod ./cwain.ko
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 5
+	cat /proc/interrupts
+	rmmod cwain zaptel
+
+reload:	unload load
+load:	load$(BUILDVER)
+
+test:	test$(BUILDVER)
+
+
+loadlinux24: linux24
+	modprobe zaptel
+	insmod ./cwain.o
+	ztcfg -v
+
+loadlinux26: linux26
+	sync
+	modprobe zaptel
+	insmod ./cwain.ko debug=1
+	ztcfg -v
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 cwain.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/cwain.ko
+
+installlinux24:
+	install -D -m 644 cwain.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/cwain.o
+
+unload: 
+	rmmod cwain zaptel
diff -urN zaptel-1.4.11.org/kernel/cwain/TODO zaptel-1.4.11/kernel/cwain/TODO
--- zaptel-1.4.11.org/kernel/cwain/TODO	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/TODO	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1 @@
+
diff -urN zaptel-1.4.11.org/kernel/cwain/zapata.conf zaptel-1.4.11/kernel/cwain/zapata.conf
--- zaptel-1.4.11.org/kernel/cwain/zapata.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zapata.conf	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,32 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+signalling = pri_cpe
+
+pridialplan = local
+prilocaldialplan = dynamic
+nationalprefix = 0
+internationalprefix = 00
+
+priindication = passthrough
+
+echocancel = yes
+
+context=demo
+
+group = 1
+channel => 1-15,17-31
+
diff -urN zaptel-1.4.11.org/kernel/cwain/zapata.conf.doubleE1 zaptel-1.4.11/kernel/cwain/zapata.conf.doubleE1
--- zaptel-1.4.11.org/kernel/cwain/zapata.conf.doubleE1	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zapata.conf.doubleE1	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,35 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+signalling = pri_cpe
+
+pridialplan = local
+prilocaldialplan = dynamic
+nationalprefix = 0
+internationalprefix = 00
+
+priindication = passthrough
+
+echocancel = yes
+
+context=demo
+
+group = 1
+channel => 1-15,17-31
+
+group = 2
+channel => 32-46,48-62
+
diff -urN zaptel-1.4.11.org/kernel/cwain/zaptel.conf zaptel-1.4.11/kernel/cwain/zaptel.conf
--- zaptel-1.4.11.org/kernel/cwain/zaptel.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zaptel.conf	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,11 @@
+loadzone=nl
+defaultzone=nl
+span=1,2,3,ccs,hdb3,crc4
+
+alaw=1-31
+
+bchan=1-15
+dchan=16
+bchan=17-31
+
+
diff -urN zaptel-1.4.11.org/kernel/cwain/zaptel.conf.doubleE1 zaptel-1.4.11/kernel/cwain/zaptel.conf.doubleE1
--- zaptel-1.4.11.org/kernel/cwain/zaptel.conf.doubleE1	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zaptel.conf.doubleE1	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,14 @@
+loadzone=nl
+defaultzone=nl
+span=1,1,3,ccs,hdb3,crc4
+span=2,2,3,ccs,hdb3,crc4
+
+alaw=1-62
+
+bchan=1-15
+dchan=16
+bchan=17-31
+
+bchan=32-46
+dchan=47
+bchan=48-62
diff -urN zaptel-1.4.11.org/kernel/cwain/zaptel.conf.hdlcnet zaptel-1.4.11/kernel/cwain/zaptel.conf.hdlcnet
--- zaptel-1.4.11.org/kernel/cwain/zaptel.conf.hdlcnet	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zaptel.conf.hdlcnet	2008-07-16 22:06:17.187813340 +0200
@@ -0,0 +1,8 @@
+loadzone=nl
+defaultzone=nl
+span=1,1,3,ccs,hdb3,crc4
+
+; hdlc0
+hdlcnet=1
+
+
diff -urN zaptel-1.4.11.org/kernel/cwain/zaptel.conf.hdlcnet.doubleE1 zaptel-1.4.11/kernel/cwain/zaptel.conf.hdlcnet.doubleE1
--- zaptel-1.4.11.org/kernel/cwain/zaptel.conf.hdlcnet.doubleE1	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/cwain/zaptel.conf.hdlcnet.doubleE1	2008-07-16 22:06:17.191146481 +0200
@@ -0,0 +1,10 @@
+loadzone=nl
+defaultzone=nl
+span=1,1,3,ccs,hdb3,crc4
+span=2,2,3,ccs,hdb3,crc4
+
+; hdlc0
+hdlcnet = 1
+
+; hdlc 1
+hdlcnet = 2
\ Brak znaku nowej linii na końcu pliku
diff -urN zaptel-1.4.11.org/kernel/ds1x1f.c zaptel-1.4.11/kernel/ds1x1f.c
--- zaptel-1.4.11.org/kernel/ds1x1f.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ds1x1f.c	2008-07-16 22:06:17.191146481 +0200
@@ -0,0 +1,2089 @@
+//=======================================================================
+//            T1/E1 PCI card with failover  DS1x1F card Driver
+//
+//		     Ver: 2.14   Date: 17.Jan.2007
+//
+//                      based of work by:
+//               Mark Spencer <markster@digium.com>
+//            Matthew Fredrickson <creslin@digium.com>
+//             William Meadows <wmeadows@digium.com>
+//
+//                  Copyright (c)2006,2007 TCDG Corp.
+//                      All rights reserved.
+//			
+//			http://www.tc-dg.net
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+//
+//=======================================================================
+
+ 
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+
+#ifdef STANDALONE_ZAPATA
+#include "zaptel.h"
+#else
+#include <linux/zaptel.h>
+#endif
+
+
+#define WC_MAX_CARDS		32
+#define NUM_REGS	 	0xa9
+#define NUM_PCI 		12
+
+#define OFS_FALC		0x0000		// pci address space offset for FALC registers  256 * 32 bit words (only 8 LSB used) 
+#define OFS_TDM_WR		0x0800		// pci address space offset for TDM media shift register buffers  8 * 32 bit words   
+#define OFS_TDM_RD		0x0900		// pci address space offset for TDM media shift register buffers  8 * 32 bit words   
+#define OFS_CTRL		0x1000		// pci address space offset for card control register             1 * 32 bit         
+#define OFS_CLK			0x1004		// pci address space offset for card clock / h.100 register       1 * 32 bit         
+
+
+#define FLAG_STARTED 		0x01
+#define FLAG_NMF 		0x02
+#define FLAG_SENDINGYELLOW 	0x04
+
+#define MODE_SW			-1		// mode controlled by DIP switch
+#define	MODE_T1			0x01		// T1 mode			bit.0 = T1
+#define	MODE_E1			0x02		// E1 mode			bit.1 = E1
+#define	MODE_UE1		0x82		// unchannelized E1		bit.7 = unchannelized
+#define	MODE_J1			0x41		// J1 mode			bit.6 = j1mode
+
+
+#define DS1_SET_REL		 7		// new MAINT commands for controlling the bypass relay and monitoring, hot-standby
+#define DS1_CLR_REL		 8
+#define DS1_SET_RXMON		 9
+#define DS1_CLR_RXMON		10
+#define DS1_SET_TXEN		11
+#define DS1_CLR_TXEN		12
+
+
+
+//======================================= Control register  bit definitions ================================
+
+#define CTRL_LOFF               0x0000          // All LED off
+#define CTRL_LGRN		0x0001		// Green LED control bit
+#define CTRL_LRED		0x0002		// Red LED control bit
+#define CTRL_REL		0x0004		// bypass relay  L = bypass  H = normal operation
+#define CTRL_TEST		0x0008		// relay presence test bit  L = normal operation  H= presence test
+#define CTRL_FRST		0x0010		// Falc reset bit  L = normal operation H = Falc Reset
+#define CTRL_INTA		0x0100		// Interrupt acknowledge bit  writing a '1' resets IRQ and IRM
+#define CTRL_IRQ		0x0100		// Interrupt request bit
+#define CTRL_IRM		0x0400		// Interrupt missed bit  = previous interrupt has not yet been serviced when new one was triggered 
+#define CTRL_RELI		0x0800		// relay presence bit  H = no relay  L = relay present  (valid only when CTRL_TEST = H)
+#define CTRL_SW1		0x1000		// DIP switch #1
+#define CTRL_SW2		0x2000		// DIP switch #2
+#define CTRL_SW3		0x4000		// DIP switch #3
+#define CTRL_SW4		0x8000		// DIP switch #4
+
+//==================================== FALC-56 PEF-2256 register definitions ===============================
+
+#define FR_XFIFO	0x00
+#define FR_RFIFO	0x00
+#define FR_CMDR		0x02
+#define FR_MODE		0x03
+#define FR_RAH1		0x04
+#define FR_RAH2		0x05
+#define FR_RAL1		0x06
+#define FR_RAL2		0x07
+#define FR_IPC 		0x08
+#define FR_CCR1		0x09
+#define FR_CCR2		0x0a
+#define FR_RTR1		0x0c
+#define FR_RTR2		0x0d
+#define FR_RTR3		0x0e
+#define FR_RTR4		0x0f
+#define FR_TTR1		0x10
+#define FR_TTR2		0x11
+#define FR_TTR3		0x12
+#define FR_TTR4		0x13
+#define FR_IMR0		0x14
+#define FR_IMR1		0x15
+#define FR_IMR2		0x16
+#define FR_IMR3		0x17
+#define FR_IMR4		0x18
+#define FR_IMR5		0x19
+#define FR_IERR		0x1b
+#define FR_FMR0		0x1c
+#define FR_FMR1		0x1d
+#define FR_FMR2		0x1e
+#define FR_LOOP		0x1f
+#define FR_FMR4		0x20
+#define FR_FMR5		0x21
+#define FR_XSW 		0x20
+#define FR_XSP 		0x21
+#define FR_XC0 		0x22
+#define FR_XC1 		0x23
+#define FR_RC0 		0x24
+#define FR_RC1 		0x25
+#define FR_XPM0		0x26
+#define FR_XPM1		0x27
+#define FR_XPM2		0x28
+#define FR_TSWM		0x29
+#define FR_IDLE		0x2b
+#define FR_XSA4		0x2c
+#define FR_XSA5		0x2d
+#define FR_XSA6		0x2e
+#define FR_XSA7		0x2f
+#define FR_XSA8		0x30
+#define FR_FMR3		0x31
+#define FR_CCB1		0x2f
+#define FR_CCB2		0x30
+#define FR_CCB3		0x31
+#define FR_ICB1		0x32
+#define FR_ICB2		0x33
+#define FR_ICB3		0x34
+#define FR_ICB4		0x35
+#define FR_LIM0		0x36
+#define FR_LIM1		0x37
+#define FR_PCD 		0x38
+#define FR_PCR 		0x39
+#define FR_LIM2		0x3a
+#define FR_LCR1		0x3b
+#define FR_LCR2		0x3c
+#define FR_LCR3		0x3d
+#define FR_SIC1		0x3e
+#define FR_SIC2		0x3f
+#define FR_SIC3		0x40
+#define FR_CMR1		0x44
+#define FR_CMR2		0x45
+#define FR_GCR 		0x46
+#define FR_ESM 		0x47
+#define FR_RBD  	0x49
+#define FR_VSTR 	0x4a
+#define FR_RES  	0x4b
+#define FR_FRS0 	0x4c
+#define FR_FRS1 	0x4d
+#define FR_RSW  	0x4e
+#define FR_RSP  	0x4f
+#define FR_FECL		0x50
+#define FR_FECH		0x51
+#define FR_CVCL		0x52
+#define FR_CVCH		0x53
+#define FR_CEC1L	0x54
+#define FR_CEC1H	0x55
+#define FR_EBCL 	0x56
+#define FR_EBCH		0x57
+#define FR_CEC2L	0x58
+#define FR_CEC2H	0x59
+#define FR_CEC3L	0x5a
+#define FR_CEC3H	0x5b
+#define FR_RSA4 	0x5c
+#define FR_RSA5 	0x5d
+#define FR_RSA6 	0x5e
+#define FR_RSA7 	0x5f
+#define FR_RSA8 	0x60
+#define FR_DEC 		0x60
+#define FR_RSA6S	0x61
+#define FR_RSP1		0x62
+#define FR_RSP2		0x63
+#define FR_SIS 		0x64
+#define FR_RSIS		0x65
+#define FR_RBCL		0x66
+#define FR_RBCH		0x67
+#define FR_ISR0		0x68
+#define FR_ISR1		0x69
+#define FR_ISR2		0x6a
+#define FR_ISR3		0x6b
+#define FR_ISR4		0x6c
+#define FR_ISR5		0x6d
+#define FR_GIS 		0x6e
+#define FR_XS1 		0x70
+#define FR_XS2 		0x71
+#define FR_XS3 		0x72
+#define FR_XS4 		0x73
+#define FR_XS5 		0x74
+#define FR_XS6 		0x75
+#define FR_XS7 		0x76
+#define FR_XS8 		0x77
+#define FR_XS9 		0x78
+#define FR_XS10		0x79
+#define FR_XS11		0x7a
+#define FR_XS12		0x7b
+#define FR_XS13		0x7c
+#define FR_XS14		0x7d
+#define FR_XS15		0x7e
+#define FR_XS16		0x7f
+#define FR_RS1 		0x70
+#define FR_RS2 		0x71
+#define FR_RS3 		0x72
+#define FR_RS4 		0x73
+#define FR_RS5 		0x74
+#define FR_RS6 		0x75
+#define FR_RS7 		0x76
+#define FR_RS8 		0x77
+#define FR_RS9 		0x78
+#define FR_RS10		0x79
+#define FR_RS11		0x7a
+#define FR_RS12		0x7b
+#define FR_RS13		0x7c
+#define FR_RS14		0x7d
+#define FR_RS15		0x7e
+#define FR_RS16		0x7f
+#define FR_PC1 		0x80
+#define FR_PC2 		0x81
+#define FR_PC3 		0x82
+#define FR_PC4 		0x83
+#define FR_PC5 		0x84
+#define FR_GPC1		0x85
+#define FR_PC6 		0x86
+#define FR_CMDR2	0x87
+#define FR_CMDR3	0x88
+#define FR_CMDR4	0x89
+#define FR_CCR3		0x8b
+#define FR_CCR4		0x8c
+#define FR_CCR5		0x8d
+#define FR_MODE2	0x8e
+#define FR_MODE3	0x8f
+#define FR_RBC2		0x90
+#define FR_RBC3		0x91
+#define FR_GCM1		0x92
+#define FR_GCM2		0x93
+#define FR_GCM3		0x94
+#define FR_GCM4		0x95
+#define FR_GCM5		0x96
+#define FR_GCM6  	0x97
+#define FR_GCM7		0x98
+#define FR_GCM8  	0x99
+#define FR_SIS2		0x98
+#define FR_RSIS2	0x99
+#define FR_SIS3		0x9a
+#define FR_RSIS3	0x9b
+#define FR_XFIFO2	0x9c
+#define FR_RFIFO2	0x9c
+#define FR_XFIFO3	0x9e
+#define FR_RFIFO3	0x9e
+#define FR_TSEO 	0xa0
+#define FR_TSBS1	0xa1
+#define FR_TSBS2	0xa2
+#define FR_TSBS3	0xa3
+#define FR_TSS2 	0xa4
+#define FR_TSS3 	0xa5
+#define FR_TPC0 	0xa8
+#define FR_WID 		0xec
+
+//========================================================================================================
+
+struct t4_regs {
+        unsigned int  pci[NUM_PCI];
+        unsigned char regs[NUM_REGS];
+};
+
+
+#define WCT4_GET_REGS   _IOW (ZT_CODE, 60, struct t4_regs)
+
+
+
+static int clrtab[] = {0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1};
+
+static char name[]  = {"ds1x1f"};
+
+struct t1 {
+	struct pci_dev *dev;
+	spinlock_t lock;
+	int spantype;	
+	int spanflags;						// Span flags
+	unsigned char txsigs[16];  				// Copy of tx sig registers 
+	int num;
+	int alarmcount;						// How much red alarm we've seen
+	int alarmdebounce;
+	char *variety;
+
+	unsigned int intcount;
+	int          prescaler;					// interrupt divider
+
+	int usecount;
+	int blinktimer;
+	int alarmtimer;
+	int loopupcnt;
+	int loopdowncnt;
+	unsigned char     ledtestreg;
+	
+	void *            cnaddr;				// PCI and driver related parameters
+	void *            ioaddr;
+	unsigned long     iostart;
+	unsigned long     iolen;
+	unsigned long     cnstart;
+	unsigned long     cnlen;
+	struct resource * cres;
+        struct resource * ires;
+
+	unsigned char txchunkptr;				// pointer for rd/wr audiosamples
+	unsigned char rxchunkptr;
+
+        unsigned char ec_chunk1[32][ZT_CHUNKSIZE];		// echocanceller memory buffers
+        unsigned char ec_chunk2[32][ZT_CHUNKSIZE];
+	
+	struct zt_span span;					// Span
+	struct zt_chan chans[32];				// Channels 
+};
+
+								
+								// module paramter variables
+static int debug         =  0;   				// defines debug modes 0,1,2
+static int cardmode      = -1;					// forces card into T1, E1, J1, UE1 mode , -1 = use DIP switches
+static int alarmdebounce =  0;
+static int loopback      =  0;
+static int frames	 = -1;					// sets the size of the cards framebuffer 1-8 frames (preferred are 1,2,4,8)
+static int extclk        = -1;					// controls the clock synchronization via H.100 bus connector
+static int monitor       =  0;					// monitor = 3 puts the card in a Hi-Z mode and enabling it to monitor T1/E1 traffic
+
+static struct t1 *cards[WC_MAX_CARDS];
+
+
+static inline void start_alarm(struct t1 *wc)
+{
+	wc->blinktimer = 0;
+}
+
+
+static int ds1_open(struct zt_chan *chan)
+{
+	struct t1 *wc = chan->pvt;
+	
+	wc->usecount++;
+
+	try_module_get(THIS_MODULE);
+
+	return 0;
+}
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int led_write_reg(struct t1 *wc, unsigned int val)		// write to the cards 32 bit control register
+{
+	unsigned int x;
+
+	x = (ioread32(wc->ioaddr + OFS_CTRL) & 0xfc) | (val & 0x03);			// combine LED content with all other register data
+
+	iowrite32(x, wc->ioaddr + OFS_CTRL);						// write back register content
+
+	return x;
+}
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int ctrl_set_reg(struct t1 *wc, unsigned int val)		// set bits in control register
+{
+	unsigned x;
+
+	x = (ioread32(wc->ioaddr + OFS_CTRL) & 0xff) | val;				// OR newcontent with all other register data
+
+	iowrite32(x, wc->ioaddr + OFS_CTRL);						// write back register content
+
+	return x;
+}
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int ctrl_clr_reg(struct t1 *wc, unsigned int val)		// clear bits in control register
+{
+	unsigned x;
+
+	x = (ioread32(wc->ioaddr + OFS_CTRL) & 0xff) & (val ^ 0xff);			// OR newcontent with all other register data
+
+	iowrite32(x, wc->ioaddr + OFS_CTRL);						// write back register content
+
+	return x;
+}
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int ctrl_write_reg(struct t1 *wc, unsigned int val)		// write to the cards 32 bit control register
+{
+	iowrite32(val, wc->ioaddr + OFS_CTRL);						// write back register content
+
+	return val;
+}
+
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int ctrl_read_reg(struct t1 *wc)					// read control register
+{
+	return (ioread32(wc->ioaddr + OFS_CTRL));					// return content of control register
+}
+
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int clk_write_reg(struct t1 *wc, unsigned int val)		// write to the cards 32 bit clock/ h.100 bus register
+{
+	iowrite32(val, wc->ioaddr + OFS_CLK);						// write back register content
+
+	return val;
+}
+
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int clk_read_reg(struct t1 *wc)					// read clock / h.100 bus register
+{
+	return (ioread32(wc->ioaddr + OFS_CLK));					// return content of control register
+}
+
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static inline unsigned int __t1_framer_in(struct t1 *wc, const unsigned int reg)	// read a Falc framer register
+{
+	int loc = ((reg & 0x00ff) << 2) + OFS_FALC;					// FALC registers are on doubleword boundaries
+
+	return ((ioread32(wc->ioaddr + loc)) & 0xff);					// return only the 8 lsb
+}
+
+
+
+static inline unsigned int t1_framer_in(struct t1 *wc, const unsigned int addr)		// spinlock wrapper
+{
+	unsigned long flags;
+	unsigned int  ret;
+
+	spin_lock_irqsave(&wc->lock, flags);
+
+	ret = __t1_framer_in(wc, addr);
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	return ret;
+}
+
+
+static inline void __t1_framer_out(struct t1 *wc, const unsigned int reg, const unsigned int val)	// write to Falc framer register	
+{
+	int loc = ((reg & 0x00ff) << 2) + OFS_FALC;					// FALC registers are on doubleword boundaries
+	int ret;
+
+	iowrite32(val, wc->ioaddr + loc);						// write to register
+
+	ret = (ioread32(wc->ioaddr + loc)) & 0xff;					// for debugging read back register content
+	
+	if (debug > 1)					
+	{
+		if (ret == val)								// check if write was successful
+			printk("Wrote: %02x to Adr: %02x \n", val, reg);				// and print on the console
+		else
+			printk("Wrote: %02x to Adr: %02x but read back: %02x !!!\n", val, reg, ret);	// print results on the console
+	}
+}
+
+
+static inline void t1_framer_out(struct t1 *wc, const unsigned int addr, const unsigned int value)	// spinlock wrapper
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+
+	__t1_framer_out(wc, addr, value);
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+}
+
+//-------------------------------------------------------------------------------------------------------------------------------------------
+static void ds1_release(struct t1 *wc)
+{
+	zt_unregister(&wc->span);
+
+	kfree(wc);
+
+	printk("Freed a DS1x1F card\n");
+}
+
+
+static int ds1_close(struct zt_chan *chan)
+{
+	struct t1 *wc = chan->pvt;
+	wc->usecount--;
+	
+	module_put(THIS_MODULE);
+	
+	if (!wc->usecount) 						// If we're dead, release us now 
+		ds1_release(wc);
+
+	return 0;
+}
+
+//----------------------------------------------------------------------------------------------------------------------------------------
+//                                                      HARDWARE INTERRUPT CONTROL Enable / Disable
+
+static void ds1_enable_interrupts(struct t1 *wc)				// enable 8 kHz TDM interrupts from the pci card
+{
+	iowrite32(0x00000001, wc->cnaddr + 0x1ec);				// enable internal interrupt
+
+	ctrl_set_reg(wc, CTRL_INTA);						// clear interrupt status bit
+
+	if (debug) 
+		printk("Enabled interrupts!\n");
+}
+
+static void ds1_disable_interrupts(struct t1 *wc)				// disable all interrupts from the card
+{
+	ctrl_set_reg(wc, CTRL_INTA);						// clear interrupt status bit
+
+	iowrite32(0x00000000, wc->cnaddr + 0x1ec);				// disable internal interrupt
+
+	if (debug) 
+		printk("Disabled interrupts!\n");
+}
+
+//----------------------------------------------------------------------------------------------------------------------------------------
+static void __ds1_set_clear(struct t1 *wc)					// SELECT CLEAR CHANNEL MODE - FOR T1 ONLY
+{
+	int i;
+	unsigned short val;
+	
+	val = 0;
+	for (i=0; i<8; i++) 							// go through channel 0-7
+	{
+		if (wc->span.chans[i   ].flags & ZT_FLAG_CLEAR)			// check if this channel is marked Clear channel 
+			val |= clrtab[i];	
+	}	
+	__t1_framer_out(wc, FR_CCB1, val);					// write register CCB1
+	
+	val = 0;
+	for (i=0; i<8; i++) 							// go through channel 8-15
+	{
+		if (wc->span.chans[i+ 8].flags & ZT_FLAG_CLEAR)			// check if this channel is marked Clear channel 
+			val |= clrtab[i];	
+	}	
+	__t1_framer_out(wc, FR_CCB2, val);					// write register CCB2
+	
+	val = 0;
+	for (i=0; i<8; i++) 							// go through channel 16-23
+	{
+		if (wc->span.chans[i+16].flags & ZT_FLAG_CLEAR)			// check if this channel is marked Clear channel 
+			val |= clrtab[i];	
+	}	
+	__t1_framer_out(wc, FR_CCB3, val);					// write register CCB3 
+	
+
+
+}
+
+//----------------------------------------------------------------------------------------------------------------------------------------
+static int ds1_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data)
+{
+	struct t4_regs regs;
+	int x;
+	struct t1 *wc;
+
+	wc = chan->pvt;
+	
+	switch(cmd) 
+	{
+		case WCT4_GET_REGS:
+			for (x=0; x<NUM_PCI; x++)
+				regs.pci[x] = (ioread32(wc->ioaddr + (x << 2)));
+
+			for (x=0; x<NUM_REGS; x++)
+				regs.regs[x] = t1_framer_in(wc, x);
+
+			if (copy_to_user((struct t4_regs *)data, &regs, sizeof(regs)))
+				return -EFAULT;
+			break;
+
+		case DS1_SET_REL:								// Turn on failover relay - normal operation
+			ctrl_set_reg (wc, CTRL_REL);
+			break;
+
+		case DS1_CLR_REL:								// turn off failover relay - bypass
+			ctrl_clr_reg (wc, CTRL_REL);
+			break;
+
+		case DS1_SET_RXMON:								// Enable receiver Hi-Z monitor mode
+			__t1_framer_out(wc, FR_LIM2,__t1_framer_in(wc, FR_LIM2) & 0xFD);	// LIM2: turn off AS1
+			break;
+			
+		case DS1_CLR_RXMON:								// Set receiver to normal 100 Ohm impedance
+			__t1_framer_out(wc, FR_LIM2,__t1_framer_in(wc, FR_LIM2) | 0x02);	// LIM2: turn on AS1
+			break;
+
+		case DS1_SET_TXEN:								// Enable transmitter - normal operation	
+			__t1_framer_out(wc, FR_LIM2,__t1_framer_in(wc, FR_XPM2) & 0xBF);	// XPM2: turn on line drivers
+			break;
+			
+		case DS1_CLR_TXEN:								// Disable transmitter - set to Hi-Z
+			__t1_framer_out(wc, FR_LIM2,__t1_framer_in(wc, FR_XPM2) | 0x40);	// XPM2: turn off line drivers
+			break;
+
+			
+			
+		default:
+			return -ENOTTY;
+	}
+	return 0;
+}
+
+
+static int ds1_maint(struct zt_span *span, int cmd)
+{
+	struct t1 *wc = span->pvt;
+
+	if (wc->spantype == MODE_E1) 
+	{
+		switch(cmd) 
+		{
+			case ZT_MAINT_NONE:
+				printk("XXX Turn off local and remote loops E1 XXX\n");
+				break;
+
+			case ZT_MAINT_LOCALLOOP:
+				printk("XXX Turn on local loopback E1 XXX\n");
+				break;
+
+			case ZT_MAINT_REMOTELOOP:
+				printk("XXX Turn on remote loopback E1 XXX\n");
+				break;
+
+			case ZT_MAINT_LOOPUP:
+				printk("XXX Send loopup code E1 XXX\n");
+				break;
+
+			case ZT_MAINT_LOOPDOWN:
+				printk("XXX Send loopdown code E1 XXX\n");
+				break;
+
+			case ZT_MAINT_LOOPSTOP:
+				printk("XXX Stop sending loop codes E1 XXX\n");
+				break;
+
+			case DS1_SET_REL:
+				ctrl_set_reg (wc, CTRL_REL);
+				printk("XXX Turn off E1 bypass XXX\n");
+				break;
+
+			case DS1_CLR_REL:
+				ctrl_clr_reg (wc, CTRL_REL);
+				printk("XXX Turn on E1 bypass XXX\n");
+				break;
+
+			default:
+				printk("DS1x1F: Unknown E1 maintainance command: %d\n", cmd);
+				break;
+		}
+	} 
+	else 
+	{
+		switch(cmd) 
+		{
+		    case ZT_MAINT_NONE:
+				printk("XXX Turn off local and remote loops T1 XXX\n");
+				break;
+
+		    case ZT_MAINT_LOCALLOOP:
+				printk("XXX Turn on local loop and no remote loop XXX\n");
+				break;
+
+		    case ZT_MAINT_REMOTELOOP:
+				printk("XXX Turn on remote loopup XXX\n");
+				break;
+
+		    case ZT_MAINT_LOOPUP:
+				t1_framer_out(wc, FR_FMR5, 0x50);	/* FMR5: Nothing but RBS mode */
+				break;
+
+		    case ZT_MAINT_LOOPDOWN:
+				t1_framer_out(wc, FR_FMR5, 0x60);	/* FMR5: Nothing but RBS mode */
+				break;
+
+		    case ZT_MAINT_LOOPSTOP:
+				t1_framer_out(wc, FR_FMR5, 0x40);	/* FMR5: Nothing but RBS mode */
+				break;
+
+		    case DS1_SET_REL:
+				ctrl_set_reg (wc, CTRL_REL);
+				printk("XXX Turn off T1 bypass XXX\n");
+				break;
+
+		    case DS1_CLR_REL:
+				ctrl_clr_reg (wc, CTRL_REL);
+				printk("XXX Turn on T1 bypass XXX\n");
+				break;
+
+		    default:
+				printk("DS1x1F: Unknown T1 maintainance command: %d\n", cmd);
+				break;
+		   }
+	}
+	return 0;
+}
+
+
+static int ds1_rbsbits(struct zt_chan *chan, int bits)
+{
+	u_char m,c;
+	int n,b;
+	struct t1 *wc = chan->pvt;
+	unsigned long flags;
+	
+	if(debug > 2) 
+		printk("Setting CAS signalling bits to: %d for ch: %s\n", bits, chan->name);
+
+	spin_lock_irqsave(&wc->lock, flags);	
+
+	if (wc->spantype == MODE_E1) 				// E1 CAS (R2) signalling
+	{ 							
+		if (chan->chanpos == 16) 			// channel 16 is the signalling channel even for CAS	
+		{
+			spin_unlock_irqrestore(&wc->lock, flags);
+			return 0;				// so leave it alone 	
+		}
+
+		n = chan->chanpos - 1;
+
+		if (chan->chanpos > 15) 			// move everything above channel 16 one down
+			n--;
+
+		b  = (n % 15);
+		c  = wc->txsigs[b];
+		m  = (n / 15) << 2; 				// we have to write one nibble with new bits
+		c &= (0xf << m); 				// while keeping the other nibble as is
+		c |= (bits & 0xf) << (4 - m); 		
+
+		wc->txsigs[b] = c;
+
+		__t1_framer_out(wc,FR_XS2 + b,c); 		// In E1 mode XS1 is not used for CAS signalling
+
+	} 
+	else							// T1 or J1 CAS mode
+	{
+		if (wc->span.lineconfig & ZT_CONFIG_D4) 	// Old D4 framin selected	
+		{
+			n  = chan->chanpos - 1;
+			b  = (n/4);
+			c  = wc->txsigs[b];
+			m  = ((3 - (n % 4)) << 1); 		// D4 only uses 2 CAS bits per channel
+			c &= ~(0x3 << m); 			// do the nibble thing
+			c |= ((bits >> 2) & 0x3) << m; 
+			wc->txsigs[b] = c;
+		  						// output them to the chip */
+			__t1_framer_out(wc,FR_XS1 + b ,c); 	// since there are only 2 bits per channel
+			__t1_framer_out(wc,FR_XS6 + b ,c); 	// write them into the CAS registers twice
+		} 
+		else
+		{ 
+			if (wc->span.lineconfig & ZT_CONFIG_ESF) // ESF = CAS 4 bits per channel
+			{
+				n  = chan->chanpos - 1;
+				b  = (n/2);
+				c  = wc->txsigs[b];
+				m  = ((n % 2) << 2); 		// do the nibble thing
+				c &= (0xf << m); 		
+				c |= (bits & 0xf) << (4 - m); 
+				wc->txsigs[b] = c;
+								// output them to the chip 
+				__t1_framer_out(wc,FR_XS1 + b,c); // write only once 
+			} 
+		}
+	}
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	if (debug > 2)
+		printk("Finished setting CAS signalling bits\n");
+
+	return 0;
+}
+
+
+static void __t1_check_sigbits(struct t1 *wc)						// read the current CAS bits from framerchip
+{
+	int a,i,rxs;
+
+	if (!(wc->span.flags & ZT_FLAG_RUNNING))
+		return;
+
+	if (wc->spantype == MODE_E1) 							// E1 CAS mode selected
+	{
+		for (i = 0; i < 15; i++) 						// do this in 16 steps
+		{
+			a = __t1_framer_in(wc, FR_RS2 + i);				// RS1 is not used for CAS bits
+			rxs = (a & 0xf);					
+
+			if (!(wc->span.chans[i+16].sig & ZT_SIG_CLEAR)) 		// get lower nibble = channel+16
+			{
+				if (wc->span.chans[i+16].rxsig != rxs)
+					zt_rbsbits(&wc->span.chans[i+16], rxs);
+			}
+
+			rxs = (a >> 4) & 0xf;						// get upper nibble = channel +0
+
+			if (!(wc->span.chans[i].sig & ZT_SIG_CLEAR)) 
+			{
+				if (wc->span.chans[i].rxsig != rxs)
+					zt_rbsbits(&wc->span.chans[i], rxs);
+			}
+		}
+	} 
+	else 										// T1 or J1 mode selected
+	{
+		if (wc->span.lineconfig & ZT_CONFIG_D4) 				// D4 framing selected
+		{									// D4 uses only 2 CAS bits per channel
+			for (i = 0; i < 24; i+=4) 					// do it in 6 steps
+			{
+				a = __t1_framer_in(wc, FR_RS1 + (i>>2));
+				
+				rxs = (a & 0x3) << 2;					// get bits.0 and .1 = channel +3
+				if (!(wc->span.chans[i+3].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i+3].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i+3], rxs);
+				}
+	
+				rxs = (a & 0xc);					// get bits.2 and .3 = channel +2	
+				if (!(wc->span.chans[i+2].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i+2].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i+2], rxs);
+				}
+	
+				rxs = (a >> 2) & 0xc;					// get bits.4 and .5 = channel +1
+				if (!(wc->span.chans[i+1].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i+1].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i+1], rxs);
+				}
+	
+				rxs = (a >> 4) & 0xc;					// get bits.6 and .7 = channel +0
+				if (!(wc->span.chans[i].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i], rxs);
+				}
+			}
+		}
+		else 									// ESF framing uses 4 CAS bits per channel
+		{
+			for (i = 0; i < 24; i+=2) 					// do this in 12 steps 
+			{
+				a = __t1_framer_in(wc, FR_RS1 + (i>>1));	
+		
+				rxs = (a & 0xf);					// get lower nibble = channel +1 
+				if (!(wc->span.chans[i+1].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i+1].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i+1], rxs);
+				}
+		
+				rxs = (a >> 4) & 0xf;					// get upper nibble = channel +0
+				if (!(wc->span.chans[i].sig & ZT_SIG_CLEAR)) 
+				{
+					if (wc->span.chans[i].rxsig != rxs)
+						zt_rbsbits(&wc->span.chans[i], rxs);
+				}
+			}
+		}
+	}	
+}
+
+
+static void t4_serial_setup(struct t1 *wc)
+{
+	unsigned int RC,XC;
+
+	switch (wc->spantype)
+	{
+		case MODE_E1:			// E1 mode
+        		printk("DS1x1F: Setting global parameters for E1 \n");
+			break;
+
+		case MODE_UE1:			// NEW - Unframed E1 mode
+        		printk("DS1x1F: Setting global parameters for Unchannelized E1 \n");
+			break;
+
+		case MODE_J1:			// J1 mode
+        		printk("DS1x1F: Setting global parameters for J1 \n");
+			break;
+
+		default:			// All others default to T1
+        		printk("DS1x1F: Setting global parameters for T1 \n");
+			break;
+	}
+
+
+	RC = 0x000;				// Rt = 4 x 125 ns cycle
+	XC = 0x004;				// Xt = 0 x 125 nS cycles
+
+	t1_framer_out(wc, FR_GPC1, 0xe0);	// GPC1: Multiplex mode enabled, FSC is output, active low, RCLK from channel 0
+	t1_framer_out(wc, FR_IPC,  0x05);	// IPC: Interrupt push/pull active low 
+
+	t1_framer_out(wc, FR_GCM1, 0x66);	
+	t1_framer_out(wc, FR_GCM2, 0x0e);
+	t1_framer_out(wc, FR_GCM3, 0x3f);
+	t1_framer_out(wc, FR_GCM4, 0x0f);
+	t1_framer_out(wc, FR_GCM5, 0x04);
+	t1_framer_out(wc, FR_GCM6, 0x3c);
+	t1_framer_out(wc, FR_GCM7, 0x9c);
+	t1_framer_out(wc, FR_GCM8, 0x90);
+
+	t1_framer_out(wc, FR_GCR,  0x40);		// GCR: Interrupt on Activation/Deactivation of AIX, LOS 
+	t1_framer_out(wc, FR_SIC1, 0x82);		// SIC1: 2.048 Mhz clock/bus, double buffer receive / transmit, byte interleaved
+	t1_framer_out(wc, FR_SIC2, 0x00); 		// SIC2: No FFS, no center receive eliastic buffer, phase 0
+	t1_framer_out(wc, FR_SIC3, 0x08);		// SIC3: Edges for capture tx latches with rising edge / rx changes with falling edge
+	t1_framer_out(wc, FR_CMR1, 0x30);		// CMR1: RCLK is at 8.192 Mhz dejittered
+	t1_framer_out(wc, FR_CMR2, 0x25);   		// CMR2: sync and clock for tx and rx provided by FALC
+
+	t1_framer_out(wc, FR_XC0,  0x00 | ((XC >> 8) & 0x07));		// XC0: Normal operation of Sa-bits
+	t1_framer_out(wc, FR_XC1,  XC & 0xff);				// XC1: tx offset
+
+	t1_framer_out(wc, FR_RC0,  0x00 | ((RC >> 8) & 0x07));		// RC0: rx offset
+	t1_framer_out(wc, FR_RC1,  RC & 0xff);				// RC1:
+
+							// ------------- Configure ports ---------------
+	t1_framer_out(wc, FR_PC1,  0x10);		// PC1: FMR/SPYX output/input on RPA/XPA
+	t1_framer_out(wc, FR_PC2,  0x65);		// PC2: unused
+	t1_framer_out(wc, FR_PC3,  0x65);		// PC3: unused
+	t1_framer_out(wc, FR_PC4,  0x35);		// PC4: unused
+	t1_framer_out(wc, FR_PC5,  0x33);		// PC5: XMFS active low, SCLKR is input, RCLK is output
+	t1_framer_out(wc, FR_PC6,  0x01);		// PC6: CLK1 is Tx Clock output, CLK2 is 2.048 Mhz from DCO-R
+
+	t1_framer_out(wc, FR_LCR1, 0x00);		// Clear LCR1
+
+	printk("DS1x1F: Successfully initialized card\n");
+}
+
+
+static void __t1_configure_t1(struct t1 *wc, int lineconfig, int txlevel)
+{
+	char *mode, *frame, *lcode;
+	char as1;
+	char xlt;
+	
+	__t1_framer_out(wc, FR_FMR1, 0xbc);		// FMR1: Mode 1, T1 mode, CRC on for ESF, 2.048 Mhz system data rate, no XAIS
+
+	switch (monitor)				// module parameter monitor 
+	{
+		case 1:					
+			as1 = 0x00;			// Tx = normal / Rx = Hi-Z
+			xlt = 0x00;
+			break;
+			
+		case 2:
+			as1 = 0x02;			// Tx = Hi-Z  / Rx = 100 Ohm
+			xlt = 0x40;
+			break;				
+			
+		case 3:
+			as1 = 0x00;			// Tx = Hi-Z  / Rx = Hi-Z
+			xlt = 0x40;
+			break;
+			
+		default:				// Tx = normal / Rx = 100 Ohm
+			as1 = 0x02;
+			xlt = 0x00;
+			break;
+	}
+	
+							/* Configure line interface */
+	if (lineconfig & ZT_CONFIG_AMI) 
+	{
+		lcode = "AMI";
+		__t1_framer_out(wc, FR_FMR0, 0xa0);
+	} 
+	else 
+	{
+		lcode = "B8ZS";
+		__t1_framer_out(wc, FR_FMR0, 0xf0);
+	}
+
+ 	if (!(lineconfig & ZT_CONFIG_D4) && !(lineconfig & ZT_CONFIG_ESF))	// support for F4  4 frame format
+	{
+		frame = "F4";
+		if (loopback)
+			__t1_framer_out(wc, FR_FMR2, 0x26);
+		else
+			__t1_framer_out(wc, FR_FMR2, 0x22);
+
+		if (wc->spantype == MODE_J1)
+			__t1_framer_out(wc, FR_FMR4, 0x1d);
+		else
+			__t1_framer_out(wc, FR_FMR4, 0x0d);
+	} 
+
+	if (!(lineconfig & ZT_CONFIG_D4) && (lineconfig & ZT_CONFIG_ESF))	// standard ESF 24 frame format 
+	{
+		frame  = "ESF";
+
+		if (loopback)
+			__t1_framer_out(wc, FR_FMR2, 0xe6);
+		else
+			__t1_framer_out(wc, FR_FMR2, 0xe2);
+	
+		if (wc->spantype == MODE_J1)
+			__t1_framer_out(wc, FR_FMR4, 0x1e);
+		else
+			__t1_framer_out(wc, FR_FMR4, 0x0e);
+	}
+
+	if ((lineconfig & ZT_CONFIG_D4) && !(lineconfig & ZT_CONFIG_ESF))	// standard D4  12 frame format
+	{
+		frame = "D4";
+		if (loopback)
+			__t1_framer_out(wc, FR_FMR2, 0x26);
+		else
+			__t1_framer_out(wc, FR_FMR2, 0x22);
+
+		if (wc->spantype == MODE_J1)
+			__t1_framer_out(wc, FR_FMR4, 0x1c);
+		else
+			__t1_framer_out(wc, FR_FMR4, 0x0c);
+	}
+
+ 	if ((lineconfig & ZT_CONFIG_D4) && (lineconfig & ZT_CONFIG_ESF))	// support for SLC96 framing mode used in TR-08 circuits
+	{
+		frame = "SLC96";
+		if (loopback)
+			__t1_framer_out(wc, FR_FMR2, 0x26);
+		else
+			__t1_framer_out(wc, FR_FMR2, 0x22);
+
+		if (wc->spantype == MODE_J1)
+			__t1_framer_out(wc, FR_FMR4, 0x1f);
+		else
+			__t1_framer_out(wc, FR_FMR4, 0x0f);
+	} 
+
+
+	__t1_framer_out(wc, FR_FMR5, 0x40);		// FMR5: Enable RBS mode */
+
+	__t1_framer_out(wc, FR_LIM1, 0xf8);		// LIM1: Clear data in case of LOS, Set receiver threshold (0.5V), No remote loop, no DRS
+	__t1_framer_out(wc, FR_LIM0, 0x08);		// LIM0: Enable auto long haul mode, no local loop (must be set after LIM1)
+
+	__t1_framer_out(wc, FR_CMDR, 0x50);		// CMDR: Reset the receiver and transmitter line interface
+	__t1_framer_out(wc, FR_CMDR, 0x00);		// CMDR: Reset the receiver and transmitter line interface 
+
+	__t1_framer_out(wc, FR_PCD,  0x0a);		// PCD: LOS after 176 consecutive "zeros" 
+	__t1_framer_out(wc, FR_PCR,  0x15);		// PCR: 22 "ones" clear LOS 
+
+	if (wc->spantype == MODE_J1)
+	{
+		mode = "J1";
+		__t1_framer_out(wc, FR_RC0, 0x80); 		// J1 overide
+	}
+	else
+	{
+		mode = "T1";
+	}
+		
+	switch (txlevel) 					// Set Tx pulse mask + Rx line build out  
+	{
+		case 7:
+			__t1_framer_out(wc, FR_LIM2, 0xe1 | as1);	// LIM2: LBO=3, RST=50%, LOS1=1
+			__t1_framer_out(wc, FR_XPM0, 0x07);		// XPM0 
+			__t1_framer_out(wc, FR_XPM1, 0x01);		// XPM1 
+			__t1_framer_out(wc, FR_XPM2, 0x00 | xlt);	// XPM2 
+			break;
+	
+		case 6:
+			__t1_framer_out(wc, FR_LIM2, 0xa1 | as1);	// LIM2: LBO=2, RST=50%, LOS1=1      
+			__t1_framer_out(wc, FR_XPM0, 0x8c);		// XPM0
+			__t1_framer_out(wc, FR_XPM1, 0x11);		// XPM1 
+			__t1_framer_out(wc, FR_XPM2, 0x01 | xlt);	// XPM2
+			break;
+	
+		case 5:
+			__t1_framer_out(wc, FR_LIM2, 0x61 | as1);	// LIM2: LBO=1, RST=50%, LOS1=1
+			__t1_framer_out(wc, FR_XPM0, 0x8c);		// XPM0
+			__t1_framer_out(wc, FR_XPM1, 0x01);		// XPM1
+			__t1_framer_out(wc, FR_XPM2, 0x00 | xlt);	// XPM2
+			break;
+	
+		default:
+			__t1_framer_out(wc, FR_LIM2, 0x21 | as1);	// LIM2: LBO=0, RST=50%, LOS1=1
+			__t1_framer_out(wc, FR_XPM0, 0xd7);		// XPM0
+			__t1_framer_out(wc, FR_XPM1, 0x22);		// XPM1
+			__t1_framer_out(wc, FR_XPM2, 0x01 | xlt);	// XPM2
+			break;
+	}
+
+
+	printk("DS1x1F: Configured Mode: %s Framing: %s Linecode: %s\n", mode, frame, lcode);
+}
+
+
+static void __t1_configure_e1(struct t1 *wc, int lineconfig)
+{
+	unsigned int  fmr2, fmr1;
+	unsigned int  cas = 0;
+	char         *crc4 = "";
+	char         *frame, *lcode;
+	char	      as1;
+	char          xlt;
+	
+	fmr1 = 0x44; 					/* FMR1: E1 mode, Automatic force resync, PCM30 mode, 2.048 Mhz backplane, no XAIS */
+	fmr2 = 0x03; 					/* FMR2: Auto transmit remote alarm, auto loss of multiframe recovery, no payload loopback */
+
+	switch (monitor)				// module parameter monitor 
+	{
+		case 1:					
+			as1 = 0x00;			// Tx = normal / Rx = Hi-Z
+			xlt = 0x00;
+			break;
+			
+		case 2:
+			as1 = 0x02;			// Tx = Hi-Z  / Rx = 100 Ohm
+			xlt = 0x40;
+			break;				
+			
+		case 3:
+			as1 = 0x00;			// Tx = Hi-Z  / Rx = Hi-Z
+			xlt = 0x40;
+			break;
+			
+		default:				// Tx = normal / Rx = 100 Ohm
+			as1 = 0x02;
+			xlt = 0x00;
+			break;
+	}
+
+	
+	if (wc->spantype == MODE_UE1)
+		fmr2 |= 0x30;
+
+	if (loopback)
+		fmr2 |= 0x4;
+
+	if (lineconfig & ZT_CONFIG_CRC4) 
+	{
+		fmr1 |=   0x08;				/* CRC4 transmit */
+		fmr2 |=   0xc0;				/* CRC4 receive */
+		crc4  = "/CRC4";
+	}
+
+	__t1_framer_out(wc, FR_FMR1, fmr1);
+	__t1_framer_out(wc, FR_FMR2, fmr2);
+
+
+	if (lineconfig & ZT_CONFIG_AMI) 		/* Configure line interface */
+	{
+		lcode = "AMI";
+		__t1_framer_out(wc, FR_FMR0, 0xa0);
+	} 
+	else 
+	{
+		lcode = "HDB3";
+		__t1_framer_out(wc, FR_FMR0, 0xf0);
+	}
+
+	if (lineconfig & ZT_CONFIG_CCS) 
+	{
+		frame = "CCS";
+	} 
+	else 
+	{
+		frame = "CAS";
+		cas   =  0x40;
+	}
+
+	if (wc->spantype == MODE_UE1)
+		__t1_framer_out(wc, FR_LOOP, 0x40);
+
+	__t1_framer_out(wc, FR_LIM1, 0xf0);			// LIM1: Clear data in case of LOS, Set receiver threshold (0.5V), No remote loop, no DRS
+	__t1_framer_out(wc, FR_LIM0, 0x08);			// LIM0: Enable auto long haul mode, no local loop (must be after LIM1)
+
+	__t1_framer_out(wc, FR_CMDR, 0x50);			// CMDR: Reset the receiver and transmitter line interface
+	__t1_framer_out(wc, FR_CMDR, 0x00);			// CMDR: Reset the receiver and transmitter line interface
+
+								// Condition receive line interface for E1 after reset
+	__t1_framer_out(wc, 0xbb, 0x17);
+	__t1_framer_out(wc, 0xbc, 0x55);
+	__t1_framer_out(wc, 0xbb, 0x97);
+	__t1_framer_out(wc, 0xbb, 0x11);
+	__t1_framer_out(wc, 0xbc, 0xaa);
+	__t1_framer_out(wc, 0xbb, 0x91);
+	__t1_framer_out(wc, 0xbb, 0x12);
+	__t1_framer_out(wc, 0xbc, 0x55);
+	__t1_framer_out(wc, 0xbb, 0x92);
+	__t1_framer_out(wc, 0xbb, 0x0c);
+	__t1_framer_out(wc, 0xbb, 0x00);
+	__t1_framer_out(wc, 0xbb, 0x8c);
+	
+	__t1_framer_out(wc, FR_LIM2, 0x20 | as1);		// LIM2: 50% peak amplitude is a "1"
+	__t1_framer_out(wc, FR_PCD,  0x0a);			// PCD: LOS after 176 consecutive "zeros"
+	__t1_framer_out(wc, FR_PCR,  0x15);			// PCR: 22 "ones" clear LOS
+	
+	__t1_framer_out(wc, FR_XSW,  0x9f);			// XSW: Spare bits all to 1 
+
+	if (wc->spantype == MODE_UE1)
+		__t1_framer_out(wc, FR_XSP, 0x3c      );
+	else
+		__t1_framer_out(wc, FR_XSP, 0x1c | cas);	// XSP: E-bit set when async. AXS auto, XSIF to 1
+		
+								// Generate pulse mask for E1
+	__t1_framer_out(wc, FR_XPM0, 0x54);			// XPM0
+	__t1_framer_out(wc, FR_XPM1, 0x02);			// XPM1
+	__t1_framer_out(wc, FR_XPM2, 0x00 | xlt);		// XPM2
+
+	if (wc->spantype == MODE_UE1)
+		printk("DS1x1F: Configured Mode: E1-Unchannelized Framing: %s Linecode: %s\n", frame, lcode);
+	else
+		printk("DS1x1F: Configured Mode: E1%s Framing: %s Linecode: %s\n", crc4, frame, lcode);
+
+}
+//-----------------------------------------------------------------------------------------------------------------------------------------
+
+
+static void ds1_framer_start(struct t1 *wc, struct zt_span *span)
+{
+	int alreadyrunning = wc->span.flags & ZT_FLAG_RUNNING;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+
+	if (wc->spantype & MODE_E1) 
+	{ 						// configure in E1/ UE1 mode
+		__t1_configure_e1(wc, span->lineconfig);
+	} 
+	else 
+	{ 						// configure in T1 / J1 mode
+		__t1_configure_t1(wc, span->lineconfig, span->txlevel);
+		__ds1_set_clear(wc);
+	}
+	
+	if (!alreadyrunning) 
+		wc->span.flags |= ZT_FLAG_RUNNING;
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+}
+
+
+static int ds1_startup(struct zt_span *span)
+{
+	struct t1 *wc = span->pvt;
+
+	int alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+							// initialize the start value for the entire chunk of last ec buffer 
+							// Reset framer with proper parameters and start 
+	ds1_framer_start(wc, span);
+	printk("Calling startup (flags is %d)\n", span->flags);
+
+ 	ctrl_write_reg(wc, CTRL_REL  | CTRL_LRED);	// now enable the relay
+ 
+
+	if (!alreadyrunning) 
+	{						// Only if we're not already going
+		ds1_enable_interrupts(wc);
+		span->flags |= ZT_FLAG_RUNNING;
+	}
+	return 0;
+}
+
+
+static int ds1_shutdown(struct zt_span *span)
+{
+	struct t1 *wc = span->pvt;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+
+	__t1_framer_out(wc, FR_GCR, 0x41);		// GCR: Interrupt on Activation/Deactivation of AIX, LOS
+
+	ds1_disable_interrupts(wc);
+
+ 	ctrl_write_reg(wc, CTRL_LRED);			// turn off relay and turn on RED LED only
+
+	span->flags &= ~ZT_FLAG_RUNNING;
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return 0;
+}
+
+
+static int ds1_chanconfig(struct zt_chan *chan, int sigtype)
+{
+	struct t1 *wc = chan->pvt;
+	unsigned long flags;
+	int alreadyrunning = chan->span->flags & ZT_FLAG_RUNNING;
+
+	spin_lock_irqsave(&wc->lock, flags);
+
+	if (alreadyrunning && (wc->spantype != MODE_E1))
+		__ds1_set_clear(wc);
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return 0;
+}
+
+
+static int ds1_spanconfig(struct zt_span *span, struct zt_lineconfig *lc)
+{
+	span->lineconfig = lc->lineconfig;
+	span->txlevel    = lc->lbo;
+	span->rxlevel    = 0;
+							/* Do we want to SYNC on receive or not */
+							/* If already running, apply changes immediately */
+	if (span->flags & ZT_FLAG_RUNNING)
+		return ds1_startup(span);
+
+	return 0;
+}
+
+
+static int ds1_software_init(struct t1 *wc)
+{
+	int x;						/* Find position */
+
+	for (x = 0; x < WC_MAX_CARDS; x++) 
+	{
+		if (!cards[x]) 
+		{
+			cards[x] = wc;
+			break;
+		}
+	}
+
+	if (x >= WC_MAX_CARDS)
+		return -1;
+
+	t4_serial_setup(wc);
+	wc->num = x;
+
+	sprintf(wc->span.name, "WCT1/%d"                , wc->num);
+	sprintf(wc->span.desc, "%s Card %d", wc->variety, wc->num);
+
+	wc->span.spanconfig = ds1_spanconfig;
+	wc->span.chanconfig = ds1_chanconfig;
+	wc->span.startup    = ds1_startup;
+	wc->span.shutdown   = ds1_shutdown;
+	wc->span.rbsbits    = ds1_rbsbits;
+	wc->span.maint      = ds1_maint;
+	wc->span.open       = ds1_open;
+	wc->span.close      = ds1_close;
+
+	switch (wc->spantype)
+	{
+		case MODE_UE1:
+			wc->span.channels = 32;
+			break;
+
+		case MODE_E1:
+			wc->span.channels = 31;
+			break;
+
+		default:
+			wc->span.channels = 24;
+			break;
+	}
+
+	wc->span.chans      = wc->chans;
+	wc->span.flags      = ZT_FLAG_RBS;
+	wc->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_B8ZS | ZT_CONFIG_D4 | ZT_CONFIG_ESF;
+	wc->span.ioctl      = ds1_ioctl;
+	wc->span.pvt        = wc;
+
+	if (wc->spantype & MODE_E1)
+		wc->span.deflaw = ZT_LAW_ALAW;
+	else
+		wc->span.deflaw = ZT_LAW_MULAW;
+
+	init_waitqueue_head(&wc->span.maintq);
+
+	for (x=0;x<wc->span.channels;x++) 
+        {
+		sprintf(wc->chans[x].name, "WCT1/%d/%d", wc->num, x + 1);
+		wc->chans[x].sigcap = ZT_SIG_EM | ZT_SIG_CLEAR | ZT_SIG_EM_E1 | 
+				      ZT_SIG_FXSLS | ZT_SIG_FXSGS | 
+				      ZT_SIG_FXSKS | ZT_SIG_FXOLS | ZT_SIG_DACS_RBS |
+				      ZT_SIG_FXOGS | ZT_SIG_FXOKS | ZT_SIG_CAS | ZT_SIG_SF;
+		wc->chans[x].pvt = wc;
+		wc->chans[x].chanpos = x + 1;
+	}
+
+	if (zt_register(&wc->span, 0)) 
+	{
+		printk("Unable to register span with zaptel\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+static inline void __handle_leds(struct t1 *wc)
+{
+	int oldreg;
+
+	wc->blinktimer++;
+
+	if (wc->blinktimer >= 4000) 
+		wc->blinktimer = 0;
+
+	oldreg = wc->ledtestreg;
+
+	if (wc->span.alarms & ZT_ALARM_RED)				// RED alarm active 
+	{								// LOS  = loss of signal
+		if (wc->blinktimer < 50) 
+			wc->ledtestreg = CTRL_LRED;
+		else
+			wc->ledtestreg = CTRL_LOFF;
+	
+		if (wc->blinktimer >= 200) 				// very fast flickering
+			wc->blinktimer = 0;
+					
+	} 
+	else 
+	{
+		if (wc->span.alarms & ZT_ALARM_YELLOW) 			// YELLOW ALARM = RED LED flashing
+		{							// other side can't see our signal
+			if (wc->blinktimer < 250) 
+				wc->ledtestreg = CTRL_LRED;
+			else
+				wc->ledtestreg = CTRL_LOFF;
+	
+			if (wc->blinktimer >= 500) 			// flashing
+				wc->blinktimer = 0;
+		} 
+		else								
+		{
+			if (wc->span.alarms & ZT_ALARM_BLUE)		// BLUE ALARM 
+			{						// T1 failure in front of a repeater down the line
+				if (wc->blinktimer < 250) 
+					wc->ledtestreg = CTRL_LGRN;	// GREEN LED flashing
+				else
+					wc->ledtestreg = CTRL_LOFF;
+	
+				if (wc->blinktimer >= 500) 		// flashing
+					wc->blinktimer = 0;
+			} 
+			else	
+			{						// NO ALARM
+				if (wc->blinktimer < 150)		// slow winking green led heartbeat
+					wc->ledtestreg = CTRL_LOFF;
+				else
+					wc->ledtestreg = CTRL_LGRN;	// GREEN LED on most of the time
+			}
+		}
+	}
+
+	if (oldreg != wc->ledtestreg)					// only when some bits have changed
+		led_write_reg(wc, wc->ledtestreg);			// write LED bits 0,1
+}
+
+
+//====================================== SEND MEDIA DATA =====================================
+static void ds1_media(struct t1 *wc)
+{
+        int x,y,ty,ry,shift;
+        unsigned int tx,rx;
+	char frm;
+
+	frm = (clk_read_reg(wc) & 0x07) + 1;					 // see how many frames are to be read by card
+
+        ty = wc->txchunkptr;
+        ry = wc->rxchunkptr;
+
+
+	for (y = 0; y < frm; y++)
+	{
+		int reg = y * 32;
+
+	        if (ty >= ZT_CHUNKSIZE)
+	        {
+	                ty = 0;
+	                zt_transmit(&wc->span);
+	        }
+
+	        rx = ioread32(wc->ioaddr + OFS_TDM_RD + 0 + reg);			// read in first 4 channels	
+	        tx = 0xff;								// FALC-56 uses TS0 for sync purposes only
+
+	        for (x=1; x<=wc->span.channels; x++)
+	        {
+	                if ((x % 4) == 0)
+	                {
+	                        iowrite32(tx, wc->ioaddr + OFS_TDM_WR + x - 4 + reg);   // write 4 bytes (channels)  of pcm data
+	                        tx = 0;
+	                        rx = ioread32(wc->ioaddr + OFS_TDM_RD + x     + reg);
+        	        }
+
+	                shift = ((x % 4) << 3);
+	                tx |= (wc->chans[x-1].writechunk[ty] & 0xff) << shift;
+	                       wc->chans[x-1].readchunk [ry] =  (rx  >> shift) & 0xff;
+	        }
+
+	        iowrite32(tx, wc->ioaddr + OFS_TDM_WR + (x & 0xfc) + reg);             // write 4 bytes (channels)  of pcm data
+
+		ty++;
+	        ry++;
+
+	        if (ry >= ZT_CHUNKSIZE)
+	        {
+	                ry = 0;
+
+		        for (x=0; x<wc->span.channels; x++)				// handle echocanceller memory fill
+		        {
+		              zt_ec_chunk(&wc->chans[x], wc->chans[x].readchunk,  wc->ec_chunk2[x]);
+
+		              memcpy(wc->ec_chunk2[x],   wc->ec_chunk1[x]       , ZT_CHUNKSIZE);
+		              memcpy(wc->ec_chunk1[x],   wc->chans[x].writechunk, ZT_CHUNKSIZE);
+		        }
+
+	                zt_receive(&wc->span);
+	        }
+	}
+        
+	wc->txchunkptr = ty;
+	wc->rxchunkptr = ry;
+}
+
+
+
+//===============================================================================================================================================================================
+
+
+static void __t1_check_alarms(struct t1 *wc)
+{
+	unsigned char c,d;
+	int alarms;
+	int x,j;
+
+	if (!(wc->span.flags & ZT_FLAG_RUNNING))
+		return;
+
+	c = __t1_framer_in(wc, FR_FRS0);
+	d = __t1_framer_in(wc, FR_FRS1);
+
+	/* Assume no alarms */
+	alarms = 0;
+
+	/* And consider only carrier alarms */
+	wc->span.alarms &= (ZT_ALARM_RED | ZT_ALARM_BLUE | ZT_ALARM_NOTOPEN);
+
+	if (wc->spantype & MODE_E1) 
+	{
+		if (c & 0x04) 
+		{				/* No multiframe found, force RAI high after 400ms only if we haven't found a multiframe since last loss of frame */
+			if (!(wc->spanflags & FLAG_NMF)) 
+			{
+				__t1_framer_out(wc, FR_FMR4, 0x9f | 0x20);		/* FMR4: Force RAI High */
+				wc->spanflags |= FLAG_NMF;
+				printk("NMF workaround on!\n");
+			}
+
+			__t1_framer_out(wc, FR_FMR2, 0xc3);			/* Reset to CRC4 mode */
+			__t1_framer_out(wc, FR_FMR0, 0xf2);			/* Force Resync */
+			__t1_framer_out(wc, FR_FMR0, 0xf0);			/* Force Resync */
+		} 
+		else 
+		{
+			if (!(c & 0x02)) 
+			{
+				if ((wc->spanflags & FLAG_NMF)) 
+				{
+					__t1_framer_out(wc, FR_FMR4, 0x9f);	/* FMR4: Clear forced RAI */
+					wc->spanflags &= ~FLAG_NMF;
+					printk("NMF workaround off!\n");
+				}
+			}
+		}
+	} 
+	else 
+	{									/* Detect loopup code if we're not sending one */
+		if ((!wc->span.mainttimer) && (d & 0x08)) 
+		{
+			if ((wc->loopupcnt++ > 80)  && (wc->span.maintstat != ZT_MAINT_REMOTELOOP)) 	// Loop-up code detected 
+			{
+				__t1_framer_out(wc, FR_LIM0, 0x08);					// LIM0: Disable any local loop
+				__t1_framer_out(wc, FR_LIM1, 0xf6);					// LIM1: Enable remote loop
+
+				wc->span.maintstat = ZT_MAINT_REMOTELOOP;				// maintainance status = REMOTELOOP
+			}
+		} 
+		else
+			wc->loopupcnt = 0;
+		
+										/* Same for loopdown code */
+		if ((!wc->span.mainttimer) && (d & 0x10)) 
+		{								/* Loop-down code detected */
+			if ((wc->loopdowncnt++ > 80)  && (wc->span.maintstat == ZT_MAINT_REMOTELOOP)) 
+			{
+				__t1_framer_out(wc, FR_LIM0, 0x08);		/* LIM0: Disable any local loop */
+				__t1_framer_out(wc, FR_LIM1, 0xf0);		/* LIM1: Disable remote loop */
+				wc->span.maintstat = ZT_MAINT_NONE;
+			}
+		} 
+		else
+			wc->loopdowncnt = 0;
+	}
+
+	if (wc->span.lineconfig & ZT_CONFIG_NOTOPEN) 
+	{
+		for (x=0,j=0;x < wc->span.channels;x++)
+		{
+			if ((wc->span.chans[x].flags & ZT_FLAG_OPEN) || (wc->span.chans[x].flags & ZT_FLAG_NETDEV))
+				j++;
+		}
+
+		if (!j)
+			alarms |= ZT_ALARM_NOTOPEN;
+	}
+
+	if (c & 0xa0) 
+	{
+		if (wc->alarmcount >= alarmdebounce) 
+		{
+			if (!(wc->spantype & 0x80))
+				alarms |= ZT_ALARM_RED;
+		} 
+		else
+			wc->alarmcount++;
+	} 
+	else
+		wc->alarmcount = 0;
+
+	if (c & 0x4)
+		alarms |= ZT_ALARM_BLUE;
+
+										/* Keep track of recovering */
+	if ((!alarms) && wc->span.alarms) 
+		wc->alarmtimer = ZT_ALARMSETTLE_TIME;
+
+	if (wc->alarmtimer)
+		alarms |= ZT_ALARM_RECOVER;
+
+										/* If receiving alarms, go into Yellow alarm state */
+	if (alarms && !(wc->spanflags & FLAG_SENDINGYELLOW)) 
+	{
+		unsigned char fmr4;
+		printk("DS1x1F: Setting yellow alarm\n");
+										/* We manually do yellow alarm to handle RECOVER and NOTOPEN, otherwise it's auto anyway */
+		fmr4 = __t1_framer_in(wc, FR_FMR4);
+		__t1_framer_out(wc, FR_FMR4, fmr4 | 0x20);
+
+		wc->spanflags |= FLAG_SENDINGYELLOW;
+	} 
+	else 
+	{
+		if ((!alarms) && (wc->spanflags & FLAG_SENDINGYELLOW)) 
+		{
+			unsigned char fmr4;
+			printk("DS1x1F: Clearing yellow alarm\n");
+										// We manually do yellow alarm to handle RECOVER 
+			fmr4 = __t1_framer_in(wc, FR_FMR4);
+			__t1_framer_out(wc, FR_FMR4, fmr4 & ~0x20);
+
+			wc->spanflags &= ~FLAG_SENDINGYELLOW;
+		}
+	}
+										// Re-check the timing source when we enter/leave alarm, not withstanding yellow alarm
+	if ((c & 0x10) && !(wc->spantype & 0x80))
+		alarms |= ZT_ALARM_YELLOW;
+
+	if (wc->span.mainttimer || wc->span.maintstat) 
+		alarms |= ZT_ALARM_LOOPBACK;
+
+	wc->span.alarms = alarms;
+	zt_alarm_notify(&wc->span);
+}
+
+
+static void __ds1_do_counters(struct t1 *wc)
+{
+	if (wc->alarmtimer) 
+	{
+		if (!--wc->alarmtimer) 
+		{
+			wc->span.alarms &= ~(ZT_ALARM_RECOVER);
+			zt_alarm_notify(&wc->span);
+		}
+	}
+}
+
+///--------------------------------------------------------------------------------------------------------------------------------
+ZAP_IRQ_HANDLER(ds1_interrupt)
+{
+	struct t1 *wc = dev_id;
+	unsigned long flags;
+	unsigned int x;
+	int y;
+	
+	x = ctrl_read_reg(wc);								// read statusregister
+
+	if (!(x & CTRL_IRQ))
+		return IRQ_NONE;
+
+	ctrl_set_reg(wc, CTRL_INTA);							// clear the interrupt flag
+
+	if (!wc->intcount && debug)
+		printk("DS1x1F: Got interrupt\n");
+
+	if (x & CTRL_IRM)								// we missed at least one interrupt
+		printk("DS1x1F: Missed an Interrupt !!!\n");
+	
+	ds1_media(wc);									// handle media / audio- buffers
+
+	x = clk_read_reg(wc) & 0x07;							// get the current frame buffer setting
+
+	spin_lock_irqsave(&wc->lock, flags);
+	
+	y = wc->prescaler - 1;
+
+	if (y < 1)
+	{
+		y = 8 / (x + 1);
+
+		__handle_leds(wc);
+											// Count down timers
+		__ds1_do_counters(wc);							
+
+		wc->intcount++;
+
+		x = wc->intcount & 0x0f;								// Do some things that we don't have to do very often
+
+		switch(x) 
+		{
+			case 0:
+			case 1:
+				break;
+			case 2:
+				__t1_check_sigbits(wc);
+				break;
+			case 4:									// Check alarms 1/4 as frequently
+				if (!(wc->intcount & 0x30))
+					__t1_check_alarms(wc);
+			break;
+		}
+	}
+	wc->prescaler = y;
+	
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	return IRQ_RETVAL(1);
+}
+
+static int memory_test(struct t1 *wc, int pattern)
+{
+	int ret = 0;
+	int x, y;
+
+	for (x=0; x<31; x++)							// clear out tx tdm memory to FF		
+	{
+		iowrite32 (pattern, wc->ioaddr + OFS_TDM_WR + (8 * x)    );
+		
+		y = ioread32(       wc->ioaddr + OFS_TDM_WR + (8 * x)    );
+
+		if (y != pattern)
+		{
+			ret = 1;
+			if (debug)
+				printk("DS1x1F: TDM tx memory failure %08x / %08x @ %02x     LSB\n", pattern, y, x);
+		}
+		else
+			if (debug)
+				printk("DS1x1F: TDM tx memory OK      %08x / %08x @ %02x     LSB\n", pattern, y, x);
+	
+		iowrite32 (pattern, wc->ioaddr + OFS_TDM_RD + (8 * x));
+		
+		y = ioread32(       wc->ioaddr + OFS_TDM_RD + (8 * x));
+
+		if (y != pattern)
+		{
+			ret = 1;
+			if (debug)
+				printk("DS1x1F: TDM rx memory failure %08x / %08x @ %02x MSB\n", pattern, y, x);
+		}
+		else
+			if (debug)
+				printk("DS1x1F: TDM rx memory OK      %08x / %08x @ %02x MSB\n", pattern, y, x);
+
+
+	}
+	return (ret);
+}
+
+
+//--------------------------------------------------------------------------------------------------------------------------------------
+static int ds1_hardware_init(struct t1 *wc)
+{
+	unsigned int vstr, wid;
+	unsigned int x;
+
+	if (frames < 1)								// setting frames = 0 autoadjust to current ZT_CHUNKSIZE
+		frames = ZT_CHUNKSIZE;
+
+	if (frames > 8)								// maximum framebuffer size is 8 frames
+		frames = 8;
+	
+	if (extclk == -1)							// extclk not specified by parameter
+	{	
+		x = ctrl_read_reg(wc);						// read DIP switch
+		extclk = (x >> 14) & 0x03;					// SW 3-4 => clock selection	
+	}	
+	
+	switch (extclk)								// external / H.100 bus clocking options
+	{
+		case 1:								// clock derived from H.100 bus if available
+			x = 0x30 | (frames - 1);
+			break;
+
+		case 2:								// this card is bus clock master
+			x = 0x20 | (frames - 1);
+			break;
+
+		default:							// all other cases - internally clocked / no clk output
+			x =         frames - 1;		
+			break;
+	}
+
+	clk_write_reg (wc, x);							// no loopback
+
+	mdelay(10);								// wait for 10 msec. for FDET settle time
+
+	x = clk_read_reg(wc);
+	
+	switch (x & 0x30)
+	{
+		case 0x20:
+			printk("DS1x1F: Clocking: Busmaster  Framebuffer: %d frames\n",(x & 0x07) + 1);
+			break;
+	
+		case 0x30:
+			if (x & 0x00010000)
+				printk("DS1x1F: Clocking:  External (   clock present on bus) Framebuffer: %d frames\n",(x & 0x07) + 1);
+			else
+				printk("DS1x1F: Clocking: (External) no clock present on bus  Framebuffer: %d frames\n",(x & 0x07) + 1);
+			break;
+	
+		default:
+			printk("DS1x1F: Clocking: Internal  Framebuffer: %d frames\n",(x & 0x07) + 1);
+			break;
+	}
+
+	ctrl_write_reg(wc, CTRL_INTA | CTRL_TEST | CTRL_FRST);
+
+	mdelay(10);								// wait for 10 msec.
+
+	x = ctrl_read_reg(wc);							// read in the controlregister
+
+	ctrl_write_reg(wc, CTRL_LRED);
+
+	mdelay(1);								// wait for 1 msec.
+
+	if (cardmode != -1) 
+		wc->spantype = cardmode;					// read in spanmode paramter 
+	else 
+		switch (x & 0x3000)						// check if SW-1 and SW-2
+		{
+			case 0x0000:
+				wc->spantype = MODE_T1;				// OFF - OFF = T1
+				break;
+
+			case 0x1000:
+				wc->spantype = MODE_J1;				// OFF - ON  = J1
+				break;
+
+			case 0x2000:
+				wc->spantype = MODE_UE1;			// ON - OFF  = unchannelized E1
+				break;
+
+			case 0x3000:
+				wc->spantype = MODE_E1;				// ON - ON   =  E1
+				break;				
+		}
+
+	if (x & CTRL_RELI)
+		printk("DS1x1  Board Ver: %01x.%01x SW=%01x-%01x-%01x-%01x  [%x]\n",(x>>28),((x>>20)&0xf),((x>>15)&1),((x>>14)&1),((x>>13)&1),((x>>12)&1),x);	   
+	else
+		printk("DS1x1F Board Ver: %01x.%01x SW=%01x-%01x-%01x-%01x  [%x]\n",(x>>28),((x>>20)&0xf),((x>>15)&1),((x>>14)&1),((x>>13)&1),((x>>12)&1),x);	  
+
+	vstr = t1_framer_in(wc ,FR_VSTR);					// identify FALC framer chip version
+	wid  = t1_framer_in(wc ,FR_WID );
+
+	if (vstr == 0x05)
+	{
+		if (wid & 0xc0)
+			printk("FALC PEF-2256 Ver: 2.2 detected\n");
+		else
+			printk("FALC PEF-2256 Ver: 2.1 detected\n");
+	}
+	else
+	{
+		if ((wid & 0x03) == 0x03)
+			printk("!!! WARNING !!! Old FALC PEB-2256 Ver: 1.2 detected\n");
+		else
+			printk("!!! WARNING !!! FALC Version unknown: VSTR: %02x WID: %02x\n", vstr, wid);
+	}
+
+	ds1_disable_interrupts(wc);
+
+	x = 0;
+
+	if (memory_test (wc, 0x5555aaaa)) x = 1;
+	if (memory_test (wc, 0x01234567)) x = 1;
+	if (memory_test (wc, 0xaaaa5555)) x = 1;
+	if (memory_test (wc, 0x76543210)) x = 1;
+
+	if (x)
+		printk("DS1x1F: Card TDM memory test failed !!!\n");
+	else
+		printk("DS1x1F: Card TDM memory test completed.\n");
+
+	ds1_enable_interrupts(wc);
+
+	start_alarm(wc);
+	return 0;
+
+}
+
+
+static int __devinit ds1_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct   t1   *wc;
+	unsigned long end;
+
+	
+	if (pci_enable_device(pdev)) 
+	{ 
+		printk (KERN_ALERT "DS1x1F: PCI enable failed\n");
+                pci_disable_device (pdev);
+		return (-EIO);
+	} 
+	else 
+	{
+		wc = kmalloc(sizeof(struct t1), GFP_KERNEL);
+
+		printk("Trying to init an DS1x1F\n");
+
+		if (wc) 
+		{
+			memset(wc, 0x0, sizeof(struct t1));					// initialize structure with 0x00
+			spin_lock_init(&wc->lock);
+
+		        wc->cnstart = pci_resource_start(pdev, 0);                             // read the assigned memory resources for region 0
+		        end   	    = pci_resource_end  (pdev, 0);
+		        wc->cnlen   = end - wc->cnstart + 1;
+		        wc->cres    = request_mem_region(wc->cnstart,wc->cnlen,name);
+		        wc->cnaddr  = ioremap_nocache   (wc->cnstart,wc->cnlen     );
+	
+			if(debug)
+				printk (KERN_INFO "Config resources = [0x%lx-0x%lx] (%ld) \n", wc->cnstart, end, wc->cnlen);
+
+		        wc->iostart = pci_resource_start(pdev, 2);                             // read the assigned memory resources for region 2
+		        end   	    = pci_resource_end  (pdev, 2);
+		        wc->iolen   = end - wc->iostart + 1;
+		        wc->ires    = request_mem_region(wc->iostart,wc->iolen,name);
+		        wc->ioaddr  = ioremap_nocache   (wc->iostart,wc->iolen     );
+
+			if(debug)
+				printk (KERN_INFO "I/O resources    = [0x%lx-0x%lx] (%ld) \n", wc->iostart, end, wc->iolen);
+
+			wc->dev    = pdev;
+			
+			pci_set_drvdata(pdev, wc);					 	// keep track of our device - i.e. for later removal
+
+                        if (request_irq(pdev->irq, ds1_interrupt, ZAP_IRQ_SHARED_DISABLED, "ds1x1f", wc))
+                        {
+                                printk("DS1x1F: Unable to request IRQ %d\n", pdev->irq);
+                                kfree(wc);
+                                return -EIO;
+                        }
+
+			ds1_hardware_init(wc);							// Initialize hardware
+
+			wc->variety = "DS1x1F T1/E1-card";					// We now know which version of card we have 
+			ds1_software_init(wc);							// Misc. software stuff
+
+			printk("Found an: %s\n", wc->variety);
+			return (0);
+		} 
+		else
+		{
+			printk (KERN_ALERT "DS1x1F: failed to allocate memory\n");
+			return (-ENOMEM);
+		}
+	}
+	return (0);
+}
+
+
+static void __devexit ds1_remove(struct pci_dev *pdev)
+{
+	struct t1 *wc = pci_get_drvdata(pdev);
+
+	if (wc) 
+	{
+
+		ds1_disable_interrupts(wc);			// In case hardware is still there 
+		free_irq(pdev->irq, wc);			// release the interrupt resource
+		mdelay(10);
+
+		zt_unregister(&wc->span);
+
+		if (debug) 
+			printk (KERN_ALERT "DS1x1F: resetting relay / falc / red led on\n");
+
+		ctrl_write_reg(wc, CTRL_FRST | CTRL_LRED);	// reset FALC, relay= off, Red LED = on
+
+		if (wc->ioaddr  != NULL)			// unmap io space
+                        iounmap (wc->ioaddr);
+
+		if (wc->cnaddr  != NULL)			// unmap control space
+                        iounmap (wc->cnaddr);
+
+		release_mem_region(wc->iostart, wc->iolen);	// release io memory region
+		release_mem_region(wc->cnstart, wc->cnlen);	// release control memory region
+
+		kfree(wc);
+
+		printk (KERN_ALERT "DS1x1F: disable pci device\n");
+		pci_disable_device (pdev);
+	}
+	else
+		printk (KERN_ALERT "DS1x1F: WARNING Removal Failed !!!\n");
+
+}
+
+
+static struct pci_device_id  ds1_ids[] = { { PCI_DEVICE( 0x2321, 0x011f) }, { 0, }, };
+
+
+MODULE_DEVICE_TABLE(pci,ds1_ids);
+
+
+static struct pci_driver ds1_driver = {
+	name: 	  "ds1x1f",
+	probe: 	  ds1_probe,
+	remove:	  __devexit_p(ds1_remove),
+	suspend:  NULL,
+	resume:   NULL,
+	id_table: ds1_ids,
+};
+
+
+static int __init ds1_init(void)
+{
+	int res;
+	res = zap_pci_module(&ds1_driver);
+
+	if (res)
+		return -ENODEV;
+
+	return 0;
+}
+
+
+static void __exit ds1_cleanup(void)
+{
+	pci_unregister_driver(&ds1_driver);
+}
+
+
+
+module_param(alarmdebounce,  int, 0600);
+module_param(loopback,       int, 0600);
+module_param(cardmode,       int, 0600);
+module_param(frames,         int, 0600);
+module_param(debug,          int, 0600);
+module_param(extclk,         int, 0600);
+module_param(monitor,        int, 0600);
+
+MODULE_DESCRIPTION("TC-DG ds1x1f Zaptel Driver");
+MODULE_AUTHOR("TCDG Corp. <tech@tc-dg.net");
+MODULE_LICENSE("GPL");
+
+module_init(ds1_init);
+module_exit(ds1_cleanup);
+
diff -urN zaptel-1.4.11.org/kernel/opvxa1200.c zaptel-1.4.11/kernel/opvxa1200.c
--- zaptel-1.4.11.org/kernel/opvxa1200.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/opvxa1200.c	2008-07-16 22:06:17.207813701 +0200
@@ -0,0 +1,2718 @@
+/*
+ * OpenVox A1200P FXS/FXO Interface Driver for Zapata Telephony interface
+ *
+ * Modify from wctdm.c by MiaoLin<miaolin@openvox.com.cn>
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ */
+
+/* Rev histroy
+ *
+ * Rev 0.10 initial version	
+ * Rev 0.11 
+ * 	fixed the led light on/off bug.
+ * 	modify some wctdm print to opvxa1200
+ * 	support firmware version 1.2, faster i/o operation, and better LED control.
+ * 
+ * Rev 0.12 patched to support new pci id 0x8519
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ * 
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include "proslic.h"
+#include "wctdm.h"
+  
+//miaolin
+#include <linux/string.h>
+#include <asm/uaccess.h> // get_fs(), set_fs(), KERNEL_DS
+#include <linux/file.h> // fput()
+//miaolin
+  
+
+/*
+ *  Define for audio vs. register based ring detection
+ *  
+ */
+/* #define AUDIO_RINGCHECK  */
+
+/*
+  Experimental max loop current limit for the proslic
+  Loop current limit is from 20 mA to 41 mA in steps of 3
+  (according to datasheet)
+  So set the value below to:
+  0x00 : 20mA (default)
+  0x01 : 23mA
+  0x02 : 26mA
+  0x03 : 29mA
+  0x04 : 32mA
+  0x05 : 35mA
+  0x06 : 37mA
+  0x07 : 41mA
+*/
+static int loopcurrent = 20;
+
+static int reversepolarity = 0;
+
+static alpha  indirect_regs[] =
+{
+{0,255,"DTMF_ROW_0_PEAK",0x55C2},
+{1,255,"DTMF_ROW_1_PEAK",0x51E6},
+{2,255,"DTMF_ROW2_PEAK",0x4B85},
+{3,255,"DTMF_ROW3_PEAK",0x4937},
+{4,255,"DTMF_COL1_PEAK",0x3333},
+{5,255,"DTMF_FWD_TWIST",0x0202},
+{6,255,"DTMF_RVS_TWIST",0x0202},
+{7,255,"DTMF_ROW_RATIO_TRES",0x0198},
+{8,255,"DTMF_COL_RATIO_TRES",0x0198},
+{9,255,"DTMF_ROW_2ND_ARM",0x0611},
+{10,255,"DTMF_COL_2ND_ARM",0x0202},
+{11,255,"DTMF_PWR_MIN_TRES",0x00E5},
+{12,255,"DTMF_OT_LIM_TRES",0x0A1C},
+{13,0,"OSC1_COEF",0x7B30},
+{14,1,"OSC1X",0x0063},
+{15,2,"OSC1Y",0x0000},
+{16,3,"OSC2_COEF",0x7870},
+{17,4,"OSC2X",0x007D},
+{18,5,"OSC2Y",0x0000},
+{19,6,"RING_V_OFF",0x0000},
+{20,7,"RING_OSC",0x7EF0},
+{21,8,"RING_X",0x0160},
+{22,9,"RING_Y",0x0000},
+{23,255,"PULSE_ENVEL",0x2000},
+{24,255,"PULSE_X",0x2000},
+{25,255,"PULSE_Y",0x0000},
+//{26,13,"RECV_DIGITAL_GAIN",0x4000},	// playback volume set lower
+{26,13,"RECV_DIGITAL_GAIN",0x2000},	// playback volume set lower
+{27,14,"XMIT_DIGITAL_GAIN",0x4000},
+//{27,14,"XMIT_DIGITAL_GAIN",0x2000},
+{28,15,"LOOP_CLOSE_TRES",0x1000},
+{29,16,"RING_TRIP_TRES",0x3600},
+{30,17,"COMMON_MIN_TRES",0x1000},
+{31,18,"COMMON_MAX_TRES",0x0200},
+{32,19,"PWR_ALARM_Q1Q2",0x07C0},
+{33,20,"PWR_ALARM_Q3Q4",0x2600},
+{34,21,"PWR_ALARM_Q5Q6",0x1B80},
+{35,22,"LOOP_CLOSURE_FILTER",0x8000},
+{36,23,"RING_TRIP_FILTER",0x0320},
+{37,24,"TERM_LP_POLE_Q1Q2",0x008C},
+{38,25,"TERM_LP_POLE_Q3Q4",0x0100},
+{39,26,"TERM_LP_POLE_Q5Q6",0x0010},
+{40,27,"CM_BIAS_RINGING",0x0C00},
+{41,64,"DCDC_MIN_V",0x0C00},
+{42,255,"DCDC_XTRA",0x1000},
+{43,66,"LOOP_CLOSE_TRES_LOW",0x1000},
+};
+
+static struct fxo_mode {
+	char *name;
+	/* FXO */
+	int ohs;
+	int ohs2;
+	int rz;
+	int rt;
+	int ilim;
+	int dcv;
+	int mini;
+	int acim;
+	int ring_osc;
+	int ring_x;
+} fxo_modes[] =
+{
+	{ "FCC", 0, 0, 0, 1, 0, 0x3, 0, 0, }, 	/* US, Canada */
+	{ "TBR21", 0, 0, 0, 0, 1, 0x3, 0, 0x2, 0x7e6c, 0x023a, },
+										/* Austria, Belgium, Denmark, Finland, France, Germany, 
+										   Greece, Iceland, Ireland, Italy, Luxembourg, Netherlands,
+										   Norway, Portugal, Spain, Sweden, Switzerland, and UK */
+	{ "ARGENTINA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "AUSTRALIA", 1, 0, 0, 0, 0, 0, 0x3, 0x3, },
+	{ "AUSTRIA", 0, 1, 0, 0, 1, 0x3, 0, 0x3, },
+	{ "BAHRAIN", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "BELGIUM", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "BRAZIL", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "BULGARIA", 0, 0, 0, 0, 1, 0x3, 0x0, 0x3, },
+	{ "CANADA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CHILE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CHINA", 0, 0, 0, 0, 0, 0, 0x3, 0xf, },
+	{ "COLUMBIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CROATIA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "CYRPUS", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "CZECH", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "DENMARK", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ECUADOR", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "EGYPT", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "ELSALVADOR", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "FINLAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "FRANCE", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "GERMANY", 0, 1, 0, 0, 1, 0x3, 0, 0x3, },
+	{ "GREECE", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "GUAM", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "HONGKONG", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "HUNGARY", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "ICELAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "INDIA", 0, 0, 0, 0, 0, 0x3, 0, 0x4, },
+	{ "INDONESIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "IRELAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ISRAEL", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ITALY", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "JAPAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "JORDAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "KAZAKHSTAN", 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "KUWAIT", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "LATVIA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "LEBANON", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "LUXEMBOURG", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "MACAO", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "MALAYSIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },	/* Current loop >= 20ma */
+	{ "MALTA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "MEXICO", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "MOROCCO", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "NETHERLANDS", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "NEWZEALAND", 0, 0, 0, 0, 0, 0x3, 0, 0x4, },
+	{ "NIGERIA", 0, 0, 0, 0, 0x1, 0x3, 0, 0x2, },
+	{ "NORWAY", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "OMAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "PAKISTAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "PERU", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "PHILIPPINES", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "POLAND", 0, 0, 1, 1, 0, 0x3, 0, 0, },
+	{ "PORTUGAL", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ROMANIA", 0, 0, 0, 0, 0, 3, 0, 0, },
+	{ "RUSSIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "SAUDIARABIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SINGAPORE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SLOVAKIA", 0, 0, 0, 0, 0, 0x3, 0, 0x3, },
+	{ "SLOVENIA", 0, 0, 0, 0, 0, 0x3, 0, 0x2, },
+	{ "SOUTHAFRICA", 1, 0, 1, 0, 0, 0x3, 0, 0x3, },
+	{ "SOUTHKOREA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SPAIN", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SWEDEN", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SWITZERLAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SYRIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "TAIWAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "THAILAND", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "UAE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "UK", 0, 1, 0, 0, 1, 0x3, 0, 0x5, },
+	{ "USA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "YEMEN", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+};
+
+#ifdef STANDALONE_ZAPATA
+#include "zaptel.h"
+#else
+#include <linux/zaptel.h>
+#endif
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+#define NUM_FXO_REGS 60
+
+#define WC_MAX_IFACES 128
+
+#define DELAY	0x0	/* 30 = 15 cycles, 10 = 8 cycles, 0 = 3 cycles */
+#define WC_OFFSET	4	/* Offset between transmit and receive, in bytes. */
+#define WC_SYNCFLAG	0xca1ef1ac
+
+#define WC_CNTL    	0x00
+#define WC_OPER		0x01
+#define WC_AUXC    	0x02
+#define WC_AUXD    	0x03
+#define WC_MASK0   	0x04
+#define WC_MASK1   	0x05
+#define WC_INTSTAT 	0x06
+#define WC_AUXR		0x07
+
+#define WC_DMAWS	0x08
+#define WC_DMAWI	0x0c
+#define WC_DMAWE	0x10
+#define WC_DMARS	0x18
+#define WC_DMARI	0x1c
+#define WC_DMARE	0x20
+
+#define WC_AUXFUNC	0x2b
+#define WC_SERCTL	0x2d
+#define WC_FSCDELAY	0x2f
+
+#define WC_REGBASE	0xc0
+
+#define WC_VER		0x0
+#define WC_CS		0x1
+#define WC_SPICTRL	0x2
+#define WC_SPIDATA	0x3
+
+#define BIT_SPI_BYHW 	(1 << 0)
+#define BIT_SPI_BUSY    (1 << 1)	// 0=can read/write spi, 1=spi working.
+#define BIT_SPI_START	(1 << 2)
+
+
+#define BIT_LED_CLK     (1 << 0)	// MiaoLin add to control the led. 
+#define BIT_LED_DATA    (1 << 1)	// MiaoLin add to control the led.
+
+#define BIT_CS		(1 << 2)
+#define BIT_SCLK	(1 << 3)
+#define BIT_SDI		(1 << 4)
+#define BIT_SDO		(1 << 5)
+
+#define FLAG_EMPTY	0
+#define FLAG_WRITE	1
+#define FLAG_READ	2
+
+/* the constants below control the 'debounce' periods enforced by the
+   check_hook routines; these routines are called once every 4 interrupts
+   (the interrupt cycles around the four modules), so the periods are
+   specified in _4 millisecond_ increments
+*/
+#define RING_DEBOUNCE		4		/* Ringer Debounce (64 ms) */
+#define DEFAULT_BATT_DEBOUNCE	4		/* Battery debounce (64 ms) */
+#define POLARITY_DEBOUNCE 	4		/* Polarity debounce (64 ms) */
+#define DEFAULT_BATT_THRESH	3		/* Anything under this is "no battery" */
+
+#define OHT_TIMER		6000	/* How long after RING to retain OHT */
+
+#define FLAG_3215	(1 << 0)
+
+//modify by MiaoLin from 4 to 12;
+//#define NUM_CARDS 4
+#define NUM_CARDS 12
+#define NUM_FLAG  4	//number of flag channels.
+
+// if you want to record the last 8 sec voice before the driver unload, uncomment it and rebuild.
+//#define TEST_LOG_INCOME_VOICE
+
+#define MAX_ALARMS 10
+
+#define MOD_TYPE_FXS	0
+#define MOD_TYPE_FXO	1
+
+#define MINPEGTIME	10 * 8		/* 30 ms peak to peak gets us no more than 100 Hz */
+#define PEGTIME		50 * 8		/* 50ms peak to peak gets us rings of 10 Hz or more */
+#define PEGCOUNT	5		/* 5 cycles of pegging means RING */
+
+#define NUM_CAL_REGS 12
+
+struct calregs {
+	unsigned char vals[NUM_CAL_REGS];
+};
+
+enum proslic_power_warn {
+	PROSLIC_POWER_UNKNOWN = 0,
+	PROSLIC_POWER_ON,
+	PROSLIC_POWER_WARNED,
+};
+
+#define voc_buffer_size (8000*8)
+
+struct wctdm {
+	struct pci_dev *dev;
+	char *variety;
+	struct zt_span span;
+	unsigned char ios;
+	int usecount;
+	unsigned int intcount;
+	int dead;
+	int pos;
+	int flags[NUM_CARDS];
+	int freeregion;
+	int alt;
+	int curcard;
+	int cardflag;		/* Bit-map of present cards */
+	enum proslic_power_warn proslic_power;
+	spinlock_t lock;
+
+	union {
+		struct {
+#ifdef AUDIO_RINGCHECK
+			unsigned int pegtimer;
+			int pegcount;
+			int peg;
+			int ring;
+#else			
+			int wasringing;
+#endif			
+			int ringdebounce;
+			int offhook;
+			int battdebounce;
+			int nobatttimer;
+			int battery;
+		        int lastpol;
+		        int polarity;
+		        int polaritydebounce;
+		} fxo;
+		struct {
+			int oldrxhook;
+			int debouncehook;
+			int lastrxhook;
+			int debounce;
+			int ohttimer;
+			int idletxhookstate;		/* IDLE changing hook state */
+			int lasttxhook;
+			int palarms;
+			struct calregs calregs;
+		} fxs;
+	} mod[NUM_CARDS];
+
+	/* Receive hook state and debouncing */
+	int modtype[NUM_CARDS];
+	unsigned char reg0shadow[NUM_CARDS];
+	unsigned char reg1shadow[NUM_CARDS];
+
+	unsigned long ioaddr;
+	unsigned long mem_region;	/* 32 bit Region allocated to tiger320 */
+	unsigned long mem_len;		/* Length of 32 bit region */
+	volatile unsigned long mem32;	/* Virtual representation of 32 bit memory area */
+	
+	dma_addr_t 	readdma;
+	dma_addr_t	writedma;
+	volatile unsigned char *writechunk;					/* Double-word aligned write memory */
+	volatile unsigned char *readchunk;					/* Double-word aligned read memory */
+	struct zt_chan chans[NUM_CARDS];
+
+#ifdef TEST_LOG_INCOME_VOICE	
+	//unsigned char tempo[NUM_CARDS + NUM_FLAG];
+	char * voc_buf[NUM_CARDS + NUM_FLAG];
+	int voc_ptr[NUM_CARDS + NUM_FLAG];
+#endif
+	//int offset;
+	int lastchan;
+	unsigned short ledstate;
+	unsigned char fwversion;
+};
+
+
+struct wctdm_desc {
+	char *name;
+	int flags;
+};
+
+static struct wctdm_desc wctdme = { "OpenVox A1200P", 0 };
+static int acim2tiss[16] = { 0x0, 0x1, 0x4, 0x5, 0x7, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3 };
+
+static struct wctdm *ifaces[WC_MAX_IFACES];
+
+static void wctdm_release(struct wctdm *wc);
+
+static int battdebounce = DEFAULT_BATT_DEBOUNCE;
+static int battthresh = DEFAULT_BATT_THRESH;
+static int debug = 0;
+//static int debug = 1;
+static int robust = 0;
+static int timingonly = 0;
+static int lowpower = 0;
+static int boostringer = 0;
+static int _opermode = 0;
+static char *opermode = "FCC";
+static int fxshonormode = 0;
+static int alawoverride = 0;
+static int spibyhw = 1;			// MiaoLin add;
+static int usememio = 1;
+
+static int wctdm_init_proslic(struct wctdm *wc, int card, int fast , int manual, int sane);
+
+static void wctdm_set_led(struct wctdm* wc, int card, int onoff)
+{
+	int i;
+	unsigned char c;
+	
+	wc->ledstate &= ~(0x01<<card);
+	wc->ledstate |= (onoff<<card);
+	c = (inb(wc->ioaddr + WC_AUXD)&~BIT_LED_CLK)|BIT_LED_DATA;
+	outb( c,  wc->ioaddr + WC_AUXD);
+	for(i=NUM_CARDS-1; i>=0; i--)
+	{
+		if(wc->ledstate & (0x0001<<i))
+			if(wc->fwversion == 0x11)
+				c &= ~BIT_LED_DATA;
+			else
+				c |= BIT_LED_DATA;
+		else
+			if(wc->fwversion == 0x11)
+				c |= BIT_LED_DATA;
+			else
+				c &= ~BIT_LED_DATA;
+			
+		outb( c,  wc->ioaddr + WC_AUXD);
+		outb( c|BIT_LED_CLK,  wc->ioaddr + WC_AUXD);
+		outb( (c&~BIT_LED_CLK)|BIT_LED_DATA,  wc->ioaddr + WC_AUXD);
+	}	
+}
+ 
+
+static inline void wctdm_transmitprep(struct wctdm *wc, unsigned char ints)
+{
+	int x, y, chan_offset, pos;
+	volatile unsigned char *txbuf;
+	
+	if (ints & 0x04 /*0x01*/) 
+		/* Write is at interrupt address.  Start writing from normal offset */
+		txbuf = wc->writechunk;
+	else 
+		txbuf = wc->writechunk + ZT_CHUNKSIZE * (NUM_CARDS+NUM_FLAG);
+		
+	/* Calculate Transmission */
+	zt_transmit(&wc->span);
+	
+	if(wc->lastchan == -1)	// not in sync.
+		return;
+	
+	chan_offset = (wc->lastchan*4 + 4 ) % (NUM_CARDS+NUM_FLAG);
+
+	//for (x=0;x<wc->offset;x++)
+	//	txbuf[x] = wc->tempo[x];
+	for (y=0;y<ZT_CHUNKSIZE;y++) {
+#ifdef __BIG_ENDIAN
+	// operation pending...
+#else
+		//for (x=0;x<(NUM_CARDS+NUM_FLAG);x++) {
+		//	pos = y * (NUM_CARDS+NUM_FLAG) + chanmap[(x+chan_offset)&0x0f] + wc->offset;
+		//	/* Put channel number as outgoing data */
+		//	if (pos < (NUM_CARDS+NUM_FLAG) * ZT_CHUNKSIZE)
+		//		txbuf[pos] = wc->chans[x].writechunk[y];
+		//	else
+		//		wc->tempo[pos - (NUM_CARDS+NUM_FLAG) * ZT_CHUNKSIZE] = wc->chans[x].writechunk[y];
+		//}
+		//printk("\n");
+		for (x=0;x<(NUM_CARDS+NUM_FLAG);x++) {
+			pos = y * (NUM_CARDS+NUM_FLAG) + ((x + chan_offset + NUM_CARDS+NUM_FLAG  /*+ wc->offset*/ - WC_OFFSET)&0x0f);
+			if(x<NUM_CARDS)
+				txbuf[pos] = wc->chans[x].writechunk[y]; 
+			else
+				txbuf[pos] = 0; 
+			//if(x==2)
+			//	txbuf[pos] = 0x55;//trans_count;
+			//else
+			//	txbuf[pos] = 0;
+		}
+
+		/*for (x=0;x<(NUM_CARDS+NUM_FLAG);x++) {
+			pos = y * (NUM_CARDS+NUM_FLAG) + x + chan_offset + wc->offset - WC_OFFSET;
+			if ( pos<(NUM_CARDS+NUM_FLAG)*ZT_CHUNKSIZE )
+			{	
+				if(x<NUM_CARDS)
+					txbuf[pos] = wc->chans[x].writechunk[y]; 
+				else
+					txbuf[pos] = 0; 
+			}
+			else
+			{
+				if(x<NUM_CARDS)
+					wc->tempo[pos - (NUM_CARDS+NUM_FLAG) * ZT_CHUNKSIZE] = wc->chans[x].writechunk[y]; 
+				else
+					wc->tempo[pos - (NUM_CARDS+NUM_FLAG) * ZT_CHUNKSIZE] = 0; 
+			}
+		}*/
+#endif
+	}
+
+}
+
+#ifdef AUDIO_RINGCHECK
+static inline void ring_check(struct wctdm *wc, int card)
+{
+	int x;
+	short sample;
+	if (wc->modtype[card] != MOD_TYPE_FXO)
+		return;
+	wc->mod[card].fxo.pegtimer += ZT_CHUNKSIZE;
+	for (x=0;x<ZT_CHUNKSIZE;x++) {
+		/* Look for pegging to indicate ringing */
+		sample = ZT_XLAW(wc->chans[card].readchunk[x], (&(wc->chans[card])));
+		if ((sample > 10000) && (wc->mod[card].fxo.peg != 1)) {
+			if (debug > 1) printk("High peg!\n");
+			if ((wc->mod[card].fxo.pegtimer < PEGTIME) && (wc->mod[card].fxo.pegtimer > MINPEGTIME))
+				wc->mod[card].fxo.pegcount++;
+			wc->mod[card].fxo.pegtimer = 0;
+			wc->mod[card].fxo.peg = 1;
+		} else if ((sample < -10000) && (wc->mod[card].fxo.peg != -1)) {
+			if (debug > 1) printk("Low peg!\n");
+			if ((wc->mod[card].fxo.pegtimer < (PEGTIME >> 2)) && (wc->mod[card].fxo.pegtimer > (MINPEGTIME >> 2)))
+				wc->mod[card].fxo.pegcount++;
+			wc->mod[card].fxo.pegtimer = 0;
+			wc->mod[card].fxo.peg = -1;
+		}
+	}
+	if (wc->mod[card].fxo.pegtimer > PEGTIME) {
+		/* Reset pegcount if our timer expires */
+		wc->mod[card].fxo.pegcount = 0;
+	}
+	/* Decrement debouncer if appropriate */
+	if (wc->mod[card].fxo.ringdebounce)
+		wc->mod[card].fxo.ringdebounce--;
+	if (!wc->mod[card].fxo.offhook && !wc->mod[card].fxo.ringdebounce) {
+		if (!wc->mod[card].fxo.ring && (wc->mod[card].fxo.pegcount > PEGCOUNT)) {
+			/* It's ringing */
+			if (debug)
+				printk("RING on %d/%d!\n", wc->span.spanno, card + 1);
+			if (!wc->mod[card].fxo.offhook)
+				zt_hooksig(&wc->chans[card], ZT_RXSIG_RING);
+			wc->mod[card].fxo.ring = 1;
+		}
+		if (wc->mod[card].fxo.ring && !wc->mod[card].fxo.pegcount) {
+			/* No more ring */
+			if (debug)
+				printk("NO RING on %d/%d!\n", wc->span.spanno, card + 1);
+			zt_hooksig(&wc->chans[card], ZT_RXSIG_OFFHOOK);
+			wc->mod[card].fxo.ring = 0;
+		}
+	}
+}
+#endif
+
+
+static inline void wctdm_receiveprep(struct wctdm *wc, unsigned char ints)
+{
+	volatile unsigned char *rxbuf;
+	int x, y, chan_offset;
+
+
+	if (ints & /*0x08*/0x04)
+		/* Read is at interrupt address.  Valid data is available at normal offset */
+		rxbuf = wc->readchunk;
+	else
+		rxbuf = wc->readchunk + ZT_CHUNKSIZE * (NUM_CARDS+NUM_FLAG);
+
+	//search for the flag channel
+	for(x=0; x<4; x++)
+	{
+		//printk("0x%08x ", *(int*)(rxbuf+x*4));
+		if(  *(int*)(rxbuf+x*4) == WC_SYNCFLAG)
+		{
+			//printk(" found at %d ", x);	
+			break;
+		}
+	}
+	
+	if(x==4)
+	{
+		printk("buffer sync misseed!\n");
+		wc->lastchan = -1;
+		return;
+	}
+	else if(wc->lastchan != x)
+	{
+		
+		printk("buffer re-sync occur from %d to %d\n", wc->lastchan, x);
+		wc->lastchan = x;
+	}
+	chan_offset = (wc->lastchan*4 + 4 ) % (NUM_CARDS+NUM_FLAG);
+
+	for (x=0;x<ZT_CHUNKSIZE;x++) {
+#ifdef __BIG_ENDIAN
+	// operation pending...
+#else
+		for (y=0;y<NUM_CARDS;y++) { 
+			if (wc->cardflag & (1 << y))
+				wc->chans[y].readchunk[x] = rxbuf[(NUM_CARDS+NUM_FLAG) * x + ((y + chan_offset ) & 0x0f)];
+#ifdef TEST_LOG_INCOME_VOICE
+			wc->voc_buf[y][wc->voc_ptr[y]] = rxbuf[(NUM_CARDS+NUM_FLAG) * x + ((y + chan_offset) & 0x0f)];
+			wc->voc_ptr[y]++;
+			if(wc->voc_ptr[y] >= voc_buffer_size)
+				wc->voc_ptr[y] = 0;
+#endif		
+		}
+
+#endif
+	}
+#ifdef AUDIO_RINGCHECK
+	for (x=0;x<wc->cards;x++)
+		ring_check(wc, x);
+#endif		
+	/* XXX We're wasting 8 taps.  We should get closer :( */
+	for (x = 0; x < NUM_CARDS; x++) {
+		if (wc->cardflag & (1 << x))
+			zt_ec_chunk(&wc->chans[x], wc->chans[x].readchunk, wc->chans[x].writechunk);
+	}
+	zt_receive(&wc->span);
+}
+
+static void wctdm_stop_dma(struct wctdm *wc);
+static void wctdm_reset_tdm(struct wctdm *wc);
+static void wctdm_restart_dma(struct wctdm *wc);
+
+
+static unsigned char __wctdm_getcreg(struct wctdm *wc, unsigned char reg);
+static void __wctdm_setcreg(struct wctdm *wc, unsigned char reg, unsigned char val);
+
+
+static inline void __write_8bits(struct wctdm *wc, unsigned char bits)
+{
+	if(spibyhw == 0)
+	{
+		int x;
+		/* Drop chip select */
+		wc->ios |= BIT_SCLK;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+		wc->ios &= ~BIT_CS;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+		for (x=0;x<8;x++) {
+			/* Send out each bit, MSB first, drop SCLK as we do so */
+			if (bits & 0x80)
+				wc->ios |= BIT_SDI;
+			else
+				wc->ios &= ~BIT_SDI;
+			wc->ios &= ~BIT_SCLK;
+			outb(wc->ios, wc->ioaddr + WC_AUXD);
+			/* Now raise SCLK high again and repeat */
+			wc->ios |= BIT_SCLK;
+			outb(wc->ios, wc->ioaddr + WC_AUXD);
+			bits <<= 1;
+		}
+		/* Finally raise CS back high again */
+		wc->ios |= BIT_CS;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+	}
+	else
+	{
+		__wctdm_setcreg(wc, WC_SPIDATA, bits);
+		__wctdm_setcreg(wc, WC_SPICTRL, BIT_SPI_BYHW | BIT_SPI_START);
+		while ((__wctdm_getcreg(wc, WC_SPICTRL) & BIT_SPI_BUSY) != 0);
+		__wctdm_setcreg(wc, WC_SPICTRL, BIT_SPI_BYHW);
+	}
+}
+
+
+static inline void __reset_spi(struct wctdm *wc)
+{
+	__wctdm_setcreg(wc, WC_SPICTRL, 0);
+	
+	/* Drop chip select and clock once and raise and clock once */
+	wc->ios |= BIT_SCLK;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	wc->ios &= ~BIT_CS;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	wc->ios |= BIT_SDI;
+	wc->ios &= ~BIT_SCLK;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	/* Now raise SCLK high again and repeat */
+	wc->ios |= BIT_SCLK;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	/* Finally raise CS back high again */
+	wc->ios |= BIT_CS;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	/* Clock again */
+	wc->ios &= ~BIT_SCLK;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	/* Now raise SCLK high again and repeat */
+	wc->ios |= BIT_SCLK;
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+	
+	__wctdm_setcreg(wc, WC_SPICTRL, spibyhw);
+
+}
+
+static inline unsigned char __read_8bits(struct wctdm *wc)
+{
+	unsigned char res=0, c;
+	int x;
+	if(spibyhw == 0)
+	{
+		wc->ios &= ~BIT_CS;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+		/* Drop chip select */
+		wc->ios &= ~BIT_CS;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+		for (x=0;x<8;x++) {
+			res <<= 1;
+			/* Get SCLK */
+			wc->ios &= ~BIT_SCLK;
+			outb(wc->ios, wc->ioaddr + WC_AUXD);
+			/* Read back the value */
+			c = inb(wc->ioaddr + WC_AUXR);
+			if (c & BIT_SDO)
+				res |= 1;
+			/* Now raise SCLK high again */
+			wc->ios |= BIT_SCLK;
+			outb(wc->ios, wc->ioaddr + WC_AUXD);
+		}
+		/* Finally raise CS back high again */
+		wc->ios |= BIT_CS;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+		wc->ios &= ~BIT_SCLK;
+		outb(wc->ios, wc->ioaddr + WC_AUXD);
+	}
+	else
+	{
+		__wctdm_setcreg(wc, WC_SPICTRL, BIT_SPI_BYHW | BIT_SPI_START);
+		while ((__wctdm_getcreg(wc, WC_SPICTRL) & BIT_SPI_BUSY) != 0);
+		res = __wctdm_getcreg(wc, WC_SPIDATA);
+		__wctdm_setcreg(wc, WC_SPICTRL, BIT_SPI_BYHW);
+	}
+	
+	/* And return our result */
+	return res;
+}
+
+static void __wctdm_setcreg_mem(struct wctdm *wc, unsigned char reg, unsigned char val)
+{
+	unsigned int *p = (unsigned int*)(wc->mem32 + WC_REGBASE + ((reg & 0xf) << 2));
+	*p = val;
+}
+
+static unsigned char __wctdm_getcreg_mem(struct wctdm *wc, unsigned char reg)
+{
+	unsigned int *p = (unsigned int*)(wc->mem32 + WC_REGBASE + ((reg & 0xf) << 2));
+	return (*p)&0x00ff;
+}
+
+
+static void __wctdm_setcreg(struct wctdm *wc, unsigned char reg, unsigned char val)
+{
+	if(usememio)
+		__wctdm_setcreg_mem(wc, reg, val);
+	else
+		outb(val, wc->ioaddr + WC_REGBASE + ((reg & 0xf) << 2));
+}
+
+static unsigned char __wctdm_getcreg(struct wctdm *wc, unsigned char reg)
+{
+	if(usememio)
+		return __wctdm_getcreg_mem(wc, reg);
+	else
+		return inb(wc->ioaddr + WC_REGBASE + ((reg & 0xf) << 2));
+}
+
+static inline void __wctdm_setcard(struct wctdm *wc, int card)
+{
+	if (wc->curcard != card) {
+		__wctdm_setcreg(wc, WC_CS, card);
+		wc->curcard = card;
+		//printk("Select card %d\n", card);
+	}
+}
+
+static void __wctdm_setreg(struct wctdm *wc, int card, unsigned char reg, unsigned char value)
+{
+	__wctdm_setcard(wc, card);
+	if (wc->modtype[card] == MOD_TYPE_FXO) {
+		__write_8bits(wc, 0x20);
+		__write_8bits(wc, reg & 0x7f);
+	} else {
+		__write_8bits(wc, reg & 0x7f);
+	}
+	__write_8bits(wc, value);
+}
+
+static void wctdm_setreg(struct wctdm *wc, int card, unsigned char reg, unsigned char value)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&wc->lock, flags);
+	__wctdm_setreg(wc, card, reg, value);
+	spin_unlock_irqrestore(&wc->lock, flags);
+}
+
+static unsigned char __wctdm_getreg(struct wctdm *wc, int card, unsigned char reg)
+{
+	__wctdm_setcard(wc, card);
+	if (wc->modtype[card] == MOD_TYPE_FXO) {
+		__write_8bits(wc, 0x60);
+		__write_8bits(wc, reg & 0x7f);
+	} else {
+		__write_8bits(wc, reg | 0x80);
+	}
+	return __read_8bits(wc);
+}
+
+static inline void reset_spi(struct wctdm *wc, int card)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&wc->lock, flags);
+	__wctdm_setcard(wc, card);
+	__reset_spi(wc);
+	__reset_spi(wc);
+	spin_unlock_irqrestore(&wc->lock, flags);
+}
+
+static unsigned char wctdm_getreg(struct wctdm *wc, int card, unsigned char reg)
+{
+	unsigned long flags;
+	unsigned char res;
+	spin_lock_irqsave(&wc->lock, flags);
+	res = __wctdm_getreg(wc, card, reg);
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return res;
+}
+
+static int __wait_access(struct wctdm *wc, int card)
+{
+    unsigned char data = 0;
+    long origjiffies;
+    int count = 0;
+
+    #define MAX 6000 /* attempts */
+
+
+    origjiffies = jiffies;
+    /* Wait for indirect access */
+    while (count++ < MAX)
+	 {
+		data = __wctdm_getreg(wc, card, I_STATUS);
+
+		if (!data)
+			return 0;
+
+	 }
+
+    if(count > (MAX-1)) printk(" ##### Loop error (%02x) #####\n", data);
+
+	return 0;
+}
+
+static unsigned char translate_3215(unsigned char address)
+{
+	int x;
+	for (x=0;x<sizeof(indirect_regs)/sizeof(indirect_regs[0]);x++) {
+		if (indirect_regs[x].address == address) {
+			address = indirect_regs[x].altaddr;
+			break;
+		}
+	}
+	return address;
+}
+
+static int wctdm_proslic_setreg_indirect(struct wctdm *wc, int card, unsigned char address, unsigned short data)
+{
+	unsigned long flags;
+	int res = -1;
+	/* Translate 3215 addresses */
+	if (wc->flags[card] & FLAG_3215) {
+		address = translate_3215(address);
+		if (address == 255)
+			return 0;
+	}
+	spin_lock_irqsave(&wc->lock, flags);
+	if(!__wait_access(wc, card)) {
+		__wctdm_setreg(wc, card, IDA_LO,(unsigned char)(data & 0xFF));
+		__wctdm_setreg(wc, card, IDA_HI,(unsigned char)((data & 0xFF00)>>8));
+		__wctdm_setreg(wc, card, IAA,address);
+		res = 0;
+	};
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return res;
+}
+
+static int wctdm_proslic_getreg_indirect(struct wctdm *wc, int card, unsigned char address)
+{ 
+	unsigned long flags;
+	int res = -1;
+	char *p=NULL;
+	/* Translate 3215 addresses */
+	if (wc->flags[card] & FLAG_3215) {
+		address = translate_3215(address);
+		if (address == 255)
+			return 0;
+	}
+	spin_lock_irqsave(&wc->lock, flags);
+	if (!__wait_access(wc, card)) {
+		__wctdm_setreg(wc, card, IAA, address);
+		if (!__wait_access(wc, card)) {
+			unsigned char data1, data2;
+			data1 = __wctdm_getreg(wc, card, IDA_LO);
+			data2 = __wctdm_getreg(wc, card, IDA_HI);
+			res = data1 | (data2 << 8);
+		} else
+			p = "Failed to wait inside\n";
+	} else
+		p = "failed to wait\n";
+	spin_unlock_irqrestore(&wc->lock, flags);
+	if (p)
+		printk(p);
+	return res;
+}
+
+static int wctdm_proslic_init_indirect_regs(struct wctdm *wc, int card)
+{
+	unsigned char i;
+
+	for (i=0; i<sizeof(indirect_regs) / sizeof(indirect_regs[0]); i++)
+	{
+		if(wctdm_proslic_setreg_indirect(wc, card, indirect_regs[i].address,indirect_regs[i].initial))
+			return -1;
+	}
+
+	return 0;
+}
+
+static int wctdm_proslic_verify_indirect_regs(struct wctdm *wc, int card)
+{ 
+	int passed = 1;
+	unsigned short i, initial;
+	int j;
+
+	for (i=0; i<sizeof(indirect_regs) / sizeof(indirect_regs[0]); i++) 
+	{
+		if((j = wctdm_proslic_getreg_indirect(wc, card, (unsigned char) indirect_regs[i].address)) < 0) {
+			printk("Failed to read indirect register %d\n", i);
+			return -1;
+		}
+		initial= indirect_regs[i].initial;
+
+		if ( j != initial && (!(wc->flags[card] & FLAG_3215) || (indirect_regs[i].altaddr != 255)))
+		{
+			 printk("!!!!!!! %s  iREG %X = %X  should be %X\n",
+				indirect_regs[i].name,indirect_regs[i].address,j,initial );
+			 passed = 0;
+		}	
+	}
+
+    if (passed) {
+		if (debug)
+			printk("Init Indirect Registers completed successfully.\n");
+    } else {
+		printk(" !!!!! Init Indirect Registers UNSUCCESSFULLY.\n");
+		return -1;
+    }
+    return 0;
+}
+
+static inline void wctdm_proslic_recheck_sanity(struct wctdm *wc, int card)
+{
+	int res;
+	/* Check loopback */
+	res = wc->reg1shadow[card];
+	if (!res && (res != wc->mod[card].fxs.lasttxhook)) {
+		res = wctdm_getreg(wc, card, 8);
+		if (res) {
+			printk("Ouch, part reset, quickly restoring reality (%d)\n", card);
+			wctdm_init_proslic(wc, card, 1, 0, 1);
+		} else {
+			if (wc->mod[card].fxs.palarms++ < MAX_ALARMS) {
+				printk("Power alarm on module %d, resetting!\n", card + 1);
+				if (wc->mod[card].fxs.lasttxhook == 4)
+					wc->mod[card].fxs.lasttxhook = 1;
+				wctdm_setreg(wc, card, 64, wc->mod[card].fxs.lasttxhook);
+			} else {
+				if (wc->mod[card].fxs.palarms == MAX_ALARMS)
+					printk("Too many power alarms on card %d, NOT resetting!\n", card + 1);
+			}
+		}
+	}
+}
+
+static inline void wctdm_voicedaa_check_hook(struct wctdm *wc, int card)
+{
+#ifndef AUDIO_RINGCHECK
+	unsigned char res;
+#endif	
+	signed char b;
+	int poopy = 0;
+	/* Try to track issues that plague slot one FXO's */
+	b = wc->reg0shadow[card];
+	if ((b & 0x2) || !(b & 0x8)) {
+		/* Not good -- don't look at anything else */
+		if (debug)
+			printk("Poopy (%02x) on card %d!\n", b, card + 1); 
+		poopy++;
+	}
+	b &= 0x9b;
+	if (wc->mod[card].fxo.offhook) {
+		if (b != 0x9)
+			wctdm_setreg(wc, card, 5, 0x9);
+	} else {
+		if (b != 0x8)
+			wctdm_setreg(wc, card, 5, 0x8);
+	}
+	if (poopy)
+		return;
+#ifndef AUDIO_RINGCHECK
+	if (!wc->mod[card].fxo.offhook) {
+		res = wc->reg0shadow[card];
+		if ((res & 0x60) && wc->mod[card].fxo.battery) {
+			wc->mod[card].fxo.ringdebounce += (ZT_CHUNKSIZE * 16);
+			if (wc->mod[card].fxo.ringdebounce >= ZT_CHUNKSIZE * 64) {
+				if (!wc->mod[card].fxo.wasringing) {
+					wc->mod[card].fxo.wasringing = 1;
+					zt_hooksig(&wc->chans[card], ZT_RXSIG_RING);
+					if (debug)
+						printk("RING on %d/%d!\n", wc->span.spanno, card + 1);
+				}
+				wc->mod[card].fxo.ringdebounce = ZT_CHUNKSIZE * 64;
+			}
+		} else {
+			wc->mod[card].fxo.ringdebounce -= ZT_CHUNKSIZE * 4;
+			if (wc->mod[card].fxo.ringdebounce <= 0) {
+				if (wc->mod[card].fxo.wasringing) {
+					wc->mod[card].fxo.wasringing = 0;
+					zt_hooksig(&wc->chans[card], ZT_RXSIG_OFFHOOK);
+					if (debug)
+						printk("NO RING on %d/%d!\n", wc->span.spanno, card + 1);
+				}
+				wc->mod[card].fxo.ringdebounce = 0;
+			}
+				
+		}
+	}
+#endif
+	b = wc->reg1shadow[card];
+#if 0 
+	{
+		static int count = 0;
+		if (!(count++ % 100)) {
+			printk("Card %d: Voltage: %d  Debounce %d\n", card + 1, 
+			       b, wc->mod[card].fxo.battdebounce);
+		}
+	}
+#endif	
+	if (abs(b) < battthresh) {
+		wc->mod[card].fxo.nobatttimer++;
+#if 0
+		if (wc->mod[card].fxo.battery)
+			printk("Battery loss: %d (%d debounce)\n", b, wc->mod[card].fxo.battdebounce);
+#endif
+		if (wc->mod[card].fxo.battery && !wc->mod[card].fxo.battdebounce) {
+			if (debug)
+				printk("NO BATTERY on %d/%d!\n", wc->span.spanno, card + 1);
+			wc->mod[card].fxo.battery =  0;
+#ifdef	JAPAN
+			if ((!wc->ohdebounce) && wc->offhook) {
+				zt_hooksig(&wc->chans[card], ZT_RXSIG_ONHOOK);
+				if (debug)
+					printk("Signalled On Hook\n");
+#ifdef	ZERO_BATT_RING
+				wc->onhook++;
+#endif
+			}
+#else
+			zt_hooksig(&wc->chans[card], ZT_RXSIG_ONHOOK);
+#endif
+			wc->mod[card].fxo.battdebounce = battdebounce;
+		} else if (!wc->mod[card].fxo.battery)
+			wc->mod[card].fxo.battdebounce = battdebounce;
+	} else if (abs(b) > battthresh) {
+		if (!wc->mod[card].fxo.battery && !wc->mod[card].fxo.battdebounce) {
+			if (debug)
+				printk("BATTERY on %d/%d (%s)!\n", wc->span.spanno, card + 1, 
+					(b < 0) ? "-" : "+");			    
+#ifdef	ZERO_BATT_RING
+			if (wc->onhook) {
+				wc->onhook = 0;
+				zt_hooksig(&wc->chans[card], ZT_RXSIG_OFFHOOK);
+				if (debug)
+					printk("Signalled Off Hook\n");
+			}
+#else
+			zt_hooksig(&wc->chans[card], ZT_RXSIG_OFFHOOK);
+#endif
+			wc->mod[card].fxo.battery = 1;
+			wc->mod[card].fxo.nobatttimer = 0;
+			wc->mod[card].fxo.battdebounce = battdebounce;
+		} else if (wc->mod[card].fxo.battery)
+			wc->mod[card].fxo.battdebounce = battdebounce;
+
+		if (wc->mod[card].fxo.lastpol >= 0) {
+		    if (b < 0) {
+			wc->mod[card].fxo.lastpol = -1;
+			wc->mod[card].fxo.polaritydebounce = POLARITY_DEBOUNCE;
+		    }
+		} 
+		if (wc->mod[card].fxo.lastpol <= 0) {
+		    if (b > 0) {
+			wc->mod[card].fxo.lastpol = 1;
+			wc->mod[card].fxo.polaritydebounce = POLARITY_DEBOUNCE;
+		    }
+		}
+	} else {
+		/* It's something else... */
+		wc->mod[card].fxo.battdebounce = battdebounce;
+	}
+	if (wc->mod[card].fxo.battdebounce)
+		wc->mod[card].fxo.battdebounce--;
+	if (wc->mod[card].fxo.polaritydebounce) {
+	        wc->mod[card].fxo.polaritydebounce--;
+		if (wc->mod[card].fxo.polaritydebounce < 1) {
+		    if (wc->mod[card].fxo.lastpol != wc->mod[card].fxo.polarity) {
+				if (debug)
+					printk("%lu Polarity reversed (%d -> %d)\n", jiffies, 
+				       wc->mod[card].fxo.polarity, 
+				       wc->mod[card].fxo.lastpol);
+				if (wc->mod[card].fxo.polarity)
+				    zt_qevent_lock(&wc->chans[card], ZT_EVENT_POLARITY);
+				wc->mod[card].fxo.polarity = wc->mod[card].fxo.lastpol;
+		    }
+		}
+	}
+}
+
+static inline void wctdm_proslic_check_hook(struct wctdm *wc, int card)
+{
+	char res;
+	int hook;
+
+	/* For some reason we have to debounce the
+	   hook detector.  */
+
+	res = wc->reg0shadow[card];
+	hook = (res & 1);
+	if (hook != wc->mod[card].fxs.lastrxhook) {
+		/* Reset the debounce (must be multiple of 4ms) */
+		wc->mod[card].fxs.debounce = 8 * (4 * 8);
+#if 0
+		printk("Resetting debounce card %d hook %d, %d\n", card, hook, wc->mod[card].fxs.debounce);
+#endif
+	} else {
+		if (wc->mod[card].fxs.debounce > 0) {
+			wc->mod[card].fxs.debounce-= 16 * ZT_CHUNKSIZE;
+#if 0
+			printk("Sustaining hook %d, %d\n", hook, wc->mod[card].fxs.debounce);
+#endif
+			if (!wc->mod[card].fxs.debounce) {
+#if 0
+				printk("Counted down debounce, newhook: %d...\n", hook);
+#endif
+				wc->mod[card].fxs.debouncehook = hook;
+			}
+			if (!wc->mod[card].fxs.oldrxhook && wc->mod[card].fxs.debouncehook) {
+				/* Off hook */
+#if 1
+				if (debug)
+#endif				
+					printk("opvxa1200: Card %d Going off hook\n", card);
+				zt_hooksig(&wc->chans[card], ZT_RXSIG_OFFHOOK);
+				if (robust)
+					wctdm_init_proslic(wc, card, 1, 0, 1);
+				wc->mod[card].fxs.oldrxhook = 1;
+			
+			} else if (wc->mod[card].fxs.oldrxhook && !wc->mod[card].fxs.debouncehook) {
+				/* On hook */
+#if 1
+				if (debug)
+#endif				
+					printk("opvxa1200: Card %d Going on hook\n", card);
+				zt_hooksig(&wc->chans[card], ZT_RXSIG_ONHOOK);
+				wc->mod[card].fxs.oldrxhook = 0;
+			}
+		}
+	}
+	wc->mod[card].fxs.lastrxhook = hook;
+}
+
+ZAP_IRQ_HANDLER(wctdm_interrupt)
+{
+	struct wctdm *wc = dev_id;
+	unsigned char ints;
+	int x, y, z;
+	int mode;
+
+	ints = inb(wc->ioaddr + WC_INTSTAT);
+	outb(ints, wc->ioaddr + WC_INTSTAT);
+
+	if (!ints)
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+
+	if (ints & 0x10) {
+		/* Stop DMA, wait for watchdog */
+		printk("TDM PCI Master abort\n");
+		wctdm_stop_dma(wc);
+#ifdef LINUX26
+		return IRQ_RETVAL(1);
+#else
+		return;
+#endif		
+	}
+	
+	if (ints & 0x20) {
+		printk("PCI Target abort\n");
+#ifdef LINUX26
+		return IRQ_RETVAL(1);
+#else
+		return;
+#endif		
+	}
+
+	for (x=0;x<4*3;x++) {
+		if (wc->cardflag & (1 << x) &&
+		    (wc->modtype[x] == MOD_TYPE_FXS)) {
+			if (wc->mod[x].fxs.lasttxhook == 0x4) {
+				/* RINGing, prepare for OHT */
+				wc->mod[x].fxs.ohttimer = OHT_TIMER << 3;
+				if (reversepolarity)
+					wc->mod[x].fxs.idletxhookstate = 0x6;	/* OHT mode when idle */
+				else
+					wc->mod[x].fxs.idletxhookstate = 0x2; 
+			} else {
+				if (wc->mod[x].fxs.ohttimer) {
+					wc->mod[x].fxs.ohttimer-= ZT_CHUNKSIZE;
+					if (!wc->mod[x].fxs.ohttimer) {
+						if (reversepolarity)
+							wc->mod[x].fxs.idletxhookstate = 0x5;	/* Switch to active */
+						else
+							wc->mod[x].fxs.idletxhookstate = 0x1;
+						if ((wc->mod[x].fxs.lasttxhook == 0x2) || (wc->mod[x].fxs.lasttxhook = 0x6)) {
+							/* Apply the change if appropriate */
+							if (reversepolarity) 
+								wc->mod[x].fxs.lasttxhook = 0x5;
+							else
+								wc->mod[x].fxs.lasttxhook = 0x1;
+							wctdm_setreg(wc, x, 64, wc->mod[x].fxs.lasttxhook);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (ints & 0x0f) {
+		wc->intcount++;
+		z = wc->intcount & 0x3;
+		mode = wc->intcount & 0xc;
+		for(y=0; y<3; y++)
+		{
+			x = z + y*4;
+			if (wc->cardflag & (1 << x ) ) 
+			{
+				switch(mode) 
+				{
+				case 0:
+					/* Rest */
+					break;
+				case 4:
+					/* Read first shadow reg */
+					if (wc->modtype[x] == MOD_TYPE_FXS)
+						wc->reg0shadow[x] = wctdm_getreg(wc, x, 68);
+					else if (wc->modtype[x] == MOD_TYPE_FXO)
+						wc->reg0shadow[x] = wctdm_getreg(wc, x, 5);
+					break;
+				case 8:
+					/* Read second shadow reg */
+					if (wc->modtype[x] == MOD_TYPE_FXS)
+						wc->reg1shadow[x] = wctdm_getreg(wc, x, 64);
+					else if (wc->modtype[x] == MOD_TYPE_FXO)
+						wc->reg1shadow[x] = wctdm_getreg(wc, x, 29);
+					break;
+				case 12:
+					/* Perform processing */
+					if (wc->modtype[x] == MOD_TYPE_FXS) {
+						wctdm_proslic_check_hook(wc, x);
+						if (!(wc->intcount & 0xf0))
+							wctdm_proslic_recheck_sanity(wc, x);
+						} else if (wc->modtype[x] == MOD_TYPE_FXO) {
+						wctdm_voicedaa_check_hook(wc, x);
+					}
+					break;
+				}
+			}
+		}
+		if (!(wc->intcount % 10000)) {
+			/* Accept an alarm once per 10 seconds */
+			for (x=0;x<4*3;x++) 
+				if (wc->modtype[x] == MOD_TYPE_FXS) {
+					if (wc->mod[x].fxs.palarms)
+						wc->mod[x].fxs.palarms--;
+				}
+		}
+		wctdm_receiveprep(wc, ints);
+		wctdm_transmitprep(wc, ints);
+	}
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+	
+}
+
+static int wctdm_voicedaa_insane(struct wctdm *wc, int card)
+{
+	int blah;
+	blah = wctdm_getreg(wc, card, 2);
+	if (blah != 0x3)
+		return -2;
+	blah = wctdm_getreg(wc, card, 11);
+	if (debug)
+		printk("VoiceDAA System: %02x\n", blah & 0xf);
+	return 0;
+}
+
+static int wctdm_proslic_insane(struct wctdm *wc, int card)
+{
+	int blah,insane_report;
+	insane_report=0;
+
+	blah = wctdm_getreg(wc, card, 0);
+	if (debug) 
+		printk("ProSLIC on module %d, product %d, version %d\n", card, (blah & 0x30) >> 4, (blah & 0xf));
+
+#if 0
+	if ((blah & 0x30) >> 4) {
+		printk("ProSLIC on module %d is not a 3210.\n", card);
+		return -1;
+	}
+#endif
+	if (((blah & 0xf) == 0) || ((blah & 0xf) == 0xf)) {
+		/* SLIC not loaded */
+		return -1;
+	}
+	if ((blah & 0xf) < 2) {
+		printk("ProSLIC 3210 version %d is too old\n", blah & 0xf);
+		return -1;
+	}
+	if ((blah & 0xf) == 2) {
+		/* ProSLIC 3215, not a 3210 */
+		wc->flags[card] |= FLAG_3215;
+	}
+	blah = wctdm_getreg(wc, card, 8);
+	if (blah != 0x2) {
+		printk("ProSLIC on module %d insane (1) %d should be 2\n", card, blah);
+		return -1;
+	} else if ( insane_report)
+		printk("ProSLIC on module %d Reg 8 Reads %d Expected is 0x2\n",card,blah);
+
+	blah = wctdm_getreg(wc, card, 64);
+	if (blah != 0x0) {
+		printk("ProSLIC on module %d insane (2)\n", card);
+		return -1;
+	} else if ( insane_report)
+		printk("ProSLIC on module %d Reg 64 Reads %d Expected is 0x0\n",card,blah);
+
+	blah = wctdm_getreg(wc, card, 11);
+	if (blah != 0x33) {
+		printk("ProSLIC on module %d insane (3)\n", card);
+		return -1;
+	} else if ( insane_report)
+		printk("ProSLIC on module %d Reg 11 Reads %d Expected is 0x33\n",card,blah);
+
+	/* Just be sure it's setup right. */
+	wctdm_setreg(wc, card, 30, 0);
+
+	if (debug) 
+		printk("ProSLIC on module %d seems sane.\n", card);
+	return 0;
+}
+
+static int wctdm_proslic_powerleak_test(struct wctdm *wc, int card)
+{
+	unsigned long origjiffies;
+	unsigned char vbat;
+
+	/* Turn off linefeed */
+	wctdm_setreg(wc, card, 64, 0);
+
+	/* Power down */
+	wctdm_setreg(wc, card, 14, 0x10);
+
+	/* Wait for one second */
+	origjiffies = jiffies;
+
+	while((vbat = wctdm_getreg(wc, card, 82)) > 0x6) {
+		if ((jiffies - origjiffies) >= (HZ/2))
+			break;;
+	}
+
+	if (vbat < 0x06) {
+		printk("Excessive leakage detected on module %d: %d volts (%02x) after %d ms\n", card,
+		       376 * vbat / 1000, vbat, (int)((jiffies - origjiffies) * 1000 / HZ));
+		return -1;
+	} else if (debug) {
+		printk("Post-leakage voltage: %d volts\n", 376 * vbat / 1000);
+	}
+	return 0;
+}
+
+static int wctdm_powerup_proslic(struct wctdm *wc, int card, int fast)
+{
+	unsigned char vbat;
+	unsigned long origjiffies;
+	int lim;
+
+	/* Set period of DC-DC converter to 1/64 khz */
+	wctdm_setreg(wc, card, 92, 0xff /* was 0xff */);
+
+	/* Wait for VBat to powerup */
+	origjiffies = jiffies;
+
+	/* Disable powerdown */
+	wctdm_setreg(wc, card, 14, 0);
+
+	/* If fast, don't bother checking anymore */
+	if (fast)
+		return 0;
+
+	while((vbat = wctdm_getreg(wc, card, 82)) < 0xc0) {
+		/* Wait no more than 500ms */
+		if ((jiffies - origjiffies) > HZ/2) {
+			break;
+		}
+	}
+
+	if (vbat < 0xc0) {
+		if (wc->proslic_power == PROSLIC_POWER_UNKNOWN)
+				 printk("ProSLIC on module %d failed to powerup within %d ms (%d mV only)\n\n -- DID YOU REMEMBER TO PLUG IN THE HD POWER CABLE TO THE A1200P??\n",
+					card, (int)(((jiffies - origjiffies) * 1000 / HZ)),
+					vbat * 375);
+		wc->proslic_power = PROSLIC_POWER_WARNED;
+		return -1;
+	} else if (debug) {
+		printk("ProSLIC on module %d powered up to -%d volts (%02x) in %d ms\n",
+		       card, vbat * 376 / 1000, vbat, (int)(((jiffies - origjiffies) * 1000 / HZ)));
+	}
+	wc->proslic_power = PROSLIC_POWER_ON;
+
+        /* Proslic max allowed loop current, reg 71 LOOP_I_LIMIT */
+        /* If out of range, just set it to the default value     */
+        lim = (loopcurrent - 20) / 3;
+        if ( loopcurrent > 41 ) {
+                lim = 0;
+                if (debug)
+                        printk("Loop current out of range! Setting to default 20mA!\n");
+        }
+        else if (debug)
+                        printk("Loop current set to %dmA!\n",(lim*3)+20);
+        wctdm_setreg(wc,card,LOOP_I_LIMIT,lim);
+
+	/* Engage DC-DC converter */
+	wctdm_setreg(wc, card, 93, 0x19 /* was 0x19 */);
+#if 0
+	origjiffies = jiffies;
+	while(0x80 & wctdm_getreg(wc, card, 93)) {
+		if ((jiffies - origjiffies) > 2 * HZ) {
+			printk("Timeout waiting for DC-DC calibration on module %d\n", card);
+			return -1;
+		}
+	}
+
+#if 0
+	/* Wait a full two seconds */
+	while((jiffies - origjiffies) < 2 * HZ);
+
+	/* Just check to be sure */
+	vbat = wctdm_getreg(wc, card, 82);
+	printk("ProSLIC on module %d powered up to -%d volts (%02x) in %d ms\n",
+		       card, vbat * 376 / 1000, vbat, (int)(((jiffies - origjiffies) * 1000 / HZ)));
+#endif
+#endif
+	return 0;
+
+}
+
+static int wctdm_proslic_manual_calibrate(struct wctdm *wc, int card){
+	unsigned long origjiffies;
+	unsigned char i;
+
+	wctdm_setreg(wc, card, 21, 0);//(0)  Disable all interupts in DR21
+	wctdm_setreg(wc, card, 22, 0);//(0)Disable all interupts in DR21
+	wctdm_setreg(wc, card, 23, 0);//(0)Disable all interupts in DR21
+	wctdm_setreg(wc, card, 64, 0);//(0)
+
+	wctdm_setreg(wc, card, 97, 0x18); //(0x18)Calibrations without the ADC and DAC offset and without common mode calibration.
+	wctdm_setreg(wc, card, 96, 0x47); //(0x47)	Calibrate common mode and differential DAC mode DAC + ILIM
+
+	origjiffies=jiffies;
+	while( wctdm_getreg(wc,card,96)!=0 ){
+		if((jiffies-origjiffies)>80)
+			return -1;
+	}
+//Initialized DR 98 and 99 to get consistant results.
+// 98 and 99 are the results registers and the search should have same intial conditions.
+
+/*******************************The following is the manual gain mismatch calibration****************************/
+/*******************************This is also available as a function *******************************************/
+	// Delay 10ms
+	origjiffies=jiffies; 
+	while((jiffies-origjiffies)<1);
+	wctdm_proslic_setreg_indirect(wc, card, 88,0);
+	wctdm_proslic_setreg_indirect(wc,card,89,0);
+	wctdm_proslic_setreg_indirect(wc,card,90,0);
+	wctdm_proslic_setreg_indirect(wc,card,91,0);
+	wctdm_proslic_setreg_indirect(wc,card,92,0);
+	wctdm_proslic_setreg_indirect(wc,card,93,0);
+
+	wctdm_setreg(wc, card, 98,0x10); // This is necessary if the calibration occurs other than at reset time
+	wctdm_setreg(wc, card, 99,0x10);
+
+	for ( i=0x1f; i>0; i--)
+	{
+		wctdm_setreg(wc, card, 98,i);
+		origjiffies=jiffies; 
+		while((jiffies-origjiffies)<4);
+		if((wctdm_getreg(wc,card,88)) == 0)
+			break;
+	} // for
+
+	for ( i=0x1f; i>0; i--)
+	{
+		wctdm_setreg(wc, card, 99,i);
+		origjiffies=jiffies; 
+		while((jiffies-origjiffies)<4);
+		if((wctdm_getreg(wc,card,89)) == 0)
+			break;
+	}//for
+
+/*******************************The preceding is the manual gain mismatch calibration****************************/
+/**********************************The following is the longitudinal Balance Cal***********************************/
+	wctdm_setreg(wc,card,64,1);
+	while((jiffies-origjiffies)<10); // Sleep 100?
+
+	wctdm_setreg(wc, card, 64, 0);
+	wctdm_setreg(wc, card, 23, 0x4);  // enable interrupt for the balance Cal
+	wctdm_setreg(wc, card, 97, 0x1); // this is a singular calibration bit for longitudinal calibration
+	wctdm_setreg(wc, card, 96,0x40);
+
+	wctdm_getreg(wc,card,96); /* Read Reg 96 just cause */
+
+	wctdm_setreg(wc, card, 21, 0xFF);
+	wctdm_setreg(wc, card, 22, 0xFF);
+	wctdm_setreg(wc, card, 23, 0xFF);
+
+	/**The preceding is the longitudinal Balance Cal***/
+	return(0);
+
+}
+#if 1
+static int wctdm_proslic_calibrate(struct wctdm *wc, int card)
+{
+	unsigned long origjiffies;
+	int x;
+	/* Perform all calibrations */
+	wctdm_setreg(wc, card, 97, 0x1f);
+	
+	/* Begin, no speedup */
+	wctdm_setreg(wc, card, 96, 0x5f);
+
+	/* Wait for it to finish */
+	origjiffies = jiffies;
+	while(wctdm_getreg(wc, card, 96)) {
+		if ((jiffies - origjiffies) > 2 * HZ) {
+			printk("Timeout waiting for calibration of module %d\n", card);
+			return -1;
+		}
+	}
+	
+	if (debug) {
+		/* Print calibration parameters */
+		printk("Calibration Vector Regs 98 - 107: \n");
+		for (x=98;x<108;x++) {
+			printk("%d: %02x\n", x, wctdm_getreg(wc, card, x));
+		}
+	}
+	return 0;
+}
+#endif
+
+static void wait_just_a_bit(int foo)
+{
+	long newjiffies;
+	newjiffies = jiffies + foo;
+	while(jiffies < newjiffies);
+}
+
+static int wctdm_init_voicedaa(struct wctdm *wc, int card, int fast, int manual, int sane)
+{
+	unsigned char reg16=0, reg26=0, reg30=0, reg31=0;
+	long newjiffies;
+	wc->modtype[card] = MOD_TYPE_FXO;
+	
+	/* Sanity check the ProSLIC */
+	reset_spi(wc, card);
+	if (!sane && wctdm_voicedaa_insane(wc, card))
+		return -2;
+
+	/* Software reset */
+	wctdm_setreg(wc, card, 1, 0x80);
+
+	/* Wait just a bit */
+	wait_just_a_bit(HZ/10);
+
+	/* Enable PCM, ulaw */
+	if (alawoverride)
+		wctdm_setreg(wc, card, 33, 0x20);
+	else
+		wctdm_setreg(wc, card, 33, 0x28);
+
+	/* Set On-hook speed, Ringer impedence, and ringer threshold */
+	reg16 |= (fxo_modes[_opermode].ohs << 6);
+	reg16 |= (fxo_modes[_opermode].rz << 1);
+	reg16 |= (fxo_modes[_opermode].rt);
+	wctdm_setreg(wc, card, 16, reg16);
+	
+	/* Set DC Termination:
+	   Tip/Ring voltage adjust, minimum operational current, current limitation */
+	reg26 |= (fxo_modes[_opermode].dcv << 6);
+	reg26 |= (fxo_modes[_opermode].mini << 4);
+	reg26 |= (fxo_modes[_opermode].ilim << 1);
+	wctdm_setreg(wc, card, 26, reg26);
+
+	/* Set AC Impedence */
+	reg30 = (fxo_modes[_opermode].acim);
+	wctdm_setreg(wc, card, 30, reg30);
+
+	/* Misc. DAA parameters */
+	reg31 = 0xa3;
+	reg31 |= (fxo_modes[_opermode].ohs2 << 3);
+	wctdm_setreg(wc, card, 31, reg31);
+
+	/* Set Transmit/Receive timeslot */
+	//printk("set card %d to %d\n", card, (3-(card%4)) * 8 + (card/4) * 64);
+	wctdm_setreg(wc, card, 34, (3-(card%4)) * 8 + (card/4) * 64);
+	wctdm_setreg(wc, card, 35, 0x00);
+	wctdm_setreg(wc, card, 36, (3-(card%4)) * 8 + (card/4) * 64);
+	wctdm_setreg(wc, card, 37, 0x00);
+
+	/* Enable ISO-Cap */
+	wctdm_setreg(wc, card, 6, 0x00);
+
+	/* Wait 1000ms for ISO-cap to come up */
+	newjiffies = jiffies;
+	newjiffies += 2 * HZ;
+	while((jiffies < newjiffies) && !(wctdm_getreg(wc, card, 11) & 0xf0))
+		wait_just_a_bit(HZ/10);
+
+	if (!(wctdm_getreg(wc, card, 11) & 0xf0)) {
+		printk("VoiceDAA did not bring up ISO link properly!\n");
+		return -1;
+	}
+	if (debug)
+		printk("ISO-Cap is now up, line side: %02x rev %02x\n", 
+		       wctdm_getreg(wc, card, 11) >> 4,
+		       (wctdm_getreg(wc, card, 13) >> 2) & 0xf);
+	/* Enable on-hook line monitor */
+	wctdm_setreg(wc, card, 5, 0x08);
+
+	/* NZ -- crank the tx gain up by 7 dB */
+	if (!strcmp(fxo_modes[_opermode].name, "NEWZEALAND")) {
+		printk("Adjusting gain\n");
+		wctdm_setreg(wc, card, 38, 0x7);
+	}
+
+	return 0;
+		
+}
+
+static int wctdm_init_proslic(struct wctdm *wc, int card, int fast, int manual, int sane)
+{
+
+	unsigned short tmp[5];
+	unsigned char r19;
+	int x;
+	int fxsmode=0;
+
+
+	/* By default, don't send on hook */
+	if (reversepolarity)
+		wc->mod[card].fxs.idletxhookstate = 5;
+	else
+		wc->mod[card].fxs.idletxhookstate = 1;
+
+	/* Sanity check the ProSLIC */
+	if (!sane && wctdm_proslic_insane(wc, card))
+		return -2;
+		
+	if (sane) {
+		/* Make sure we turn off the DC->DC converter to prevent anything from blowing up */
+		wctdm_setreg(wc, card, 14, 0x10);
+	}
+
+	if (wctdm_proslic_init_indirect_regs(wc, card)) {
+		printk(KERN_INFO "Indirect Registers failed to initialize on module %d.\n", card);
+		return -1;
+	}
+
+	/* Clear scratch pad area */
+	wctdm_proslic_setreg_indirect(wc, card, 97,0);
+
+	/* Clear digital loopback */
+	wctdm_setreg(wc, card, 8, 0);
+
+	/* Revision C optimization */
+	wctdm_setreg(wc, card, 108, 0xeb);
+
+	/* Disable automatic VBat switching for safety to prevent
+	   Q7 from accidently turning on and burning out. */
+	wctdm_setreg(wc, card, 67, 0x17);
+
+	/* Turn off Q7 */
+	wctdm_setreg(wc, card, 66, 1);
+
+	/* Flush ProSLIC digital filters by setting to clear, while
+	   saving old values */
+	for (x=0;x<5;x++) {
+		tmp[x] = wctdm_proslic_getreg_indirect(wc, card, x + 35);
+		wctdm_proslic_setreg_indirect(wc, card, x + 35, 0x8000);
+	}
+
+	/* Power up the DC-DC converter */
+	if (wctdm_powerup_proslic(wc, card, fast)) {
+		printk("Unable to do INITIAL ProSLIC powerup on module %d\n", card);
+		return -1;
+	}
+
+	if (!fast) {
+
+		/* Check for power leaks */
+		if (wctdm_proslic_powerleak_test(wc, card)) {
+			printk("ProSLIC module %d failed leakage test.  Check for short circuit\n", card);
+		}
+		/* Power up again */
+		if (wctdm_powerup_proslic(wc, card, fast)) {
+			printk("Unable to do FINAL ProSLIC powerup on module %d\n", card);
+			return -1;
+		}
+#ifndef NO_CALIBRATION
+		/* Perform calibration */
+		if(manual) {
+			if (wctdm_proslic_manual_calibrate(wc, card)) {
+				//printk("Proslic failed on Manual Calibration\n");
+				if (wctdm_proslic_manual_calibrate(wc, card)) {
+					printk("Proslic Failed on Second Attempt to Calibrate Manually. (Try -DNO_CALIBRATION in Makefile)\n");
+					return -1;
+				}
+				printk("Proslic Passed Manual Calibration on Second Attempt\n");
+			}
+		}
+		else {
+			if(wctdm_proslic_calibrate(wc, card))  {
+				//printk("ProSlic died on Auto Calibration.\n");
+				if (wctdm_proslic_calibrate(wc, card)) {
+					printk("Proslic Failed on Second Attempt to Auto Calibrate\n");
+					return -1;
+				}
+				printk("Proslic Passed Auto Calibration on Second Attempt\n");
+			}
+		}
+		/* Perform DC-DC calibration */
+		wctdm_setreg(wc, card, 93, 0x99);
+		r19 = wctdm_getreg(wc, card, 107);
+		if ((r19 < 0x2) || (r19 > 0xd)) {
+			printk("DC-DC cal has a surprising direct 107 of 0x%02x!\n", r19);
+			wctdm_setreg(wc, card, 107, 0x8);
+		}
+
+		/* Save calibration vectors */
+		for (x=0;x<NUM_CAL_REGS;x++)
+			wc->mod[card].fxs.calregs.vals[x] = wctdm_getreg(wc, card, 96 + x);
+#endif
+
+	} else {
+		/* Restore calibration registers */
+		for (x=0;x<NUM_CAL_REGS;x++)
+			wctdm_setreg(wc, card, 96 + x, wc->mod[card].fxs.calregs.vals[x]);
+	}
+	/* Calibration complete, restore original values */
+	for (x=0;x<5;x++) {
+		wctdm_proslic_setreg_indirect(wc, card, x + 35, tmp[x]);
+	}
+
+	if (wctdm_proslic_verify_indirect_regs(wc, card)) {
+		printk(KERN_INFO "Indirect Registers failed verification.\n");
+		return -1;
+	}
+
+
+#if 0
+    /* Disable Auto Power Alarm Detect and other "features" */
+    wctdm_setreg(wc, card, 67, 0x0e);
+    blah = wctdm_getreg(wc, card, 67);
+#endif
+
+#if 0
+    if (wctdm_proslic_setreg_indirect(wc, card, 97, 0x0)) { // Stanley: for the bad recording fix
+		 printk(KERN_INFO "ProSlic IndirectReg Died.\n");
+		 return -1;
+	}
+#endif
+
+    if (alawoverride)
+    	wctdm_setreg(wc, card, 1, 0x20);
+    else
+    	wctdm_setreg(wc, card, 1, 0x28);
+ 	// U-Law 8-bit interface
+	
+    //printk("set card %d to %d\n", card, (3-(card%4)) * 8 + (card/4) * 64);
+    wctdm_setreg(wc, card, 2, (3-(card%4)) * 8 + (card/4) * 64);    // Tx Start count low byte  0
+    wctdm_setreg(wc, card, 3, 0);    // Tx Start count high byte 0
+    wctdm_setreg(wc, card, 4, (3-(card%4)) * 8 + (card/4) * 64);    // Rx Start count low byte  0
+    wctdm_setreg(wc, card, 5, 0);    // Rx Start count high byte 0
+    wctdm_setreg(wc, card, 18, 0xff);     // clear all interrupt
+    wctdm_setreg(wc, card, 19, 0xff);
+    wctdm_setreg(wc, card, 20, 0xff);
+    wctdm_setreg(wc, card, 73, 0x04);
+	if (fxshonormode) {
+		fxsmode = acim2tiss[fxo_modes[_opermode].acim];
+		wctdm_setreg(wc, card, 10, 0x08 | fxsmode);
+		if (fxo_modes[_opermode].ring_osc)
+			wctdm_proslic_setreg_indirect(wc, card, 20, fxo_modes[_opermode].ring_osc);
+		if (fxo_modes[_opermode].ring_x)
+			wctdm_proslic_setreg_indirect(wc, card, 21, fxo_modes[_opermode].ring_x);
+	}
+    if (lowpower)
+    	wctdm_setreg(wc, card, 72, 0x10);
+
+#if 0
+    wctdm_setreg(wc, card, 21, 0x00); 	// enable interrupt
+    wctdm_setreg(wc, card, 22, 0x02); 	// Loop detection interrupt
+    wctdm_setreg(wc, card, 23, 0x01); 	// DTMF detection interrupt
+#endif
+
+#if 0
+    /* Enable loopback */
+    wctdm_setreg(wc, card, 8, 0x2);
+    wctdm_setreg(wc, card, 14, 0x0);
+    wctdm_setreg(wc, card, 64, 0x0);
+    wctdm_setreg(wc, card, 1, 0x08);
+#endif
+
+	/* Beef up Ringing voltage to 89V */
+	if (boostringer) {
+		if (wctdm_proslic_setreg_indirect(wc, card, 21, 0x1d1)) 
+			return -1;
+		printk("Boosting ringinger on slot %d (89V peak)\n", card + 1);
+	} else if (lowpower) {
+		if (wctdm_proslic_setreg_indirect(wc, card, 21, 0x108)) 
+			return -1;
+		printk("Reducing ring power on slot %d (50V peak)\n", card + 1);
+	}
+	wctdm_setreg(wc, card, 64, 0x01);
+	return 0;
+}
+
+
+static int wctdm_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data)
+{
+	struct wctdm_stats stats;
+	struct wctdm_regs regs;
+	struct wctdm_regop regop;
+	struct wctdm_echo_coefs echoregs;
+	struct wctdm *wc = chan->pvt;
+	int x;
+	switch (cmd) {
+	case ZT_ONHOOKTRANSFER:
+		if (wc->modtype[chan->chanpos - 1] != MOD_TYPE_FXS)
+			return -EINVAL;
+		if (get_user(x, (int *)data))
+			return -EFAULT;
+		wc->mod[chan->chanpos - 1].fxs.ohttimer = x << 3;
+		if (reversepolarity)
+			wc->mod[chan->chanpos - 1].fxs.idletxhookstate = 0x6;	/* OHT mode when idle */
+		else
+			wc->mod[chan->chanpos - 1].fxs.idletxhookstate = 0x2;
+		if (wc->mod[chan->chanpos - 1].fxs.lasttxhook == 0x1) {
+				/* Apply the change if appropriate */
+				if (reversepolarity)
+					wc->mod[chan->chanpos - 1].fxs.lasttxhook = 0x6;
+				else
+					wc->mod[chan->chanpos - 1].fxs.lasttxhook = 0x2;
+				wctdm_setreg(wc, chan->chanpos - 1, 64, wc->mod[chan->chanpos - 1].fxs.lasttxhook);
+		}
+		break;
+	case ZT_SETPOLARITY:
+		if (get_user(x, (int *)data))
+			return -EFAULT;
+		if (wc->modtype[chan->chanpos - 1] != MOD_TYPE_FXS)
+			return -EINVAL;
+		/* Can't change polarity while ringing or when open */
+		if ((wc->mod[chan->chanpos -1 ].fxs.lasttxhook == 0x04) ||
+		    (wc->mod[chan->chanpos -1 ].fxs.lasttxhook == 0x00))
+			return -EINVAL;
+
+		if ((x && !reversepolarity) || (!x && reversepolarity))
+			wc->mod[chan->chanpos - 1].fxs.lasttxhook |= 0x04;
+		else
+			wc->mod[chan->chanpos - 1].fxs.lasttxhook &= ~0x04;
+		wctdm_setreg(wc, chan->chanpos - 1, 64, wc->mod[chan->chanpos - 1].fxs.lasttxhook);
+		break;
+	case WCTDM_GET_STATS:
+		if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXS) {
+			stats.tipvolt = wctdm_getreg(wc, chan->chanpos - 1, 80) * -376;
+			stats.ringvolt = wctdm_getreg(wc, chan->chanpos - 1, 81) * -376;
+			stats.batvolt = wctdm_getreg(wc, chan->chanpos - 1, 82) * -376;
+		} else if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO) {
+			stats.tipvolt = (signed char)wctdm_getreg(wc, chan->chanpos - 1, 29) * 1000;
+			stats.ringvolt = (signed char)wctdm_getreg(wc, chan->chanpos - 1, 29) * 1000;
+			stats.batvolt = (signed char)wctdm_getreg(wc, chan->chanpos - 1, 29) * 1000;
+		} else 
+			return -EINVAL;
+		if (copy_to_user((struct wctdm_stats *)data, &stats, sizeof(stats)))
+			return -EFAULT;
+		break;
+	case WCTDM_GET_REGS:
+		if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXS) {
+			for (x=0;x<NUM_INDIRECT_REGS;x++)
+				regs.indirect[x] = wctdm_proslic_getreg_indirect(wc, chan->chanpos -1, x);
+			for (x=0;x<NUM_REGS;x++)
+				regs.direct[x] = wctdm_getreg(wc, chan->chanpos - 1, x);
+		} else {
+			memset(&regs, 0, sizeof(regs));
+			for (x=0;x<NUM_FXO_REGS;x++)
+				regs.direct[x] = wctdm_getreg(wc, chan->chanpos - 1, x);
+		}
+		if (copy_to_user((struct wctdm_regs *)data, &regs, sizeof(regs)))
+			return -EFAULT;
+		break;
+	case WCTDM_SET_REG:
+		if (copy_from_user(&regop, (struct wctdm_regop *)data, sizeof(regop)))
+			return -EFAULT;
+		if (regop.indirect) {
+			if (wc->modtype[chan->chanpos - 1] != MOD_TYPE_FXS)
+				return -EINVAL;
+			printk("Setting indirect %d to 0x%04x on %d\n", regop.reg, regop.val, chan->chanpos);
+			wctdm_proslic_setreg_indirect(wc, chan->chanpos - 1, regop.reg, regop.val);
+		} else {
+			regop.val &= 0xff;
+			printk("Setting direct %d to %04x on %d\n", regop.reg, regop.val, chan->chanpos);
+			wctdm_setreg(wc, chan->chanpos - 1, regop.reg, regop.val);
+		}
+		break;
+	case WCTDM_SET_ECHOTUNE:
+		printk("-- Setting echo registers: \n");
+		if (copy_from_user(&echoregs, (struct wctdm_echo_coefs*)data, sizeof(echoregs)))
+			return -EFAULT;
+
+		if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO) {
+			/* Set the ACIM register */
+			wctdm_setreg(wc, chan->chanpos - 1, 30, echoregs.acim);
+
+			/* Set the digital echo canceller registers */
+			wctdm_setreg(wc, chan->chanpos - 1, 45, echoregs.coef1);
+			wctdm_setreg(wc, chan->chanpos - 1, 46, echoregs.coef2);
+			wctdm_setreg(wc, chan->chanpos - 1, 47, echoregs.coef3);
+			wctdm_setreg(wc, chan->chanpos - 1, 48, echoregs.coef4);
+			wctdm_setreg(wc, chan->chanpos - 1, 49, echoregs.coef5);
+			wctdm_setreg(wc, chan->chanpos - 1, 50, echoregs.coef6);
+			wctdm_setreg(wc, chan->chanpos - 1, 51, echoregs.coef7);
+			wctdm_setreg(wc, chan->chanpos - 1, 52, echoregs.coef8);
+
+			printk("-- Set echo registers successfully\n");
+
+			break;
+		} else {
+			return -EINVAL;
+
+		}
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+
+}
+
+static int wctdm_open(struct zt_chan *chan)
+{
+	struct wctdm *wc = chan->pvt;
+	if (!(wc->cardflag & (1 << (chan->chanpos - 1))))
+		return -ENODEV;
+	if (wc->dead)
+		return -ENODEV;
+	wc->usecount++;
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#else
+	try_module_get(THIS_MODULE);
+#endif	
+	return 0;
+}
+
+static int wctdm_watchdog(struct zt_span *span, int event)
+{
+	printk("opvxa1200: Restarting DMA\n");
+	wctdm_restart_dma(span->pvt);
+	return 0;
+}
+
+static int wctdm_close(struct zt_chan *chan)
+{
+	struct wctdm *wc = chan->pvt;
+	wc->usecount--;
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#else
+	module_put(THIS_MODULE);
+#endif
+	if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXS) {
+		if (reversepolarity)
+			wc->mod[chan->chanpos - 1].fxs.idletxhookstate = 5;
+		else
+			wc->mod[chan->chanpos - 1].fxs.idletxhookstate = 1;
+	}
+	/* If we're dead, release us now */
+	if (!wc->usecount && wc->dead) 
+		wctdm_release(wc);
+	return 0;
+}
+
+static int wctdm_hooksig(struct zt_chan *chan, zt_txsig_t txsig)
+{
+	struct wctdm *wc = chan->pvt;
+	int reg=0;
+	if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO) {
+		/* XXX Enable hooksig for FXO XXX */
+		switch(txsig) {
+		case ZT_TXSIG_START:
+		case ZT_TXSIG_OFFHOOK:
+			wc->mod[chan->chanpos - 1].fxo.offhook = 1;
+			wctdm_setreg(wc, chan->chanpos - 1, 5, 0x9);
+			break;
+		case ZT_TXSIG_ONHOOK:
+			wc->mod[chan->chanpos - 1].fxo.offhook = 0;
+			wctdm_setreg(wc, chan->chanpos - 1, 5, 0x8);
+			break;
+		default:
+			printk("wcfxo: Can't set tx state to %d\n", txsig);
+		}
+	} else {
+		switch(txsig) {
+		case ZT_TXSIG_ONHOOK:
+			switch(chan->sig) {
+			case ZT_SIG_EM:
+			case ZT_SIG_FXOKS:
+			case ZT_SIG_FXOLS:
+				wc->mod[chan->chanpos-1].fxs.lasttxhook = wc->mod[chan->chanpos-1].fxs.idletxhookstate;
+				break;
+			case ZT_SIG_FXOGS:
+				wc->mod[chan->chanpos-1].fxs.lasttxhook = 3;
+				break;
+			}
+			break;
+		case ZT_TXSIG_OFFHOOK:
+			switch(chan->sig) {
+			case ZT_SIG_EM:
+				wc->mod[chan->chanpos-1].fxs.lasttxhook = 5;
+				break;
+			default:
+				wc->mod[chan->chanpos-1].fxs.lasttxhook = wc->mod[chan->chanpos-1].fxs.idletxhookstate;
+				break;
+			}
+			break;
+		case ZT_TXSIG_START:
+			wc->mod[chan->chanpos-1].fxs.lasttxhook = 4;
+			break;
+		case ZT_TXSIG_KEWL:
+			wc->mod[chan->chanpos-1].fxs.lasttxhook = 0;
+			break;
+		default:
+			printk("opvxa1200: Can't set tx state to %d\n", txsig);
+		}
+		if (debug)
+			printk("Setting FXS hook state to %d (%02x)\n", txsig, reg);
+
+#if 1
+		wctdm_setreg(wc, chan->chanpos - 1, 64, wc->mod[chan->chanpos-1].fxs.lasttxhook);
+#endif
+	}
+	return 0;
+}
+
+static int wctdm_initialize(struct wctdm *wc)
+{
+	int x;
+
+	/* Zapata stuff */
+	sprintf(wc->span.name, "OPVXA1200/%d", wc->pos);
+	sprintf(wc->span.desc, "%s Board %d", wc->variety, wc->pos + 1);
+	if (alawoverride) {
+		printk("ALAW override parameter detected.  Device will be operating in ALAW\n");
+		wc->span.deflaw = ZT_LAW_ALAW;
+	} else
+		wc->span.deflaw = ZT_LAW_MULAW;
+	for (x = 0; x < NUM_CARDS; x++) {
+		sprintf(wc->chans[x].name, "OPVXA1200/%d/%d", wc->pos, x);
+		wc->chans[x].sigcap = ZT_SIG_FXOKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS | ZT_SIG_SF | ZT_SIG_EM | ZT_SIG_CLEAR;
+		wc->chans[x].sigcap |= ZT_SIG_FXSKS | ZT_SIG_FXSLS | ZT_SIG_SF | ZT_SIG_CLEAR;
+		wc->chans[x].chanpos = x+1;
+		wc->chans[x].pvt = wc;
+	}
+	wc->span.chans = wc->chans;
+	wc->span.channels = NUM_CARDS;
+	wc->span.hooksig = wctdm_hooksig;
+	wc->span.open = wctdm_open;
+	wc->span.close = wctdm_close;
+	wc->span.flags = ZT_FLAG_RBS;
+	wc->span.ioctl = wctdm_ioctl;
+	wc->span.watchdog = wctdm_watchdog;
+	init_waitqueue_head(&wc->span.maintq);
+
+	wc->span.pvt = wc;
+	if (zt_register(&wc->span, 0)) {
+		printk("Unable to register span with zaptel\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void wctdm_post_initialize(struct wctdm *wc)
+{
+	int x;
+	/* Finalize signalling  */
+	for (x = 0; x < NUM_CARDS; x++) {
+		if (wc->cardflag & (1 << x)) {
+			if (wc->modtype[x] == MOD_TYPE_FXO)
+				wc->chans[x].sigcap = ZT_SIG_FXSKS | ZT_SIG_FXSLS | ZT_SIG_SF | ZT_SIG_CLEAR;
+			else
+				wc->chans[x].sigcap = ZT_SIG_FXOKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS | ZT_SIG_SF | ZT_SIG_EM | ZT_SIG_CLEAR;
+		}
+	}
+}
+
+static int wctdm_hardware_init(struct wctdm *wc)
+{
+	/* Hardware stuff */
+	unsigned char ver;
+	unsigned char x,y;
+	int failed;
+	//long origjiffies; //ml.
+	
+	/* Signal Reset */
+	//printk("before raise reset\n");
+	outb(0x01, wc->ioaddr + WC_CNTL);
+
+	/* Wait for 2 second */
+	/*
+	origjiffies = jiffies;
+
+	while(1) 
+	{
+		if ((jiffies - origjiffies) >= (HZ*5))
+			break;;
+	}
+
+	printk("after raise reset\n");*/
+
+	/* Check OpenVox chip */
+	x=inb(wc->ioaddr + WC_CNTL);
+	ver = __wctdm_getcreg(wc, WC_VER);
+	wc->fwversion = ver;
+	printk("OpenVox A1200P version: %01x.%01x\n", ver>>4, ver&0x0f);
+	failed = 0;
+	if (ver != 0x00) {
+		for (x=0;x<16;x++) {
+			/* Test registers */
+			__wctdm_setcreg(wc, WC_CS, x);
+			y = __wctdm_getcreg(wc, WC_CS) & 0x0f;
+			if (x != y) {
+				printk("%02x != %02x\n", x, y);
+				failed++;
+			}
+		}
+
+		if (!failed) {
+			printk("OpenVox A1200P passed register test\n");
+		} else {
+			printk("OpenVox A1200P failed register test\n");
+			return -1;
+		}
+	} else {
+		printk("No OpenVox chip %02x\n", ver);
+	}
+
+	if (spibyhw)
+		__wctdm_setcreg(wc, WC_SPICTRL, BIT_SPI_BYHW);	// spi controled by hw MiaoLin;
+	else
+		__wctdm_setcreg(wc, WC_SPICTRL, 0);	
+		
+	/* Reset PCI Interface chip and registers (and serial) */
+	outb(0x06, wc->ioaddr + WC_CNTL);
+	/* Setup our proper outputs for when we switch for our "serial" port */
+	wc->ios = BIT_CS | BIT_SCLK | BIT_SDI;
+
+	outb(wc->ios, wc->ioaddr + WC_AUXD);
+
+	/* Set all to outputs except AUX 5, which is an input */
+	outb(0xdf, wc->ioaddr + WC_AUXC);
+
+	/* Select alternate function for AUX0 *///MiaoLin modify it to normal io line.
+	//outb(0x4, wc->ioaddr + WC_AUXFUNC);
+	
+	/* Wait 1/4 of a sec */
+	wait_just_a_bit(HZ/4);
+
+	/* Back to normal, with automatic DMA wrap around */
+	outb(0x30 | 0x01, wc->ioaddr + WC_CNTL);
+	wc->ledstate = 0;
+	wctdm_set_led(wc, 0, 0);
+	
+	/* Make sure serial port and DMA are out of reset */
+	outb(inb(wc->ioaddr + WC_CNTL) & 0xf9, WC_CNTL);
+	
+	/* Configure serial port for MSB->LSB operation */
+	//outb(0xc1, wc->ioaddr + WC_SERCTL);
+	outb(0xc1, wc->ioaddr + WC_SERCTL);
+
+	/* Delay FSC by 0 so it's properly aligned */
+	//outb(0x0, wc->ioaddr + WC_FSCDELAY);
+	outb(0x01, wc->ioaddr + WC_FSCDELAY);
+
+	/* Setup DMA Addresses */
+	outl(wc->writedma,                    wc->ioaddr + WC_DMAWS);		/* Write start */
+	outl(wc->writedma + ZT_CHUNKSIZE * 4 * 4 - 4, wc->ioaddr + WC_DMAWI);		/* Middle (interrupt) */
+	outl(wc->writedma + ZT_CHUNKSIZE * 8 * 4 - 4, wc->ioaddr + WC_DMAWE);			/* End */
+	
+	outl(wc->readdma,                    	 wc->ioaddr + WC_DMARS);	/* Read start */
+	outl(wc->readdma + ZT_CHUNKSIZE * 4 * 4 - 4, 	 wc->ioaddr + WC_DMARI);	/* Middle (interrupt) */
+	outl(wc->readdma + ZT_CHUNKSIZE * 8 * 4 - 4, wc->ioaddr + WC_DMARE);	/* End */
+	
+	/* Clear interrupts */
+	outb(0xff, wc->ioaddr + WC_INTSTAT);
+
+	/* Wait 1/4 of a second more */
+	wait_just_a_bit(HZ/4);
+
+	for (x = 0; x < NUM_CARDS; x++) {
+		int sane=0,ret=0,readi=0;
+#if 1
+		/* Init with Auto Calibration */
+		if (!(ret=wctdm_init_proslic(wc, x, 0, 0, sane))) {
+			wc->cardflag |= (1 << x);
+                        if (debug) {
+                                readi = wctdm_getreg(wc,x,LOOP_I_LIMIT);
+                                printk("Proslic module %d loop current is %dmA\n",x,
+                                ((readi*3)+20));
+                        }
+			printk("Module %d: Installed -- AUTO FXS/DPO\n",x);
+			wctdm_set_led(wc, (unsigned int)x, 1);
+		} else {
+			if(ret!=-2) {
+				sane=1;
+				
+				printk("Init ProSlic with Manual Calibration \n");
+				/* Init with Manual Calibration */
+				if (!wctdm_init_proslic(wc, x, 0, 1, sane)) {
+					wc->cardflag |= (1 << x);
+                                if (debug) {
+                                        readi = wctdm_getreg(wc,x,LOOP_I_LIMIT);
+                                        printk("Proslic module %d loop current is %dmA\n",x,
+                                        ((readi*3)+20));
+                                }
+					printk("Module %d: Installed -- MANUAL FXS\n",x);
+				} else {
+					printk("Module %d: FAILED FXS (%s)\n", x, fxshonormode ? fxo_modes[_opermode].name : "FCC");
+				} 
+			} else if (!(ret = wctdm_init_voicedaa(wc, x, 0, 0, sane))) {
+				wc->cardflag |= (1 << x);
+				printk("Module %d: Installed -- AUTO FXO (%s mode)\n",x, fxo_modes[_opermode].name);
+				wctdm_set_led(wc, (unsigned int)x, 1);
+			} else
+				printk("Module %d: Not installed\n", x);
+		}
+#endif
+	}
+
+	/* Return error if nothing initialized okay. */
+	if (!wc->cardflag && !timingonly)
+		return -1;
+	//__wctdm_setcreg(wc, WC_SYNC, (wc->cardflag << 1) | 0x1);
+	return 0;
+}
+
+static void wctdm_enable_interrupts(struct wctdm *wc)
+{
+	/* Clear interrupts */
+	outb(0xff, wc->ioaddr + WC_INTSTAT);
+
+	/* Enable interrupts (we care about all of them) */
+	outb(0x3c /*0x3f*/, wc->ioaddr + WC_MASK0);
+	/* No external interrupts */
+	outb(0x00, wc->ioaddr + WC_MASK1);
+}
+
+static void wctdm_restart_dma(struct wctdm *wc)
+{
+	/* Reset Master and TDM */
+	outb(0x01, wc->ioaddr + WC_CNTL);
+	outb(0x01, wc->ioaddr + WC_OPER);
+}
+
+static void wctdm_start_dma(struct wctdm *wc)
+{
+	/* Reset Master and TDM */
+	outb(0x0f, wc->ioaddr + WC_CNTL);
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(1);
+	outb(0x01, wc->ioaddr + WC_CNTL);
+	outb(0x01, wc->ioaddr + WC_OPER);
+}
+
+static void wctdm_stop_dma(struct wctdm *wc)
+{
+	outb(0x00, wc->ioaddr + WC_OPER);
+}
+
+static void wctdm_reset_tdm(struct wctdm *wc)
+{
+	/* Reset TDM */
+	outb(0x0f, wc->ioaddr + WC_CNTL);
+}
+
+static void wctdm_disable_interrupts(struct wctdm *wc)	
+{
+	outb(0x00, wc->ioaddr + WC_MASK0);
+	outb(0x00, wc->ioaddr + WC_MASK1);
+}
+
+static int __devinit wctdm_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int res;
+	struct wctdm *wc;
+	struct wctdm_desc *d = (struct wctdm_desc *)ent->driver_data;
+	int x;
+	int y;
+
+	static int initd_ifaces=0;
+	
+	if(initd_ifaces){
+		memset((void *)ifaces,0,(sizeof(struct wctdm *))*WC_MAX_IFACES);
+		initd_ifaces=1;
+	}
+	for (x=0;x<WC_MAX_IFACES;x++)
+		if (!ifaces[x]) break;
+	if (x >= WC_MAX_IFACES) {
+		printk("Too many interfaces\n");
+		return -EIO;
+	}
+	
+	if (pci_enable_device(pdev)) {
+		res = -EIO;
+	} else {
+		wc = kmalloc(sizeof(struct wctdm), GFP_KERNEL);
+		if (wc) {
+			int cardcount = 0;
+			
+			//wc->offset = 12;	// miaolin add.
+			wc->lastchan = -1;	// first channel offset = -1;
+			wc->ledstate = 0;
+			
+			ifaces[x] = wc;
+			memset(wc, 0, sizeof(struct wctdm));
+			spin_lock_init(&wc->lock);
+			wc->curcard = -1;
+			wc->ioaddr = pci_resource_start(pdev, 0);
+			wc->mem_region = pci_resource_start(pdev, 1);
+			wc->mem_len = pci_resource_len(pdev, 1);
+			wc->mem32 = (unsigned long)ioremap(wc->mem_region, wc->mem_len);
+			wc->dev = pdev;
+			wc->pos = x;
+			wc->variety = d->name;
+			for (y=0;y<NUM_CARDS;y++)
+				wc->flags[y] = d->flags;
+			/* Keep track of whether we need to free the region */
+			if (request_region(wc->ioaddr, 0xff, "opvxa1200")) 
+				wc->freeregion = 1;
+			else
+				wc->freeregion = 0;
+			
+			if (request_mem_region(wc->mem_region, wc->mem_len, "opvxa1200"))
+				wc->freeregion |= 0x02;
+
+			/* Allocate enough memory for two zt chunks, receive and transmit.  Each sample uses
+			   8 bits.  */
+			wc->writechunk = pci_alloc_consistent(pdev, ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2, &wc->writedma);
+			if (!wc->writechunk) {
+				printk("opvxa1200: Unable to allocate DMA-able memory\n");
+				if (wc->freeregion & 0x01)
+					release_region(wc->ioaddr, 0xff);
+				if (wc->freeregion & 0x02);
+				{
+					release_mem_region(wc->mem_region, wc->mem_len);
+					iounmap((void *)wc->mem32);
+				}
+				return -ENOMEM;
+			}
+
+			wc->readchunk = wc->writechunk + ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2;	/* in bytes */
+			wc->readdma = wc->writedma + ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2;	/* in bytes */
+			
+			if (wctdm_initialize(wc)) {
+				printk("opvxa1200: Unable to intialize FXS\n");
+				/* Set Reset Low */
+				x=inb(wc->ioaddr + WC_CNTL);
+				outb((~0x1)&x, wc->ioaddr + WC_CNTL);
+				/* Free Resources */
+				free_irq(pdev->irq, wc);
+				if (wc->freeregion & 0x01)
+					release_region(wc->ioaddr, 0xff);
+				if (wc->freeregion & 0x02);
+				{
+					release_mem_region(wc->mem_region, wc->mem_len);
+					iounmap((void *)wc->mem32);
+				}
+				pci_free_consistent(pdev,  ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2, (void *)wc->writechunk, wc->writedma);
+				kfree(wc);
+				return -EIO;
+			}
+
+			/* Enable bus mastering */
+			pci_set_master(pdev);
+
+			/* Keep track of which device we are */
+			pci_set_drvdata(pdev, wc);
+
+			if (request_irq(pdev->irq, wctdm_interrupt, ZAP_IRQ_SHARED, "opvxa1200", wc)) {
+				printk("opvxa1200: Unable to request IRQ %d\n", pdev->irq);
+				if (wc->freeregion & 0x01)
+					release_region(wc->ioaddr, 0xff);
+				if (wc->freeregion & 0x02);
+				{
+					release_mem_region(wc->mem_region, wc->mem_len);
+					iounmap((void *)wc->mem32);
+				}
+				pci_free_consistent(pdev,  ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2, (void *)wc->writechunk, wc->writedma);
+				pci_set_drvdata(pdev, NULL);
+				kfree(wc);
+				return -EIO;
+			}
+
+
+			if (wctdm_hardware_init(wc)) {
+				unsigned char x;
+
+				/* Set Reset Low */
+				x=inb(wc->ioaddr + WC_CNTL);
+				outb((~0x1)&x, wc->ioaddr + WC_CNTL);
+				/* Free Resources */
+				free_irq(pdev->irq, wc);
+				if (wc->freeregion & 0x01)
+					release_region(wc->ioaddr, 0xff);
+				if (wc->freeregion & 0x02);
+				{
+					release_mem_region(wc->mem_region, wc->mem_len);
+					iounmap((void *)wc->mem32);
+				}
+				pci_free_consistent(pdev,  ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2, (void *)wc->writechunk, wc->writedma);
+				pci_set_drvdata(pdev, NULL);
+				zt_unregister(&wc->span);
+				kfree(wc);
+				return -EIO;
+
+			}
+
+#ifdef TEST_LOG_INCOME_VOICE
+			for(i=0; i<NUM_CARDS+NUM_FLAG; i++)
+			{
+				wc->voc_buf[i] = kmalloc(voc_buffer_size, GFP_KERNEL);
+				wc->voc_ptr[i] = 0;
+			}
+#endif
+			
+			wctdm_post_initialize(wc);
+
+			/* Enable interrupts */
+			wctdm_enable_interrupts(wc);
+			/* Initialize Write/Buffers to all blank data */
+			memset((void *)wc->writechunk,0, ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2);
+
+			/* Start DMA */
+			wctdm_start_dma(wc);
+
+			for (x = 0; x < NUM_CARDS; x++) {
+				if (wc->cardflag & (1 << x))
+					cardcount++;
+			}
+
+			printk("Found a OpenVox A1200P: Version %01x.%01x (%d modules)\n", wc->fwversion>>4, wc->fwversion&0x0f, cardcount);
+			
+			res = 0;
+		} else
+			res = -ENOMEM;
+	}
+	return res;
+}
+
+static void wctdm_release(struct wctdm *wc)
+{
+#ifdef TEST_LOG_INCOME_VOICE
+	struct file * f = NULL;
+	mm_segment_t orig_fs;
+	int i;
+	char fname[20];
+#endif
+	
+	zt_unregister(&wc->span);
+	if (wc->freeregion & 0x01)
+		release_region(wc->ioaddr, 0xff);
+	if (wc->freeregion & 0x02);
+	{
+		release_mem_region(wc->mem_region, wc->mem_len);
+		iounmap((void *)wc->mem32);
+	}
+	
+#ifdef TEST_LOG_INCOME_VOICE
+	for(i=0; i<NUM_CARDS + NUM_FLAG; i++)
+	{
+		sprintf(fname, "//usr//%d.pcm", i); 
+		f = filp_open(fname, O_RDWR|O_CREAT, 00);
+	
+		if (!f || !f->f_op || !f->f_op->read)
+		{
+			printk("WARNING: File (read) object is a null pointer!!!\n");
+			continue;
+		}
+	
+		f->f_pos = 0;
+		
+		orig_fs = get_fs();
+		set_fs(KERNEL_DS); 
+		
+		if(wc->voc_buf[i])
+		{
+			f->f_op->write(f, wc->voc_buf[i], voc_buffer_size, &f->f_pos);
+			kfree(wc->voc_buf[i]);
+		}
+		
+		set_fs(orig_fs); 
+		fput(f);
+	}
+#endif
+ 
+	kfree(wc);
+	printk("Freed a OpenVox A1200 card\n");
+}
+
+static void __devexit wctdm_remove_one(struct pci_dev *pdev)
+{
+	struct wctdm *wc = pci_get_drvdata(pdev);
+	if (wc) {
+
+		/* Stop any DMA */
+		wctdm_stop_dma(wc);
+		wctdm_reset_tdm(wc);
+
+		/* In case hardware is still there */
+		wctdm_disable_interrupts(wc);
+		
+		/* Immediately free resources */
+		pci_free_consistent(pdev,  ZT_MAX_CHUNKSIZE * (NUM_CARDS+NUM_FLAG) * 2 * 2, (void *)wc->writechunk, wc->writedma);
+		free_irq(pdev->irq, wc);
+
+		/* Reset PCI chip and registers */
+		if(wc->fwversion > 0x11)
+			outb(0x0e, wc->ioaddr + WC_CNTL);
+		else
+		{
+			wc->ledstate = 0;
+			wctdm_set_led(wc,0,0);	// power off all leds.
+		}
+
+		/* Release span, possibly delayed */
+		if (!wc->usecount)
+			wctdm_release(wc);
+		else
+			wc->dead = 1;
+	}
+}
+
+static struct pci_device_id wctdm_pci_tbl[] = {
+	{ 0xe159, 0x0001, 0x9100, PCI_ANY_ID, 0, 0, (unsigned long) &wctdme },
+	{ 0xe159, 0x0001, 0x9519, PCI_ANY_ID, 0, 0, (unsigned long) &wctdme },
+	{ 0xe159, 0x0001, 0x95D9, PCI_ANY_ID, 0, 0, (unsigned long) &wctdme },
+	{ 0xe159, 0x0001, 0x8519, PCI_ANY_ID, 0, 0, (unsigned long) &wctdme },
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, wctdm_pci_tbl);
+
+static struct pci_driver wctdm_driver = {
+	name: 	"opvxa1200",
+	probe: 	wctdm_init_one,
+#ifdef LINUX26
+	remove:	__devexit_p(wctdm_remove_one),
+#else
+	remove:	wctdm_remove_one,
+#endif
+	suspend: NULL,
+	resume:	NULL,
+	id_table: wctdm_pci_tbl,
+};
+
+static int __init wctdm_init(void)
+{
+	int res;
+	int x;
+	for (x=0;x<(sizeof(fxo_modes) / sizeof(fxo_modes[0])); x++) {
+		if (!strcmp(fxo_modes[x].name, opermode))
+			break;
+	}
+	if (x < sizeof(fxo_modes) / sizeof(fxo_modes[0])) {
+		_opermode = x;
+	} else {
+		printk("Invalid/unknown operating mode '%s' specified.  Please choose one of:\n", opermode);
+		for (x=0;x<sizeof(fxo_modes) / sizeof(fxo_modes[0]); x++)
+			printk("  %s\n", fxo_modes[x].name);
+		printk("Note this option is CASE SENSITIVE!\n");
+		return -ENODEV;
+	}
+
+	res = zap_pci_module(&wctdm_driver);
+	if (res)
+		return -ENODEV;
+	return 0;
+}
+
+static void __exit wctdm_cleanup(void)
+{
+	pci_unregister_driver(&wctdm_driver);
+}
+
+#ifdef LINUX26
+module_param(debug, int, 0600);
+module_param(loopcurrent, int, 0600);
+module_param(reversepolarity, int, 0600);
+module_param(robust, int, 0600);
+module_param(_opermode, int, 0600);
+module_param(opermode, charp, 0600);
+module_param(timingonly, int, 0600);
+module_param(lowpower, int, 0600);
+module_param(boostringer, int, 0600);
+module_param(fxshonormode, int, 0600);
+module_param(battdebounce, int, 0600);
+module_param(battthresh, int, 0600);
+module_param(alawoverride, int, 0600);
+module_param(spibyhw, int, 0600);
+module_param(usememio, int, 0600);
+#else
+MODULE_PARM(debug, "i");
+MODULE_PARM(loopcurrent, "i");
+MODULE_PARM(reversepolarity, "i");
+MODULE_PARM(robust, "i");
+MODULE_PARM(_opermode, "i");
+MODULE_PARM(opermode, "s");
+MODULE_PARM(timingonly, "i");
+MODULE_PARM(lowpower, "i");
+MODULE_PARM(boostringer, "i");
+MODULE_PARM(fxshonormode, "i");
+MODULE_PARM(battdebounce, "i");
+MODULE_PARM(battthresh, "i");
+MODULE_PARM(alawoverride, "i");
+MODULE_PARM(spibyhw, "i");
+MODULE_PARM(usememio, "i");
+#endif
+MODULE_DESCRIPTION("OpenVox A1200 Zaptel Driver");
+MODULE_AUTHOR("MiaoLin <miaolin@openvox.com.cn>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+module_init(wctdm_init);
+module_exit(wctdm_cleanup);
diff -urN zaptel-1.4.11.org/kernel/qozap/Kbuild zaptel-1.4.11/kernel/qozap/Kbuild
--- zaptel-1.4.11.org/kernel/qozap/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/Kbuild	2008-07-16 22:20:32.714394997 +0200
@@ -0,0 +1,9 @@
+obj-m += qozap.o
+
+FIRM_DIR	:= ../../firmware
+
+EXTRA_CFLAGS := -I$(src)/.. -Wno-undef
+
+ifeq ($(HOTPLUG_FIRMWARE),yes)
+  EXTRA_CFLAGS+=-DHOTPLUG_FIRMWARE
+endif
diff -urN zaptel-1.4.11.org/kernel/qozap/Makefile zaptel-1.4.11/kernel/qozap/Makefile
--- zaptel-1.4.11.org/kernel/qozap/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/Makefile	2008-07-16 22:06:17.207813701 +0200
@@ -0,0 +1,89 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel")
+
+CFLAGS+=-I. $(ZAP) -DRELAXED_LOCKING -O2 -g -Wall -DBUILDING_TONEZONE  #-DTONEZONE_DRIVER
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -DRELAXED_LOCKING -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP)
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+OBJS=qozap.o
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+MODULES=qozap
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+linux26:
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+obj-m := $(OBJS)
+
+qozap.o: qozap.c qozap.h 
+	$(CC) -c qozap.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	rm -rf .tmp_versions
+
+testlinux24: all
+	modprobe zaptel
+	insmod ./qozap.o
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod qozap zaptel
+
+testlinux26: all
+	modprobe zaptel
+	insmod ./qozap.ko
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod qozap zaptel
+
+reload:	unload load
+load:	load$(BUILDVER)
+
+test:	test$(BUILDVER)
+
+
+loadlinux24: linux24
+	modprobe zaptel
+	insmod ./qozap.o
+	ztcfg -v
+
+loadlinux26: linux26
+	sync
+	modprobe zaptel
+	insmod ./qozap.ko
+	ztcfg -v
+
+unload: 
+	rmmod qozap zaptel
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 qozap.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/qozap.ko
+
+installlinux24:
+	install -D -m 644 qozap.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/qozap.o
diff -urN zaptel-1.4.11.org/kernel/qozap/qozap.c zaptel-1.4.11/kernel/qozap/qozap.c
--- zaptel-1.4.11.org/kernel/qozap/qozap.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/qozap.c	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,2044 @@
+/*
+ * qozap.c - Zaptel driver for the quadBRI PCI ISDN card
+ * and the octoBRI PCI ISDN card!
+ *
+ * Copyright (C) 2003, 2004, 2005, 2006, 2007 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <zaptel.h>
+#include "qozap.h"
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+#if CONFIG_PCI
+
+static int doubleclock=0;
+static int ports=-1; /* autodetect */
+static int pcmslave=0;
+static int bloop=0;
+static int debug=0;
+static int dacs=1; /* 0 = no dacs, 1 = oncard dacs */
+static struct qoz_card *qoz_dev_list = NULL;
+static int qoz_dev_count = 0;
+static int totalBRIs = 0;
+static struct pci_dev *multi_qoz = NULL;
+static spinlock_t registerlock = SPIN_LOCK_UNLOCKED;
+static int sort=1;
+
+static int ztqoz_shutdown(struct zt_span *span);
+
+int qoz_waitbusy(struct qoz_card *qoztmp) {
+    int x=1000;
+    while (x-- && (qoz_inb(qoztmp,qoz_R_STATUS) & 1));
+    if (x < 0) {
+	return -1;
+    } else {
+	return 0;
+    }
+}
+
+void qoz_shutdownCard(struct qoz_card *qoztmp) {
+    int s=0;
+    unsigned long flags;
+    
+    int stports=0;
+    if (qoztmp == NULL) {
+	printk(KERN_INFO "qozap: shutting down NULL card!\n");
+	return;
+    }
+
+    if ((qoztmp->pci_io == NULL) || (qoztmp->ioport == 0)) {
+	return;
+    }
+
+    if (debug)
+	printk(KERN_INFO "qozap: shutting down card %d (cardID %d) at io port %#x.\n",qoztmp->cardno,qoztmp->cardID,(u_int) qoztmp->ioport);
+
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+
+    // turn off irqs
+    qoz_outb(qoztmp,qoz_R_IRQMSK_MISC, 0); 
+    qoz_outb(qoztmp,qoz_R_SCI_MSK, 0); 
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+
+    stports = qoztmp->stports;
+    for (s=0; s < stports; s++) {
+        if(qoztmp->spans[s].flags & ZT_FLAG_REGISTERED) {
+    	    zt_unregister(&(qoztmp->spans[s]));
+	    if (debug > 2)
+	        printk(KERN_INFO "qozap: unregistered card %d span %d.\n",qoztmp->cardno,s+1);
+	}
+    }
+
+
+    release_region(qoztmp->ioport, 8);
+    iounmap((void *) qoztmp->pci_io);
+    release_mem_region((unsigned long) qoztmp->pci_io_phys, 256);
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+
+    qoztmp->pci_io = NULL;
+    qoztmp->ioport = 0;
+
+    if (qoztmp->pcidev != NULL) {
+        pci_disable_device(qoztmp->pcidev);
+    }
+    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, 0);	
+    
+    free_irq(qoztmp->irq,qoztmp);
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+
+    
+}
+
+void qoz_doLEDs(struct qoz_card *qoztmp) {
+    unsigned char leds = 0x0;
+    unsigned long ledw;
+    unsigned long flags;
+    spin_lock_irqsave(&qoztmp->lock,flags);
+
+    if ((qoztmp->type == 0xb520) && (qoztmp->stports == 4)){
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x20 | 0x10);
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0xf);
+	    qoz_outb(qoztmp,qoz_R_GPIO_OUT1,(qoztmp->leds[0] | (qoztmp->leds[1] << 1) | (qoztmp->leds[2] << 2) | (qoztmp->leds[3] << 3)));
+    } else if (((qoztmp->type == 0xb550)  || (qoztmp->type == 0xb556) || (qoztmp->type == 0xb752)) && (qoztmp->stports == 4)){
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x80 | 0x40 | 0x20 | 0x10);
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0xff);
+	    leds = 0x10;
+	    if (qoztmp->leds[0] == 1) {
+		leds |= 0x04;
+	    }
+	    if (qoztmp->leds[1] == 1) {
+		leds |= 0x20;
+	    }
+	    if (qoztmp->leds[2] == 1) {
+		leds |= 0x80;
+	    }
+	    if (qoztmp->leds[3] == 1) {
+		leds |= 0x40;
+	    }
+
+    /*
+	     03
+	     12
+	0x80 rr
+	     rg
+	0x40 rg
+	     rr
+	0x20 rr
+	     gr
+	0x04 gr
+	     rr
+    */
+	    qoz_outb(qoztmp,qoz_R_GPIO_OUT1, leds);
+
+    } else if (((qoztmp->type == 0xb556) || (qoztmp->type == 0xb751)) && (qoztmp->stports == 2)){
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x80 | 0x40 | 0x20 | 0x10);
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0xff);
+	    leds = 0x0;
+	    if (qoztmp->leds[0] == 1) {
+		leds |= 0x04;
+	    }
+	    if (qoztmp->leds[1] == 1) {
+		leds |= 0x08;
+	    }
+	    qoz_outb(qoztmp,qoz_R_GPIO_OUT1, leds);
+
+    } else if (qoztmp->type == 0xb558) {
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x80 | 0x40 | 0x20);
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x80 | 0x40 | 0x20 | 0x4);
+	    if (qoztmp->leds[0] == 1) {
+		leds |= 0x04;
+	    }
+	    if (qoztmp->leds[1] == 1) {
+		leds |= 0x20;
+	    }
+	    if (qoztmp->leds[2] == 1) {
+		leds |= 0x40;
+	    }
+	    if (qoztmp->leds[3] == 1) {
+		leds |= 0x80;
+	    }
+	    
+	    qoz_outb(qoztmp,qoz_R_GPIO_OUT1, leds);
+	/*
+	    gpio_10 0
+	    gpio_13 1
+	    gpio_15 2
+	    gpio_14 3
+	*/	    
+    } else if (qoztmp->type == 0xb55b) {
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x21); 
+    /* 0x01 g1 st1
+       0x02 g2 st2
+       0x04 g3 st3
+       0x08 g4 st4
+       0x10 r8 st5
+       0x20 r7 st6
+       0x40 r6 st7
+       0x80 r5 st8
+      */
+        if (qoztmp->leds[0] == 0) {
+		leds |= 0x01;
+        }
+        if (qoztmp->leds[1] == 0) {
+		leds |= 0x02;
+        }
+        if (qoztmp->leds[2] == 0) {
+		leds |= 0x04;
+        }
+        if (qoztmp->leds[3] == 0) {
+		leds |= 0x08;
+        }
+        if (qoztmp->leds[4] == 0) {
+		leds |= 0x10;
+        }
+        if (qoztmp->leds[5] == 0) {
+		leds |= 0x20;
+        }
+        if (qoztmp->leds[6] == 0) {
+		leds |= 0x40;
+        }
+        if (qoztmp->leds[7] == 0) {
+		leds |= 0x80;
+        }
+
+	ledw = leds << 24 | leds << 16 | leds << 8 | leds;
+	
+	qoz_outdw_io(qoztmp,0x4000, ledw);
+
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+
+    }
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+}
+
+void qoz_doWD(struct qoz_card *qoztmp) {
+    unsigned long flags;
+    if (!qoztmp->wdp) {
+	return;
+    }
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x21); 
+	if (qoztmp->wdp == 1) {
+	    qoz_outdw_io(qoztmp,0x4000, qoz_WD_P2);
+	    qoztmp->wdp = 2;
+	} else {
+	    qoz_outdw_io(qoztmp,0x4000, qoz_WD_P1);
+	    qoztmp->wdp = 1;
+	}
+	qoz_inb_io(qoztmp,qoz_R_CHIP_ID);    
+    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+}
+
+void qoz_undoWD(struct qoz_card *qoztmp) {
+    unsigned long flags;
+
+    if (qoztmp->wdp) {
+	printk(KERN_INFO "qozap: Stopping hardware watchdog.\n");
+	spin_lock_irqsave(&qoztmp->lock,flags);
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x21); 
+	qoz_outdw_io(qoztmp,0x4000, qoz_WD_P0);
+	qoztmp->wdp = 0;
+	qoz_inb_io(qoztmp,qoz_R_CHIP_ID);    
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	spin_unlock_irqrestore(&qoztmp->lock,flags);
+    }
+}
+
+void qoz_reset_pcm(struct qoz_card *qoztmp) {
+    qoz_outb(qoztmp,qoz_R_CIRM,0x20);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    if (pcmslave) {
+	qoz_outb(qoztmp,qoz_R_PCM_MD0, 0x90);
+	qoz_outb(qoztmp,qoz_R_PCM_MD1, 0x20);
+	qoz_outb(qoztmp,qoz_R_PCM_MD0, 0xA0);
+	qoz_outb(qoztmp,qoz_R_PCM_MD2, 0x4 | 0x8);
+    } else {
+	qoz_outb(qoztmp,qoz_R_PCM_MD0, 0x91);
+	qoz_outb(qoztmp,qoz_R_PCM_MD1, 0x20);
+    }
+}
+
+void qoz_resetCard(struct qoz_card *qoztmp) {
+    unsigned long flags;
+    spin_lock_irqsave(&(qoztmp->lock),flags);
+    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+    
+    // soft reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x8);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    qoz_reset_pcm(qoztmp);
+
+    // fifo reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x10);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    // s/t reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x40);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    /* set S0 amplitude */
+    qoz_outb(qoztmp,qoz_R_PWM_MD,0xa0);
+    if (qoztmp->type == 0xb552) {
+	qoz_outb(qoztmp,qoz_R_PWM0,0x19);
+    } else if (qoztmp->type == 0xb55b) {
+	qoz_outb(qoztmp,qoz_R_PWM0,0x19);
+    } else {
+	qoz_outb(qoztmp,qoz_R_PWM0,0x1E);
+    }
+
+    /* set up the timer */
+    qoz_outb(qoztmp,qoz_R_TI_WD, 0x2); 
+    qoz_outb(qoztmp,qoz_R_IRQMSK_MISC, 0x2); 
+
+
+    /* all state changes */
+    qoz_outb(qoztmp,qoz_R_SCI_MSK, 0xff); 
+
+    if (qoztmp->type == 0xb552) {
+        qoz_outb(qoztmp,qoz_R_FIFO_MD,0x16);
+    } else if (qoztmp->type == 0xb55b) {
+        qoz_outb(qoztmp,qoz_R_FIFO_MD,0x16);
+    } else {
+        qoz_outb(qoztmp,qoz_R_FIFO_MD,0x26);
+    }
+
+    // double clock
+    if (doubleclock == 1) {
+	// hopefully you have set CLK_MODE correctly!
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+    } else {
+	if (qoztmp->type == 0x08b4) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x0); 
+	} else if (qoztmp->type == 0xb550) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb556) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb559) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb558) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb520) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb752) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else if (qoztmp->type == 0xb751) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	} else {
+	    /* you are on your own here! */
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	}
+    }
+    qoz_outb(qoztmp,qoz_R_CTRL,0x0); 
+
+    /* R0 G1 */
+    qoztmp->leds[0] = 0x0;
+    qoztmp->leds[1] = 0x0;
+    qoztmp->leds[2] = 0x0;
+    qoztmp->leds[3] = 0x0;
+    qoztmp->leds[4] = 0x0;
+    qoztmp->leds[5] = 0x0;
+    qoztmp->leds[6] = 0x0;
+    qoztmp->leds[7] = 0x0;
+
+    if (qoztmp->type == 0xb552) {
+	qoztmp->stports = 8;
+    } else if (qoztmp->type == 0xb55b) {
+	qoztmp->stports = 8;
+    } else if (qoztmp->type == 0xb556) {
+	qoztmp->stports = 2;
+    } else if (qoztmp->type == 0xb559) {
+	qoztmp->stports = 2;
+    } else if (qoztmp->type == 0xb751) {
+	qoztmp->stports = 2;
+    } else {
+	qoztmp->stports = 4;
+    }
+    qoztmp->ticks = 0;
+    qoztmp->clicks = 0;
+    if ((qoztmp->type == 0xb550) || (qoztmp->type == 0xb556)) {
+	printk(KERN_INFO "qozap: Starting hardware watchdog.\n");
+	qoztmp->wdp = 2;
+    } else {
+	qoztmp->wdp = 0;
+    }
+
+    qoz_outb(qoztmp,qoz_R_ST_SYNC,0x0);
+
+    /* IRQs off */
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+    
+    spin_unlock_irqrestore(&(qoztmp->lock),flags);
+}
+
+void qoz_registerCard(struct qoz_card *qozcard) {
+    struct qoz_card *tmpcard = NULL;
+    spin_lock(&registerlock);
+
+    if (qozcard != NULL) {
+	if (!sort) {
+	    tmpcard = qoz_dev_list;
+	    if (tmpcard) {
+		while (tmpcard->next) {
+		    tmpcard = tmpcard->next;
+		}
+		tmpcard->next = qozcard;
+		qozcard->prev = tmpcard;
+	    } else {
+		qoz_dev_list = qozcard;
+	    }
+	} else {
+	    qozcard->prev = NULL;
+	    qozcard->next = qoz_dev_list;
+	    if (qoz_dev_list) {
+		qoz_dev_list->prev = qozcard;
+	    }
+	    qoz_dev_list = qozcard;
+	}
+	qozcard->cardno = ++qoz_dev_count;
+    } else {
+	printk(KERN_INFO "qozap: trying to register NULL card.\n");
+    }
+    spin_unlock(&registerlock);
+}
+
+static int qoz_dfifo_tx(struct qoz_card *qoztmp, int stport) {
+    int chan = 2;
+    int x=0;
+    char fifo = 0;
+    char offset = 0;
+    unsigned long flags;
+
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else if (qoztmp->type == 0xb55b) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    fifo = stport + offset;
+
+    if (qoztmp->chans[stport][chan].bytes2transmit < 1) {
+	return 0;
+    } else {
+	spin_lock_irqsave(&qoztmp->lock,flags);
+	/* select fifo */
+	qoz_outb(qoztmp,qoz_R_FIFO,fifo << 1);    
+	qoz_waitbusy(qoztmp);
+    
+	if (debug > 1)
+	    printk(KERN_INFO "qozap: card %d stport %d TX [ ", qoztmp->cardno, stport + 1);
+	/* copy frame to fifo */
+    	for (x=0;x<qoztmp->chans[stport][chan].bytes2transmit;x++) {
+	    if (debug > 1)
+	        printk("%#x ",qoztmp->dtxbuf[stport][x]);
+    	    qoz_outb(qoztmp,qoz_A_FIFO_DATA0,qoztmp->dtxbuf[stport][x]);
+	}
+	if (debug > 1)
+	    printk("] %d bytes\n",qoztmp->chans[stport][chan].bytes2transmit);
+
+	if (qoztmp->chans[stport][chan].eoftx == 1) {
+	    /* transmit HDLC frame */
+    	    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x1);    
+    	    qoz_waitbusy(qoztmp);
+	}
+	spin_unlock_irqrestore(&qoztmp->lock,flags);
+    }
+    return 0;
+}
+
+static int qoz_fifo_tx(struct qoz_card *qoztmp, char fifo) {
+    int stport = fifo / 2;
+    int chan = fifo % 2;
+    unsigned long flags;
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    /* select fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,0x80 | (fifo << 1));    
+    qoz_waitbusy(qoztmp);
+    /* transmit 8 bytes of transparent data */
+    qoz_outdw(qoztmp,qoz_A_FIFO_DATA0,*((unsigned int *) &qoztmp->txbuf[stport][chan][0]));
+    qoz_outdw(qoztmp,qoz_A_FIFO_DATA0,*((unsigned int *) &qoztmp->txbuf[stport][chan][4]));
+	    
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+    return 0;
+}
+
+static int qoz_dfifo_rx(struct qoz_card *qoztmp, int stport) {
+    unsigned char f1=1,f2=1,data,stat;
+    unsigned char of1=0,of2=0;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    char fifo = 0;
+    char offset = 0;
+    unsigned long flags;
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else if (qoztmp->type == 0xb55b) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    fifo = stport + offset;
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    // select rx fifo
+    qoz_outb(qoztmp,qoz_R_FIFO,(fifo << 1) | 1);    
+    qoz_waitbusy(qoztmp);
+
+    while ((of1 != f1) && (of2 != f2)) {
+        of1 = f1;
+        of2 = f2;
+        f1 = qoz_inb(qoztmp,qoz_A_F1) & 0xf;
+        f2 = qoz_inb(qoztmp,qoz_A_F2) & 0xf;
+    }
+    
+    if (f1 == f2) {
+	/* no frame */
+	qoztmp->st[stport].drx--;
+	qoztmp->chans[stport][2].bytes2receive = 0;
+	spin_unlock_irqrestore(&qoztmp->lock,flags);
+	return 0;
+    }
+    
+    while ((oz1 != z1) && (oz2 != z2)) {
+        oz1 = z1;
+        oz2 = z2;
+	if ((qoztmp->type != 0xb552) && (qoztmp->type != 0xb55b)){
+    	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x7ff;
+	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x7ff;
+	} else {
+    	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x3ff;
+	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x3ff;
+	}
+    }
+    
+    if ((qoztmp->type == 0xb552)|| (qoztmp->type == 0xb55b)) {
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_DFIFO_SIZE8;
+	}
+    } else {
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_DFIFO_SIZE4;
+	}
+    }
+
+    if (len > qoz_DFIFO_SIZE4) {
+	printk(KERN_INFO "\nqozap: buffer overflow in D channel RX!\n");
+	qoztmp->chans[stport][2].bytes2receive = 0;
+	qoztmp->chans[stport][2].eofrx = 0;
+    } else {
+	if (debug > 1) printk(KERN_INFO "qozap: card %d span %d RX [ ", qoztmp->cardno, stport + 1);
+	for (i=0; i<len; i++) {
+    	    data = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+	    qoztmp->drxbuf[stport][i] = data;
+	    if (debug > 1) printk("%#x ",data);
+	}
+	if (debug > 1) printk("] %d bytes\n", len);
+	qoztmp->chans[stport][2].bytes2receive = i;
+	qoztmp->chans[stport][2].eofrx = 1;
+    }
+
+    stat = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+    if (stat != 0x0) {
+	// bad CRC, skip it
+	printk(KERN_INFO "qozap: CRC error for HDLC frame on card %d (cardID %d) S/T port %d\n",qoztmp->cardno, qoztmp->cardID, stport+1);
+	qoztmp->chans[stport][2].bytes2receive = 0;
+	qoztmp->chans[stport][2].eofrx = 0;
+//        zt_qevent_nolock(&qoztmp->chans[stport][2], ZT_EVENT_BADFCS);
+    }
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x1);    
+    qoz_waitbusy(qoztmp);
+
+    /* frame recevived */
+    if (qoztmp->st[stport].drx > 0) { 
+	qoztmp->st[stport].drx--;
+    } else {
+	printk(KERN_INFO "qozap: trying to receive too much (card %d span %d drx %d)\n", qoztmp->cardno, stport+1, qoztmp->st[stport].drx);
+	qoztmp->st[stport].drx = 0;
+    }
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+    return 0;
+}
+
+
+static int qoz_fifo_rx(struct qoz_card *qoztmp, char fifo) {
+    int stport = fifo / 2;
+    int chan = fifo % 2;
+    unsigned char data;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    int mumbojumbo=0;
+    unsigned long flags;
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+
+        /* select rx fifo */
+	qoz_outb(qoztmp,qoz_R_FIFO,0x80 | (fifo << 1) | 1);    
+        qoz_waitbusy(qoztmp);
+    
+	while ((oz1 != z1) && (oz2 != z2)) {
+	    oz1 = z1;
+	    oz2 = z2;
+	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x7f;
+    	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x7f;
+	}
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_FIFO_SIZE;
+	}
+	if (len > 2 * ZT_CHUNKSIZE) {
+	    mumbojumbo = len - (2 * ZT_CHUNKSIZE);
+	    len = ZT_CHUNKSIZE;
+	    for (i=0;i<mumbojumbo;i++) {
+    		data = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+	    }
+	    qoztmp->clicks++;
+	    if (((qoztmp->clicks > 50) || (debug > 5)) && (mumbojumbo > 0)) {
+		printk(KERN_CRIT "qozap: dropped audio card %d cardid %d bytes %d z1 %d z2 %d fifo %d\n", qoztmp->cardno, qoztmp->cardID, mumbojumbo, z1, z2, fifo);
+		qoztmp->clicks = 0;
+	    }
+	}
+
+
+	if (len < ZT_CHUNKSIZE) {
+//	    printk(KERN_INFO "qozap: not enough to receive (%d bytes)\n",len);
+	    spin_unlock_irqrestore(&qoztmp->lock,flags);
+	    return 0;
+	} else {
+	    if (bloop) {
+		*((unsigned int *) &qoztmp->txbuf[stport][chan][0]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	        *((unsigned int *) &qoztmp->txbuf[stport][chan][4]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	    } else {
+		*((unsigned int *) &qoztmp->rxbuf[stport][chan][0]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	        *((unsigned int *) &qoztmp->rxbuf[stport][chan][4]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	    }
+	}
+
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+	if (bloop == 0)
+	    zt_ec_chunk(&qoztmp->spans[stport].chans[chan], qoztmp->spans[stport].chans[chan].readchunk, qoztmp->spans[stport].chans[chan].writechunk);
+
+//    printk(KERN_INFO "s/t port %d, channel %d, dbufi=%d, f1=%d, f2=%d, z1=%d, z2=%d  => len = %d stat=%#x, hdlc=%d\n",stport,chan,qoztmp->st[stport].dbufi,f1,f2,z1,z2,len,stat,hdlc);    
+    return 0;
+}
+
+static void qoz_assign(struct qoz_card *qoztmp, int src_span, int src_chan, int dst_span, int dst_chan, int timeslot, int use_pcm_bus) {
+    unsigned long flags;
+    int dst_fifo = dst_span * 2 + (dst_chan - 1); 
+    int src_fifo = src_span * 2 + (src_chan - 1); 
+    int src_hfc_chan = src_span * 4 + (src_chan - 1);
+    int dst_hfc_chan = dst_span * 4 + (dst_chan - 1);
+
+    spin_lock_irqsave(&qoztmp->lock, flags);
+
+    qoz_outb(qoztmp,qoz_R_FIFO,(src_fifo << 1) | 1); 
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(src_hfc_chan << 1) | 1); 
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xDE); // was c2
+
+    qoz_outb(qoztmp,qoz_R_SLOT,timeslot << 1);
+    qoz_outb(qoztmp,qoz_A_SL_CFG, (src_hfc_chan << 1) | 0 | 0x40);
+
+    qoz_outb(qoztmp,qoz_R_FIFO, dst_fifo << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,dst_hfc_chan << 1);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xDE); // was c2
+    
+    qoz_outb(qoztmp,qoz_R_SLOT,(timeslot << 1) | 1); 
+    qoz_outb(qoztmp,qoz_A_SL_CFG, (dst_hfc_chan << 1) | 1 | 0x40);
+
+    spin_unlock_irqrestore(&qoztmp->lock, flags);
+}
+
+static void qoz_unassign(struct qoz_card *qoztmp, int span, int chan, int timeslot) {
+    unsigned long flags;
+
+//    int timeslot = span * 2 + (chan - 1);
+    int fifo = span * 2 + (chan - 1);
+    int hfc_chan = span * 4 + (chan - 1);
+
+    spin_lock_irqsave(&qoztmp->lock, flags);
+
+    qoz_outb(qoztmp,qoz_R_FIFO,(fifo << 1));
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x02);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(hfc_chan << 1)); 
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    qoz_outb(qoztmp,qoz_R_FIFO,(fifo << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x02);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(hfc_chan << 1) | 1); 
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    qoz_outb(qoztmp,qoz_R_SLOT,(timeslot << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_SL_CFG, 0x0);
+
+    qoz_outb(qoztmp,qoz_R_SLOT,timeslot << 1);
+    qoz_outb(qoztmp,qoz_A_SL_CFG, 0x0);
+
+    spin_unlock_irqrestore(&qoztmp->lock, flags);
+}
+
+
+static int ztqoz_dacs(struct zt_chan *dst, struct zt_chan *src)
+{
+	struct qoz_card *qoztmp = NULL;
+	int use_pcm_bus = 0;
+	int timeslot = 0;
+	if (!dacs) return -1;
+
+	if (src) {
+	    qoztmp = src->pvt;
+
+	    if (src->pvt != dst->pvt) {
+		if (dacs == 2) {
+		    use_pcm_bus = 1;
+		    timeslot = src->channo;
+		    if (debug)
+			printk("qozap: Assigning channel %d/%d -> %d/%d, timeslot %d, different cards!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos, timeslot);
+		} else {
+		    if (debug)
+			printk("qozap: Not Assigning %d/%d -> %d/%d, different cards!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+		    return -1;
+		}
+	    } else {
+		use_pcm_bus = 0;
+//		timeslot = src->span->offset * 2 + (src->chanpos);
+		timeslot = src->channo;
+	        if (debug)
+	    	    printk("qozap: Assigning channel %d/%d -> %d/%d, timeslot %d, same card!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos, timeslot);
+	    }
+
+	    if ((src->chanpos == 3) || (dst->chanpos == 3)) {
+	        if (debug)
+			printk("qozap: Not Assigning D-channel %d/%d -> %d/%d!\n", src->span->offset, src->chanpos, dst->span->offset, dst->chanpos);
+	    } else {
+		qoz_assign(qoztmp, src->span->offset, src->chanpos, dst->span->offset, dst->chanpos, timeslot, use_pcm_bus);
+	    }
+	} else {
+		qoztmp = dst->pvt;
+		if (dst->chanpos == 3) {
+		    if (debug)
+			printk("qozap: Not Unassigning D-channel %d/%d!\n", dst->span->offset, dst->chanpos);
+		} else {
+		    timeslot = dst->channo;
+		    qoz_unassign(qoztmp, dst->span->offset, dst->chanpos, timeslot);
+		    if (debug)
+			printk("qozap: Unassigning channel %d/%d, timeslot %d!\n", dst->span->offset, dst->chanpos, timeslot);
+		}
+	}
+	return 0;
+}
+
+static void qoz_resync(struct qoz_card *qoztmp) {
+    int i=0;
+    int best=9999;
+    int src=-1;
+
+    if (pcmslave) return;
+
+    for (i=0; i<qoztmp->stports; i++){
+	if (qoztmp->st[i].l1up && (qoztmp->st_sync[i] > 0) && (qoztmp->st_sync[i] < best)) {
+	    best = qoztmp->st_sync[i];
+	    src = i;
+	}
+    }
+    if (src < 0) {
+	for (i=0; i<qoztmp->stports; i++){
+	    if ((qoztmp->st_sync[i] > 0) && (qoztmp->st_sync[i] < best)) {
+		best = qoztmp->st_sync[i];
+	        src = i;
+	    }
+	}
+    }
+    if (src == qoztmp->syncsrc)
+	return;
+    if (src >= 0) {
+	qoztmp->syncsrc = src;
+	qoz_outb(qoztmp, qoz_R_ST_SYNC, src | 0x08);
+	if (debug > 2)
+	    printk(KERN_INFO "qozap: card %d Sync source changed to span %d\n", qoztmp->cardno, src + 1);
+    }
+}
+
+static inline void qoz_run(struct qoz_card *qoztmp) {
+    int s=0;
+    unsigned long flags;
+
+    for (s=0;s<qoztmp->stports;s++) {
+	if (!bloop) {
+	    if (qoztmp->spans[s].flags & ZT_FLAG_RUNNING) {
+		/* oh zaptel! tell us what to transmit... */
+    		zt_transmit(&qoztmp->spans[s]);
+	        /* B1 xmit */
+		qoz_fifo_tx(qoztmp, s * 2);
+		/* B2 xmit */
+		qoz_fifo_tx(qoztmp, (s * 2) + 1);
+
+		if ((qoztmp->st[s].layer1state != 7) && (qoztmp->chans[s][2].bytes2transmit > 0) && (qoztmp->st[s].nt_mode != 1)) {
+		    if (qoztmp->st[s].t3 == -1) {
+			if (debug > 2)
+			    printk(KERN_INFO "qozap: activating layer 1, span %d\n",s);
+			qoztmp->st[s].t3 = 0;
+			spin_lock_irqsave(&qoztmp->lock,flags);
+			    qoz_outb(qoztmp,qoz_R_ST_SEL, s);
+			    qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60); 
+			spin_unlock_irqrestore(&qoztmp->lock, flags);
+		    } else {
+		    }
+		}
+		
+		/* D xmit */
+		if (qoztmp->spans[s].alarms != ZT_ALARM_RED) {
+		    qoz_dfifo_tx(qoztmp, s);
+		} else {
+		    if ((qoztmp->st[s].t3 == -1) && (qoztmp->st[s].t4 == -1) && (qoztmp->st[s].layer1state == 3) && (qoztmp->st[s].nt_mode != 1)) {
+			/* clear alarms */
+			if (debug > 2)
+			    printk(KERN_INFO "qozap: clearing alarms on span %d\n",s);
+			qoztmp->spans[s].alarms = ZT_ALARM_NONE;
+			zt_alarm_notify_no_master_change(&qoztmp->spans[s]);
+		    }
+		}
+
+		qoztmp->chans[s][2].bytes2receive = 0;
+		qoztmp->chans[s][2].bytes2transmit = 0;
+		qoztmp->chans[s][2].eofrx = 0;
+		qoztmp->chans[s][2].eoftx = 0;
+
+	    }
+
+	    /* B1 receive */
+	    qoz_fifo_rx(qoztmp,(s*2));
+	    /* B2 receive */
+	    qoz_fifo_rx(qoztmp,(s*2)+1);
+	    /* d-chan data */
+	    if (qoztmp->st[s].drx > 0) {
+	        if (debug > 2)
+		    printk(KERN_CRIT "qozap: card %d st[%d].drx = %d\n", qoztmp->cardno, s, qoztmp->st[s].drx);
+		qoz_dfifo_rx(qoztmp, s);
+	    }
+	    if (qoztmp->spans[s].flags & ZT_FLAG_RUNNING) {
+	        /* oh zaptel! thou shall receive! */
+		zt_receive(&(qoztmp->spans[s]));
+	    }
+	} else {
+	    // loop
+	    /* B1 receive */
+	    qoz_fifo_rx(qoztmp,(s*2));
+	    /* B2 receive */
+	    qoz_fifo_rx(qoztmp,(s*2)+1);
+	    /* d-chan data */
+/*	    if (qoztmp->st[s].drx > 0) {
+	        if (debug > 2)
+		    printk(KERN_CRIT "qozap: card %d st[%d].drx = %d\n", qoztmp->cardno, s, qoztmp->st[s].drx);
+		qoz_dfifo_rx(qoztmp, s);
+	    } 
+	    if (qoztmp->spans[s].flags & ZT_FLAG_RUNNING) {
+		zt_receive(&(qoztmp->spans[s]));
+	    }
+*/
+	    if (qoztmp->spans[s].flags & ZT_FLAG_RUNNING) {
+		/* oh zaptel! tell us what to transmit... */
+    	//	zt_transmit(&qoztmp->spans[s]);
+	        /* B1 xmit */
+		qoz_fifo_tx(qoztmp, s * 2);
+		/* B2 xmit */
+		qoz_fifo_tx(qoztmp, (s * 2) + 1);
+		/* D xmit */
+//		qoz_dfifo_tx(qoztmp, s);
+
+		qoztmp->chans[s][2].bytes2receive = 0;
+		qoztmp->chans[s][2].bytes2transmit = 0;
+		qoztmp->chans[s][2].eofrx = 0;
+		qoztmp->chans[s][2].eoftx = 0;
+
+	    }
+	}
+    } 
+}
+
+ZAP_IRQ_HANDLER(qoz_interrupt) {
+    struct qoz_card *qoztmp = dev_id;
+    unsigned long flags;
+    unsigned char irq_misc,irq_sci,status,l1state,irq_foview,fi;
+    int st=0,i=0,offset=0;
+    int j=0;
+
+    if (!qoztmp) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    if ((!qoztmp->pci_io) || (!qoztmp->ioport)) {
+	    printk(KERN_CRIT "qozap: no pci mem/io\n");
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    if (qoztmp->dead) {
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#else
+	return;
+#endif		
+    }
+
+    
+    spin_lock_irqsave(&(qoztmp->lock), flags);
+	status = qoz_inb(qoztmp,qoz_R_STATUS);
+	irq_sci = qoz_inb(qoztmp,qoz_R_SCI);
+    spin_unlock_irqrestore(&(qoztmp->lock), flags);
+
+    if (!(status & 0x80) && !(status & 0x40) && (irq_sci == 0)) {
+//	printk(KERN_CRIT "qozap: status %#x\n", status);
+	// it's not us!
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    /* state machine irq */
+    if (irq_sci != 0) {
+	if (debug > 1) {
+	    printk(KERN_INFO "qozap: card %d R_BERT_STA = %#x\n", qoztmp->cardno, qoz_inb(qoztmp, qoz_R_BERT_STA) & 7);
+	}
+	if (qoztmp->type == 0xb552) {
+	    offset = 24;
+	} else if (qoztmp->type == 0xb55b) {
+	    offset = 24;
+        } else {
+	    offset = 28;
+	}
+	spin_lock_irqsave(&(qoztmp->lock), flags);
+	for (st=0;st<qoztmp->stports;st++) {
+	    if (irq_sci & (1 << st)) {
+		qoz_outb(qoztmp,qoz_R_ST_SEL,st);
+		l1state = qoz_inb(qoztmp,qoz_A_ST_RD_STA) & 0xf;
+		if (debug > 1) {
+		    printk(KERN_INFO "qozap: card %d span %d A_ST_RD_STA = %#x\n", qoztmp->cardno, st+1, qoz_inb(qoztmp, qoz_A_ST_RD_STA));
+		}
+		qoztmp->st[st].layer1state = l1state;
+		if (qoztmp->st[st].nt_mode == 1) {
+		    if (debug)
+			printk(KERN_INFO "card %d span %d state G%d (A_ST_RD_STA = %#x)\n",qoztmp->cardno,st+1,l1state,qoz_inb(qoztmp,qoz_A_ST_RD_STA));
+		    // NT state machine
+		    if (l1state == 3) {
+			qoztmp->st[st].l1up = 1;
+			// keep layer1 up!
+			if (qoztmp->stports == 8) {
+			    sprintf(qoztmp->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [NT] Layer 1 ACTIVATED (G%d)",qoztmp->cardno ,st + 1, l1state);
+			} else if (qoztmp->stports == 2) {
+			    sprintf(qoztmp->spans[st].desc,"duoBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 ACTIVATED (G%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			} else{
+			    sprintf(qoztmp->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 ACTIVATED (G%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			}
+			qoz_outb(qoztmp,qoz_A_ST_WR_STA,3 | 0x10 );
+			qoztmp->leds[st] = 1;
+		    } else {
+			qoztmp->st[st].l1up = 0;
+			if (qoztmp->stports == 8) {
+			    sprintf(qoztmp->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [NT] Layer 1 DEACTIVATED (G%d)",qoztmp->cardno ,st + 1, l1state);
+			} else if (qoztmp->stports == 2) {
+			    sprintf(qoztmp->spans[st].desc,"duoBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 DEACTIVATED (G%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			} else {
+			    sprintf(qoztmp->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 DEACTIVATED (G%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			}
+			qoztmp->leds[st] = 0;
+		    }
+		} else {
+		    if (debug)
+			printk(KERN_INFO "card %d span %d state F%d (A_ST_RD_STA = %#x)\n",qoztmp->cardno,st+1,l1state,qoz_inb(qoztmp,qoz_A_ST_RD_STA));
+		    // TE state machine
+		    if (l1state == 3) {
+			qoztmp->st[st].l1up = 0;
+			if (qoztmp->st[st].t3 > -1)  {
+			    /* keep layer1 up, if the span is started. */
+			    if (qoztmp->spans[st].flags & ZT_FLAG_RUNNING) {
+				if (debug > 2) 
+				    printk("qozap: re-activating layer1 span %d\n", st);
+    				qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60);
+			    }
+			} else {
+				if (debug > 2) 
+				    printk("qozap: not re-activating layer1 span %d\n", st);
+    				qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x40);
+			    /* if we tried to activate layer 1 and it failed make this an alarm */
+//			    qoztmp->spans[st].alarms = ZT_ALARM_RED;
+//			    zt_alarm_notify(&qoztmp->spans[st]);
+			    /* if the network shuts us down in idle mode dont make this an alarm */
+			}
+			qoztmp->leds[st] = 0;
+			if (qoztmp->stports == 8) {
+			    sprintf(qoztmp->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else if (qoztmp->stports == 2) {
+			    sprintf(qoztmp->spans[st].desc,"duoBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			} else {
+			    sprintf(qoztmp->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			}
+		    } else if (l1state == 7) {
+			qoztmp->st[st].l1up = 1;
+			/* reset D RX fifo */
+			qoz_outb(qoztmp,qoz_R_FIFO,((st + offset) << 1) | 1);
+			qoz_waitbusy(qoztmp);
+			qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+			qoz_waitbusy(qoztmp);
+			/* activation complete, stop timer t3 */
+			qoztmp->st[st].t3 = -1;
+			qoztmp->spans[st].alarms = ZT_ALARM_NONE;
+			zt_alarm_notify(&qoztmp->spans[st]);
+			qoztmp->leds[st] = 1;
+			if (qoztmp->stports == 8) {
+			    sprintf(qoztmp->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 ACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else if (qoztmp->stports == 2) {
+			    sprintf(qoztmp->spans[st].desc,"duoBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 ACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			} else {
+			    sprintf(qoztmp->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 ACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			}
+		    } else if (l1state == 8) {
+			/* lost framing */
+			if (debug > 2)
+			    printk(KERN_INFO "qozap: starting t4 for span %d\n", st);
+			qoztmp->st[st].t4 = 0;
+		    } else {
+			qoztmp->st[st].l1up = 0;
+			qoztmp->leds[st] = 0;
+			if (qoztmp->stports == 8) {
+			    sprintf(qoztmp->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else if (qoztmp->stports == 2) {
+			    sprintf(qoztmp->spans[st].desc,"duoBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			} else {
+			    sprintf(qoztmp->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,qoztmp->cardID, l1state);
+			}    
+		    }
+		}
+		
+	    }
+	}
+	qoz_resync(qoztmp);
+	spin_unlock_irqrestore(&(qoztmp->lock), flags);
+    }
+
+
+    // misc irq
+    if (status & 0x40) {
+	spin_lock_irqsave(&(qoztmp->lock), flags);
+	    irq_misc = qoz_inb(qoztmp,qoz_R_IRQ_MISC);
+	spin_unlock_irqrestore(&(qoztmp->lock), flags);
+	if (irq_misc & 0x2)  {
+	    // qozap timer
+	    qoztmp->ticks++;
+	    qoz_run(qoztmp);
+	    if (qoztmp->ticks % 100) {
+		qoz_doLEDs(qoztmp);
+	    }
+    	    if (qoztmp->ticks % 40) { 
+		/* you thought that 42 was the answer.... */
+		qoz_doWD(qoztmp);
+	    }
+	    if (qoztmp->ticks > 1000) {
+		qoztmp->ticks = 0;
+		for (j=0;j<qoztmp->stports;j++) {
+		    /* t3 */
+		    if (qoztmp->st[j].t3 >= 0) {
+			qoztmp->st[j].t3++;
+		    }
+		    if (qoztmp->st[j].nt_mode != 1) {
+			if ((qoztmp->st[j].t3 > qoz_T3) && (qoztmp->st[j].layer1state != 7)) {
+			    /* deactivate layer 1 */
+			    if (debug > 2)
+				printk(KERN_INFO "qozap: t3 timer expired for span %d\n", j);
+			    spin_lock_irqsave(&(qoztmp->lock), flags);
+				qoz_outb(qoztmp,qoz_R_ST_SEL, j);
+				qoz_outb(qoztmp,qoz_A_ST_WR_STA, 0x40 );
+				qoz_waitbusy(qoztmp);
+				qoztmp->st[j].t3 = -1;
+				qoztmp->spans[j].alarms = ZT_ALARM_RED;
+			    spin_unlock_irqrestore(&(qoztmp->lock), flags);
+			    zt_alarm_notify_no_master_change(&qoztmp->spans[j]);
+			}
+		    }
+		    /* t4 */
+		    if (qoztmp->st[j].t4 >= 0) {
+			qoztmp->st[j].t4++;
+		    }
+		    if (qoztmp->st[j].nt_mode != 1) {
+			if ((qoztmp->st[j].t4 > qoz_T4) && (qoztmp->st[j].layer1state != 7)) {
+			    /* deactivate layer 1 */
+			    if (debug > 2)
+				printk(KERN_INFO "qozap: t4 timer expired for span %d\n", j);
+			    spin_lock_irqsave(&(qoztmp->lock), flags);
+				qoz_outb(qoztmp,qoz_R_ST_SEL, j);
+				qoz_outb(qoztmp,qoz_A_ST_WR_STA, 0x40 );
+				qoztmp->st[j].t4 = -1;
+				qoztmp->st[st].l1up = 0;
+				qoztmp->spans[j].alarms = ZT_ALARM_RED;
+				qoz_waitbusy(qoztmp);
+			    spin_unlock_irqrestore(&(qoztmp->lock), flags);
+			    zt_alarm_notify_no_master_change(&qoztmp->spans[j]);
+			}
+		    }
+		}
+	    }
+	}
+	if (irq_misc & 0x4) {
+	//    printk(KERN_INFO "qozap proc/nonproc irq\n");
+	}
+    }
+
+    if (status & 0x80) {
+	/* fifo irq */
+	spin_lock_irqsave(&(qoztmp->lock), flags);
+	irq_foview = qoz_inb(qoztmp,qoz_R_IRQ_OVIEW);
+        if ((qoztmp->type == 0xb552) || (qoztmp->type == 0xb55b)) {
+	    if (irq_foview & 0x60) {
+		offset = 0;
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL6);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = offset + (i / 2);
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	    if (irq_foview & 0x80) {
+		offset = 4;
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL7);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = offset + (i / 2);
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	} else {
+	    if (irq_foview & 0x80) {
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL7);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = i / 2;
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	}
+	spin_unlock_irqrestore(&(qoztmp->lock), flags);
+    }
+    
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+static int ztqoz_open(struct zt_chan *chan) {
+//    printk(KERN_INFO "qozap: channel %d opened.\n",chan->channo);
+#ifndef LINUX26
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztqoz_close(struct zt_chan *chan) {
+//    printk(KERN_INFO "qozap: channel %d closed.\n",chan->channo);
+#ifndef LINUX26
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztqoz_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int ztqoz_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int ztqoz_startup(struct zt_span *span) {
+    struct qoz_card *qoztmp = span->pvt;
+    unsigned long flags;
+    int alreadyrunning;
+    int i=0;
+    int offset = 0;
+    
+    if (qoztmp == NULL) {
+	printk(KERN_INFO "qozap: no card for span at startup!\n");
+    }
+    
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+//    printk(KERN_CRIT "already running %d flags %d\n", alreadyrunning, span->flags);
+
+    if (!alreadyrunning) {
+	span->chans[2].flags &= ~ZT_FLAG_HDLC;
+	span->chans[2].flags |= ZT_FLAG_BRIDCHAN;
+    
+	/* setup B channel buffers (8 bytes each) */
+	for (i=0; i<2 ; i++) {
+	    memset(qoztmp->rxbuf[span->offset][i],0x0,sizeof(qoztmp->rxbuf[span->offset][i]));
+    	    span->chans[i].readchunk = qoztmp->rxbuf[span->offset][i];
+    	    memset(qoztmp->txbuf[span->offset][i],0x0,sizeof(qoztmp->txbuf[span->offset][i]));
+	    span->chans[i].writechunk = qoztmp->txbuf[span->offset][i];
+	}
+	/* setup D channel buffer */
+    	memset(qoztmp->dtxbuf[span->offset],0x0,sizeof(qoztmp->dtxbuf[span->offset]));
+	span->chans[2].writechunk = qoztmp->dtxbuf[span->offset];
+	qoztmp->chans[span->offset][2].maxbytes2transmit = sizeof(qoztmp->dtxbuf[span->offset]);
+
+	memset(qoztmp->drxbuf[span->offset],0x0,sizeof(qoztmp->drxbuf[span->offset]));
+    	span->chans[2].readchunk = qoztmp->drxbuf[span->offset];
+
+	span->flags |= ZT_FLAG_RUNNING;
+    } else {
+//	printk(KERN_CRIT "already running\n");
+	return 0;
+    }
+
+    if (pcmslave && !span->offset) {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((100 * HZ) / 1000);
+    }
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    if (pcmslave && !span->offset) {
+	if (debug) 
+	    printk(KERN_INFO "qozap: resetting PCM interface to slave mode\n");
+	qoz_reset_pcm(qoztmp);
+    }
+
+    // irqs off
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else if (qoztmp->type == 0xb55b) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    /* setup D-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset + offset) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xD);
+    qoz_outb(qoztmp,qoz_A_SUBCH_CFG,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) + 2) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup D-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset + offset) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xD);
+    qoz_outb(qoztmp,qoz_A_SUBCH_CFG,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(((span->offset * 4) + 2) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B1-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset * 2) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(span->offset * 4) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B1-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B2-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) + 1) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) + 1) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B2-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(((span->offset * 2) + 1) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((((span->offset) * 4) + 1) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    if (debug)
+        printk(KERN_INFO "qozap: starting card %d span %d/%d.\n",qoztmp->cardno,span->spanno,span->offset);
+    
+    /* activate layer 1 */
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	// NT mode
+	qoz_outb(qoztmp,qoz_A_ST_CTRL0,0x7);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL1,0x0);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL2,0x3);
+	qoz_outb(qoztmp,qoz_A_ST_CLK_DLY,0x60 | CLKDEL_NT);
+    } else {
+	// TE mode
+	qoz_outb(qoztmp,qoz_A_ST_CTRL0,0x3);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL1,0x0);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL2,0x3);
+	if (qoztmp->type == 0xb550) {
+	    qoz_outb(qoztmp,qoz_A_ST_CLK_DLY,CLKDEL_TE);
+	} else {
+	    qoz_outb(qoztmp,qoz_A_ST_CLK_DLY,CLKDEL_TE + 1);
+	}
+    }
+    qoztmp->st[span->offset].t3 = 0;
+    qoztmp->st[span->offset].t4 = -1;
+    
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x80); 
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x0); 
+    }
+
+
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60 | 0x80); // ACT, G2->G3 EN
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60); // start Activation
+    }
+
+    /* enable irqs */
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 8 | 1); 
+
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+    return 0;
+}
+
+static int ztqoz_shutdown(struct zt_span *span) {
+    unsigned long flags;
+    struct qoz_card *qoztmp = span->pvt;
+    int alreadyrunning;
+    int offset = 0;
+    
+    if (qoztmp == NULL) {
+	printk(KERN_CRIT "qozap: qoztmp == NULL!\n");
+	return 0;
+	
+    }
+
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	return 0;
+    }
+
+//    printk(KERN_CRIT "qozap: stopping card %d port %d.\n",qoztmp->cardno, span->offset + 1);
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    // turn off irqs for all fifos
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else if (qoztmp->type == 0xb55b) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    /* disable D TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset + offset) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable D RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset + offset) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B1 TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset * 2) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B1 RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B2 TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(((span->offset) * 2) + 1) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B2 RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((((span->offset) * 2) + 1) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0); 
+
+    span->flags &= ~ZT_FLAG_RUNNING;
+
+    /* Deactivate Layer 1 */
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x40); 
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x40);
+    }
+
+
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+//    printk(KERN_CRIT "qozap: card %d span %d/%d down.\n",qoztmp->cardno,span->spanno,span->offset);
+    return 0;
+}
+
+static int ztqoz_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int ztqoz_chanconfig(struct zt_chan *chan,int sigtype) {
+//    printk(KERN_INFO "chan_config sigtype=%d\n",sigtype);
+    return 0;
+}
+
+static int ztqoz_spanconfig(struct zt_span *span,struct zt_lineconfig *lc) {
+    struct qoz_card *qoztmp = span->pvt;
+    span->lineconfig = lc->lineconfig;
+    qoztmp->st_sync[span->offset] = lc->sync;
+    qoztmp->syncsrc = -1;
+    return 0;
+}
+
+static int ztqoz_initialize(struct qoz_card *qoztmp) {
+    int i=0,s=0;
+    
+    for (s=0; s < qoztmp->stports; s++) {
+	memset(&qoztmp->spans[s],0,sizeof(struct zt_span));
+	sprintf(qoztmp->spans[s].name,"ztqoz/%d/%d",qoztmp->cardno ,s + 1);
+	if (qoztmp->stports == 8) {
+	    if (qoztmp->st[s].nt_mode == 1){
+		sprintf(qoztmp->spans[s].desc,"octoBRI PCI ISDN Card %d Span %d [NT]",qoztmp->cardno,s + 1);
+	    } else {
+		sprintf(qoztmp->spans[s].desc,"octoBRI PCI ISDN Card %d Span %d [TE]",qoztmp->cardno,s + 1);
+	    }
+	} else 	if (qoztmp->stports == 2) {
+	    if (qoztmp->st[s].nt_mode == 1){
+		sprintf(qoztmp->spans[s].desc,"duoBRI PCI ISDN Card %d Span %d [NT]",qoztmp->cardno,s + 1);
+	    } else {
+		sprintf(qoztmp->spans[s].desc,"duoBRI PCI ISDN Card %d Span %d [TE]",qoztmp->cardno,s + 1);
+	    }
+	} else {
+	    if (qoztmp->cardID < 0xff) {
+		if (qoztmp->st[s].nt_mode == 1){
+		    sprintf(qoztmp->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d)",qoztmp->cardno,s + 1,qoztmp->cardID);
+		} else {
+		    sprintf(qoztmp->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d)",qoztmp->cardno,s + 1,qoztmp->cardID);
+		}
+	    } else {
+		if (qoztmp->st[s].nt_mode == 1){
+		    sprintf(qoztmp->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [NT]",qoztmp->cardno,s + 1);
+		} else {
+		    sprintf(qoztmp->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [TE]",qoztmp->cardno,s + 1);
+		}
+	    }
+	}
+
+        qoztmp->spans[s].spanconfig = ztqoz_spanconfig;
+        qoztmp->spans[s].chanconfig = ztqoz_chanconfig;
+        qoztmp->spans[s].startup = ztqoz_startup;
+        qoztmp->spans[s].shutdown = ztqoz_shutdown;
+        qoztmp->spans[s].maint = ztqoz_maint;
+        qoztmp->spans[s].rbsbits = ztqoz_rbsbits;
+        qoztmp->spans[s].open = ztqoz_open;
+        qoztmp->spans[s].close = ztqoz_close;
+        qoztmp->spans[s].ioctl = ztqoz_ioctl;
+	qoztmp->spans[s].dacs = ztqoz_dacs;
+
+        qoztmp->spans[s].chans = qoztmp->chans[s];
+        qoztmp->spans[s].channels = 3;
+        qoztmp->spans[s].deflaw = ZT_LAW_ALAW;
+        qoztmp->spans[s].linecompat = ZT_CONFIG_AMI | ZT_CONFIG_CCS;
+        init_waitqueue_head(&qoztmp->spans[s].maintq);
+        qoztmp->spans[s].pvt = qoztmp;
+        qoztmp->spans[s].offset = s;
+
+	for (i=0; i < qoztmp->spans[s].channels; i++) {
+	    memset(&(qoztmp->chans[s][i]),0x0,sizeof(struct zt_chan));
+	    sprintf(qoztmp->chans[s][i].name,"ztqoz%d/%d/%d",qoztmp->cardno,s + 1,i + 1);
+	    qoztmp->chans[s][i].pvt = qoztmp;
+	    qoztmp->chans[s][i].sigcap =  ZT_SIG_CLEAR | ZT_SIG_DACS;
+	    qoztmp->chans[s][i].chanpos = i + 1; 
+	}
+
+	if (zt_register(&qoztmp->spans[s],0)) {
+	    printk(KERN_INFO "qozap: unable to register zaptel span %d!\n",s+1);
+	    return -1;
+	}
+//	 printk(KERN_INFO "qozap: registered zaptel span %d.\n",s+1);
+    }
+
+    return 0;
+}
+
+int qoz_findCards(unsigned int pcidid) {
+    struct pci_dev *tmp;
+    struct qoz_card *qoztmp = NULL;
+    int i=0;
+    unsigned char dips=0;
+    int cid=0;
+    int modes=0;
+    tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+    while (tmp != NULL) {
+	multi_qoz = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_qoz = NULL;
+	    return -1;
+	}
+
+	qoztmp = kmalloc(sizeof(struct qoz_card),GFP_KERNEL);
+	if (!qoztmp) {
+	    printk(KERN_WARNING "qozap: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -ENOMEM;
+	}
+	memset(qoztmp, 0x0, sizeof(struct qoz_card));
+	
+	spin_lock_init(&qoztmp->lock);
+	qoztmp->pcidev = tmp;
+	qoztmp->pcibus = tmp->bus->number;
+	qoztmp->pcidevfn = tmp->devfn; 
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "qozap: no irq!\n");
+	} else {
+	    qoztmp->irq = tmp->irq;
+	}
+
+	qoztmp->pci_io_phys = (char *) tmp->resource[1].start;
+	if (!qoztmp->pci_io_phys) {
+	    printk(KERN_WARNING "qozap: no iomem!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+
+	qoztmp->ioport = tmp->resource[0].start;
+	if (!qoztmp->ioport) {
+	    printk(KERN_WARNING "qozap: no ioport!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+	if (!request_region(qoztmp->ioport, 8, "qozap")) {
+	    printk(KERN_WARNING "qozap: couldnt request io range!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+	if (!request_mem_region((unsigned long) qoztmp->pci_io_phys, 256, "qozap")) {
+	    printk(KERN_WARNING "qozap: couldnt request io mem range!\n");
+	    release_region(qoztmp->ioport, 8);
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+	
+	if (request_irq(qoztmp->irq, qoz_interrupt, ZAP_IRQ_SHARED, "qozap", qoztmp)) {
+	    printk(KERN_WARNING "qozap: unable to register irq\n");
+	    kfree(qoztmp);
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+
+	qoztmp->pci_io = ioremap((ulong) qoztmp->pci_io_phys, 256);
+	
+	pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+
+	qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+	qoztmp->type = tmp->subsystem_device;
+	qoz_resetCard(qoztmp);
+	
+
+        if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+	//    printk(KERN_INFO "MODES = %#x.\n",modes);
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x80 | 0x40);
+	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x00);
+	    dips = (qoz_inb(qoztmp,qoz_R_GPIO_IN1) >> 5);
+	    cid = 7;
+	    for (i=0;i<3;i++) {
+	        if ((dips & (1 << i)) != 0) {
+	    	cid -= (1 << (2-i));
+	        }
+	    }
+	//	printk(KERN_INFO "DIPS = %#x CID= %#x\n",dips,cid);
+        } else if ((tmp->subsystem_device==0xb550) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		/* quadBRI 2.0 */
+	//    printk(KERN_INFO "MODES = %#x.\n",modes);
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xF0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x00);
+//		dips = qoz_inb(qoztmp,qoz_R_GPIO_IN1) >> 5;
+		dips = ((qoz_inb(qoztmp,qoz_R_GPI_IN3) & 80) >> 1) | ((qoz_inb(qoztmp,qoz_R_GPI_IN3) & 8) << 2) | qoz_inb(qoztmp,qoz_R_GPIO_IN1);
+
+		cid = 0;
+		for (i=0;i<3;i++) {
+	    	    if ((dips & (1 << i)) == 0) {
+	    		cid += (1 << i);
+		    }
+		}
+
+        } else if ((tmp->subsystem_device==0xb556) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		/* duoBRI */
+
+		/* gpi27 1 gpi23 2 */
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x00);
+
+/*		dips = qoz_inb_io(qoztmp,0x4000);
+		dips = qoz_inb_io(qoztmp,0x4000);
+		dips = qoz_inb_io(qoztmp,0x4000);
+		dips = qoz_inb_io(qoztmp,0x4000);
+
+		qoz_outw_io(qoztmp,0x0,0x0);  */
+
+
+        } else if ((tmp->subsystem_device==0xb558) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		/* quadBRI minipCI */
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xF0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x00);
+		dips = qoz_inb(qoztmp,qoz_R_GPIO_IN1) >> 5;
+/*	    printk(KERN_INFO "gpio_in1 %#x\n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+
+	    printk(KERN_INFO "gpi_in2 %#x\n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+	    printk(KERN_INFO "dip1 %#x\n", (qoz_inb(qoztmp,qoz_R_GPI_IN3) & 80) >> 7);
+	    printk(KERN_INFO "gpi_in3 %#x\n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+	    printk(KERN_INFO "dip2 %#x\n", (qoz_inb(qoztmp,qoz_R_GPI_IN3) & 8) >> 3); >*/
+		cid = 0;
+		for (i=0;i<3;i++) {
+	    	    if ((dips & (1 << i)) != 0) {
+	    		cid += (1 << i);
+		    }
+		}
+//	    printk(KERN_INFO "DIPS = %#x CID= %#x\n",dips,cid);
+
+	} else if ((tmp->subsystem_device==0xb55b) && (pcidid == PCI_DEVICE_ID_CCD_M)){
+		qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x21); 
+
+		dips = ~qoz_inb_io(qoztmp,0x4000);
+		dips = ~qoz_inb_io(qoztmp,0x4000);
+		dips = ~qoz_inb_io(qoztmp,0x4000);
+		dips = ~qoz_inb_io(qoztmp,0x4000);
+
+		dips &= 0x3F;
+		qoz_outw_io(qoztmp,0x0,0x0); 
+
+		cid = 0;
+		for (i=0;i<6;i++) {
+	    	    if ((dips & (1 << i)) != 0) {
+	    		cid += (1 << i);
+		    }
+		}
+		qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+		printk(KERN_CRIT "dips = %#x cid = %d\n", dips, cid);
+	} else if (((tmp->subsystem_device==0xb752) || (tmp->subsystem_device==0xb751)) && (pcidid == PCI_DEVICE_ID_CCD_M4)){
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xF0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x00);
+//		dips = qoz_inb(qoztmp,qoz_R_GPIO_IN1) >> 5;
+		dips = ((qoz_inb(qoztmp,qoz_R_GPI_IN3) & 80) >> 1) | ((qoz_inb(qoztmp,qoz_R_GPI_IN3) & 8) << 2) | qoz_inb(qoztmp,qoz_R_GPIO_IN1);
+
+		cid = 0;
+		for (i=0;i<3;i++) {
+	    	    if ((dips & (1 << i)) == 0) {
+	    		cid += (1 << i);
+		    }
+		}
+		printk(KERN_CRIT "dips = %#x cid = %d\n", dips, cid);
+        } else {
+	    cid = 0xff;
+        }
+
+	if (ports == -1) {
+    	    if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;
+    	    } else if ((tmp->subsystem_device==0xb550) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		if (debug) {
+		    printk(KERN_CRIT "gpio_in0 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN0));
+		    printk(KERN_CRIT "gpio_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+		    printk(KERN_CRIT "gpi_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN1));
+		    printk(KERN_CRIT "gpi_in2 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+		    printk(KERN_CRIT "gpi_in3 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+		}
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;	    
+    	    } else if ((tmp->subsystem_device==0xb558) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		if (debug) {
+		    printk(KERN_CRIT "gpio_in0 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN0));
+		    printk(KERN_CRIT "gpio_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+	    	    printk(KERN_CRIT "gpi_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN1));
+		    printk(KERN_CRIT "gpi_in2 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+		    printk(KERN_CRIT "gpi_in3 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+		}
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;	    
+    	    } else if ((tmp->subsystem_device==0xb556) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		if (debug) {
+		    printk(KERN_CRIT "gpio_in0 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN0));
+		    printk(KERN_CRIT "gpio_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+		    printk(KERN_CRIT "gpi_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN1));
+		    printk(KERN_CRIT "gpi_in2 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+		    printk(KERN_CRIT "gpi_in3 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+		}
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;
+    	    } else if ((tmp->subsystem_device==0xb751) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		if (debug) {
+		    printk(KERN_CRIT "gpio_in0 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN0));
+		    printk(KERN_CRIT "gpio_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+		    printk(KERN_CRIT "gpi_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN1));
+		    printk(KERN_CRIT "gpi_in2 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+		    printk(KERN_CRIT "gpi_in3 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+		}
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;	    
+    	    } else if ((tmp->subsystem_device==0xb752) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		qoz_outb(qoztmp,qoz_R_GPIO_SEL,0xf0);
+		qoz_outb(qoztmp,qoz_R_GPIO_EN0,0x00);
+		if (debug) {
+		    printk(KERN_CRIT "gpio_in0 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN0));
+		    printk(KERN_CRIT "gpio_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPIO_IN1));
+		    printk(KERN_CRIT "gpi_in1 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN1));
+		    printk(KERN_CRIT "gpi_in2 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN2));
+		    printk(KERN_CRIT "gpi_in3 %#x \n", qoz_inb(qoztmp,qoz_R_GPI_IN3));
+		}
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;	    
+	    } else {
+		modes = 0; // assume TE mode
+	    }
+	} else {
+	    modes = ports >> totalBRIs;
+	}
+
+	if (pcidid == PCI_DEVICE_ID_CCD_M4) {
+	    switch (tmp->subsystem_device) {
+		case 0x08b4:
+			if (ports == -1) ports = 0; /* assume TE mode if no ports param */
+			printk(KERN_INFO
+		        "qozap: CologneChip HFC-4S evaluation board configured at io port %#x IRQ %d HZ %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ);
+		        totalBRIs += 4;
+		    break;
+		case 0xb520:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET quadBRI card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 4;
+		    break;
+		case 0xb550:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET quadBRI (Version 2.0) card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 4;
+		    break;
+		case 0xb556:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET duoBRI card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 2;
+		    break;
+		case 0xb559:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET duoBRI miniPCI card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 2;
+		    break;
+		case 0xb751:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET duoBRI PCIe card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 2;
+		    break;
+		case 0xb558:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET quadBRI miniPCI card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 4;
+		    break;
+		case 0xb752:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET quadBRI PCIe card configured at io port %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->ioport,
+		        qoztmp->irq, HZ, cid);
+		        totalBRIs += 4;
+		    break;
+	    } 
+	} else {
+	    switch (tmp->subsystem_device) {
+		case 0xb552:
+		    printk(KERN_INFO
+		       "qozap: Junghanns.NET octoBRI card configured at io port %#x IRQ %d HZ %d\n",
+		       (u_int) qoztmp->ioport,
+		       qoztmp->irq, HZ);
+	        break;
+		case 0xb55b:
+		    printk(KERN_INFO
+		       "qozap: Junghanns.NET octoBRI (Version 2.0) card configured at io port %#x IRQ %d HZ %d\n",
+		       (u_int) qoztmp->ioport,
+		       qoztmp->irq, HZ);
+	        break;
+		default:
+		    printk(KERN_INFO
+		       "qozap: wtf\n");
+		    if (qoztmp->pcidev != NULL) {
+    			pci_disable_device(qoztmp->pcidev);
+		    }
+		    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, 0);	
+		    free_irq(qoztmp->irq,qoztmp);
+		    kfree(qoztmp);
+		    qoztmp = NULL;
+		    tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+		    continue;
+		break;		
+	    } 
+	    totalBRIs += 8;
+	}
+
+	qoztmp->cardID = cid;
+	qoztmp->type = tmp->subsystem_device;
+
+	printk(KERN_INFO "qozap: S/T ports: %d [",qoztmp->stports);
+	for (i=0;i<qoztmp->stports;i++) {
+	    qoztmp->st_sync[i] = 0;
+	    if ((modes & (1 << i)) != 0) {
+	        qoztmp->st[i].nt_mode = 1;
+	        printk(" NT");
+	    } else {
+	        qoztmp->st[i].nt_mode = 0;
+	        printk(" TE");
+	    }
+	}
+	printk(" ]\n");
+	
+	qoz_registerCard(qoztmp);
+	tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+    }
+    return 0;
+}
+
+
+int qoz_sortCards(void) {
+    int changed=0,tmpcardno;
+    struct qoz_card *tmpcard,*tmpcard2;
+    spin_lock(&registerlock);
+    do {
+	changed = 0;
+	tmpcard = qoz_dev_list;
+	while (tmpcard != NULL) {
+	    if (tmpcard->prev) {
+		if (tmpcard->prev->cardID > tmpcard->cardID) {
+		    tmpcardno = tmpcard->prev->cardno;
+		    tmpcard->prev->cardno = tmpcard->cardno; 
+		    tmpcard->cardno = tmpcardno;
+		
+		    tmpcard2 = tmpcard->prev;
+		    if (tmpcard2->prev) {
+			tmpcard2->prev->next = tmpcard;
+		    } else {
+			qoz_dev_list = tmpcard;
+		    }
+		    if (tmpcard->next) {
+			tmpcard->next->prev = tmpcard2;
+		    } 
+		    tmpcard2->next = tmpcard->next;
+		    tmpcard->prev = tmpcard2->prev;
+		    tmpcard->next = tmpcard2;
+		    tmpcard2->prev = tmpcard;
+		    changed = 1;
+		    tmpcard = tmpcard2;
+		}
+	    }
+	    tmpcard = tmpcard->next;
+	}
+    } while (changed == 1);
+    spin_unlock(&registerlock);
+    return 0;
+}
+
+int qoz_zapCards(void) {
+    struct qoz_card *tmpcard;
+    tmpcard = qoz_dev_list;
+    while (tmpcard != NULL) {
+	ztqoz_initialize(tmpcard);
+	tmpcard = tmpcard->next;
+    }
+    return 0;
+}
+
+
+int init_module(void) {
+    multi_qoz = NULL;
+    qoz_findCards(PCI_DEVICE_ID_CCD_M4);
+    multi_qoz = NULL;
+    qoz_findCards(PCI_DEVICE_ID_CCD_M);
+    if (sort) {
+	qoz_sortCards();
+    }
+    qoz_zapCards();
+    if (qoz_dev_count == 0) {
+	printk(KERN_INFO "qozap: no multiBRI cards found.\n");
+    } else {
+	printk(KERN_INFO "qozap: %d multiBRI card(s) in this box, %d BRI ports total, bloop %d, pcmslave %d, dacs %d.\n",qoz_dev_count, totalBRIs, bloop, pcmslave, dacs);
+    }
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct qoz_card *tmpcard,*tmplist;
+    int i=0;
+    tmplist = qoz_dev_list;
+    while (tmplist != NULL) {
+	tmplist->dead = 1;
+	qoz_resetCard(tmplist);
+	qoz_undoWD(tmplist);
+	qoz_shutdownCard(tmplist);
+	tmplist = tmplist->next;
+    }
+    tmplist = qoz_dev_list;
+    spin_lock(&registerlock);
+    while (tmplist != NULL) {
+	tmpcard = tmplist->next;
+	kfree(tmplist);
+	i++;
+	tmplist = tmpcard;
+    }
+    spin_unlock(&registerlock);
+    printk(KERN_INFO "qozap: shutdown %d multiBRI cards.\n", i);
+}
+#endif
+
+#ifdef LINUX26
+module_param(doubleclock, int, 0600);
+module_param(ports, int, 0600);
+module_param(pcmslave, int, 0600);
+module_param(bloop, int, 0600);
+module_param(debug, int, 0600);
+module_param(dacs, int, 0600);
+module_param(sort, int, 0600);
+#else
+MODULE_PARM(doubleclock,"i");
+MODULE_PARM(ports,"i");
+MODULE_PARM(pcmslave,"i");
+MODULE_PARM(bloop,"i");
+MODULE_PARM(debug,"i");
+MODULE_PARM(dacs,"i");
+MODULE_PARM(sort,"i");
+#endif
+
+
+MODULE_DESCRIPTION("quad/octo BRI zaptel driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urN zaptel-1.4.11.org/kernel/qozap/qozap.h zaptel-1.4.11/kernel/qozap/qozap.h
--- zaptel-1.4.11.org/kernel/qozap/qozap.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/qozap.h	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,236 @@
+#define qoz_SPANS 8	
+#define qoz_FIFO_SIZE	128
+#define qoz_DFIFO_SIZE4	2048
+#define qoz_DFIFO_SIZE8	1024
+
+typedef struct qoz_span {
+    unsigned char nt_mode;
+    unsigned char btx;
+    unsigned char bswapped;
+    unsigned char drx;
+    int t3;
+    int t4;
+    int l1up;
+    unsigned char layer1state;
+} qoz_span;
+
+typedef struct qoz_regs {
+    unsigned char fifo_en;
+    unsigned char ctmt;
+    unsigned char int_m1;
+    unsigned char int_m2;
+    unsigned char sctrl;
+    unsigned char sctrl_e;
+    unsigned char sctrl_r;
+    unsigned char connect;
+    unsigned char trm;
+    unsigned char mst_mode;
+} qoz_regs;
+
+typedef struct qoz_card {
+    spinlock_t lock;
+    int cardID;
+    unsigned char dead;
+    unsigned char leds[8];
+    unsigned char cardno;
+    unsigned int irq;
+    unsigned int iomem;
+    unsigned char *pci_io;
+    void *pci_io_phys;
+    unsigned long ioport;
+    struct qoz_span st[qoz_SPANS];
+    int st_sync[qoz_SPANS];
+    int syncsrc;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    struct zt_span spans[qoz_SPANS];
+    struct zt_chan chans[qoz_SPANS][3];
+    unsigned char rxbuf[qoz_SPANS][2][ZT_CHUNKSIZE];
+    unsigned char txbuf[qoz_SPANS][2][ZT_CHUNKSIZE];
+    unsigned char drxbuf[qoz_SPANS][qoz_DFIFO_SIZE4];
+    unsigned char dtxbuf[qoz_SPANS][qoz_DFIFO_SIZE4];
+    unsigned char stports;
+    unsigned int ticks;
+    unsigned int clicks;
+    unsigned int type;
+    unsigned int wdp;
+    struct qoz_card *next;
+    struct qoz_card *prev;
+} qoz_card;
+
+
+#define qoz_outb_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outb((c), ((a)->ioport));
+
+#define qoz_inb_io(a,b) ({ outw((b), (a)->ioport+4); inb((a)->ioport); })
+
+#define qoz_outw_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outw((c), ((a)->ioport));
+
+#define qoz_inw_io(a,b) ({ outw((b), (a)->ioport+4); inw((a)->ioport); })
+
+#define qoz_outdw_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outl((c), ((a)->ioport));
+
+#define qoz_indw_io(a,b) ({ outw((b), (a)->ioport+4); inl((a)->ioport); })
+
+#define qoz_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define qoz_inb(a,b) (readb((a)->pci_io+(b)))
+
+#define qoz_outw(a,b,c) (writew((c),(a)->pci_io+(b)))
+#define qoz_inw(a,b) (readw((a)->pci_io+(b)))
+
+#define qoz_outdw(a,b,c) (writel((c),(a)->pci_io+(b)))
+#define qoz_indw(a,b) (readl((a)->pci_io+(b)))
+
+
+/* Write only registers */
+#define qoz_A_CH_MSK	0xF4
+#define qoz_A_CHANNEL 	0xFC
+#define qoz_A_CON_HDLC	0xFA
+#define qoz_A_CONF	0xD1
+#define qoz_A_FIFO_SEQ	0xFD
+#define qoz_R_INC_RES_FIFO	0x0E
+#define qoz_A_IRQ_MSK	0xFF
+#define qoz_A_SL_CFG	0xD0
+#define qoz_A_ST_B1_TX	0x3C
+#define qoz_A_ST_B2_TX	0x3D
+#define qoz_A_ST_CLK_DLY	0x37
+#define qoz_A_ST_CTRL0	0x31
+#define qoz_A_ST_CTRL1	0x32
+#define qoz_A_ST_CTRL2	0x33
+#define qoz_A_ST_D_TX	0x3E
+#define qoz_A_ST_SQ_WR	0x34
+#define qoz_A_ST_WR_STA	0x30
+#define qoz_A_SUBCH_CFG	0xFB
+#define qoz_R_BERT_WD_MD	0x1B
+#define qoz_R_BRG_CTRL	0x45
+#define qoz_R_BRG_MD	0x47
+#define qoz_R_BRG_PCM_CFG	0x02
+#define qoz_R_BRG_TIM_SEL01	0x4C
+#define qoz_R_BRG_TIM_SEL23	0x4D
+#define qoz_R_BRG_TIM_SEL45	0x4E
+#define qoz_R_BRG_TIM_SEL67	0x4F
+#define qoz_R_BRG_TIM0	0x48
+#define qoz_R_BRG_TIM1	0x49
+#define qoz_R_BRG_TIM2	0x4A
+#define qoz_R_BRG_TIM3	0x4B
+#define qoz_R_CIRM	0x00
+#define qoz_R_CONF_EN	0x18
+#define qoz_R_CTRL	0x01
+#define qoz_R_DTMF0	0x1C
+#define qoz_R_DTMF1	0x1D
+#define qoz_R_FIFO_MD	0x0D
+#define qoz_R_FIFO	0x0F
+#define qoz_R_FIRST_FIFO	0x0B
+#define qoz_R_FSM_IDX	0x0F
+#define qoz_R_GPIO_EN0	0x42
+#define qoz_R_GPIO_EN1	0x43
+#define qoz_R_GPIO_OUT0	0x40
+#define qoz_R_GPIO_OUT1	0x41
+#define qoz_R_GPIO_SEL	0x44
+#define qoz_R_IRQ_CTRL	0x13
+#define qoz_R_IRQMSK_MISC	0x11
+#define qoz_R_PCM_MD0	0x14
+#define qoz_R_PCM_MD1	0x15
+#define qoz_R_PCM_MD2	0x15
+#define qoz_R_PWM_MD	0x46
+#define qoz_R_PWM0	0x38
+#define qoz_R_PWM1	0x39
+#define qoz_R_RAM_ADDR0	0x08
+#define qoz_R_RAM_ADDR1	0x09
+#define qoz_R_RAM_ADDR2	0x0A
+#define qoz_R_RAM_MISC	0x0C
+#define qoz_R_SCI_MSK	0x12
+#define qoz_R_SH0H	0x15
+#define qoz_R_SH0L	0x15
+#define qoz_R_SH1H	0x15
+#define qoz_R_SH1L	0x15
+#define qoz_R_SL_SEL0	0x15
+#define qoz_R_SL_SEL1	0x15
+#define qoz_R_SL_SEL2	0x15
+#define qoz_R_SL_SEL3	0x15
+#define qoz_R_SL_SEL4	0x15
+#define qoz_R_SL_SEL5	0x15
+#define qoz_R_SL_SEL6	0x15
+#define qoz_R_SL_SEL7	0x15
+#define qoz_R_SLOT	0x10
+#define qoz_R_ST_SEL	0x16
+#define qoz_R_ST_SYNC	0x17
+#define qoz_R_TI_WD	0x1A
+
+/* Read only registers */
+#define qoz_A_F1	0x0C
+#define qoz_A_F12	0x0C
+#define qoz_A_F2	0x0D
+#define qoz_A_ST_B1_RX	0x3C
+#define qoz_A_ST_B2_TX	0x3D
+#define qoz_A_ST_D_RX	0x3E
+#define qoz_A_ST_E_RX	0x3F
+#define qoz_A_ST_RD_STA	0x30
+#define qoz_A_ST_SQ_RD	0x34
+#define qoz_A_Z1	0x04
+#define qoz_A_Z12	0x04
+#define qoz_A_Z1H	0x05
+#define qoz_A_Z1L	0x04
+#define qoz_A_Z2	0x06
+#define qoz_A_Z2H	0x07
+#define qoz_A_Z2L	0x06
+#define qoz_R_BERT_ECH	0x1B
+#define qoz_R_BERT_ECL	0x1A
+#define qoz_R_BERT_STA	0x17
+#define qoz_R_CHIP_ID	0x16
+#define qoz_R_CHIP_RV	0x1F
+#define qoz_R_CONF_OFLOW	0x14
+#define qoz_R_F0_CNTH	0x19
+#define qoz_R_F0_CNTL	0x18
+#define qoz_R_GPI_IN0	0x44
+#define qoz_R_GPI_IN1	0x45
+#define qoz_R_GPI_IN2	0x46
+#define qoz_R_GPI_IN3	0x47
+#define qoz_R_GPIO_IN0	0x40
+#define qoz_R_GPIO_IN1	0x41
+#define qoz_R_INT_DATA	0x88
+#define qoz_R_IRQ_FIFO_BL0	0xC8
+#define qoz_R_IRQ_FIFO_BL1	0xC9
+#define qoz_R_IRQ_FIFO_BL2	0xCA
+#define qoz_R_IRQ_FIFO_BL3	0xCB
+#define qoz_R_IRQ_FIFO_BL4	0xCC
+#define qoz_R_IRQ_FIFO_BL5	0xCD
+#define qoz_R_IRQ_FIFO_BL6	0xCE
+#define qoz_R_IRQ_FIFO_BL7	0xCF
+#define qoz_R_IRQ_MISC	0x11
+#define qoz_R_IRQ_OVIEW	0x10
+#define qoz_R_RAM_USE	0x15
+#define qoz_R_SCI	0x12
+#define qoz_R_STATUS	0x1C
+
+/* Read/Write registers */
+#define qoz_A_FIFO_DATA0_NOINC	0x84
+#define qoz_A_FIFO_DATA0	0x80
+#define qoz_A_FIFO_DATA1_NOINC	0x84
+#define qoz_A_FIFO_DATA1	0x80
+#define qoz_A_FIFO_DATA2_NOINC	0x84
+#define qoz_A_FIFO_DATA2	0x80
+#define qoz_R_RAM_DATA	0xC0
+
+#define PCI_DEVICE_ID_CCD_M	0x16b8
+#define PCI_DEVICE_ID_CCD_M4	0x08b4
+#define CLKDEL_TE	0xe	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0xc	/* CLKDEL in NT mode */
+
+#define HFC8S_CHIP_ID	0x80
+#define HFC4S_CHIP_ID	0xC0
+
+#define qoz_WD_P0	0x000000
+#define qoz_WD_P1	0x808080
+#define qoz_WD_P2	0x404040
+
+#define qoz_T3		3
+#define qoz_T4		1
+
+
diff -urN zaptel-1.4.11.org/kernel/qozap/TODO zaptel-1.4.11/kernel/qozap/TODO
--- zaptel-1.4.11.org/kernel/qozap/TODO	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/TODO	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,8 @@
+- onchip dtmf
+- E channel support for full debug
+
+
+t3 (5ms max)
+
+t4 (500ms) layer 1 down/up
+
diff -urN zaptel-1.4.11.org/kernel/qozap/zapata.conf zaptel-1.4.11/kernel/qozap/zapata.conf
--- zaptel-1.4.11.org/kernel/qozap/zapata.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zapata.conf	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,51 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+; p2mp TE mode (for connecting ISDN lines in point-to-multipoint mode)
+signalling = bri_cpe_ptmp
+; p2p TE mode (for connecting ISDN lines in point-to-point mode)
+;signalling = bri_cpe
+; p2mp NT mode (for connecting ISDN phones in point-to-multipoint mode)
+;signalling = bri_net_ptmp
+; p2p NT mode (for connecting an ISDN pbx in point-to-point mode)
+;signalling = bri_net
+
+pridialplan = local
+prilocaldialplan = dynamic
+nationalprefix = 0
+internationalprefix = 00
+
+priindication = passthrough
+
+echocancel = yes
+
+context=demo
+group = 1
+; S/T port 1
+channel => 1-2
+
+group = 2
+; S/T port 2
+channel => 4-5
+
+group = 3
+; S/T port 3
+channel => 7-8
+
+group = 4
+; S/T port 4
+channel => 10-11
+
diff -urN zaptel-1.4.11.org/kernel/qozap/zapata.conf.duoBRI zaptel-1.4.11/kernel/qozap/zapata.conf.duoBRI
--- zaptel-1.4.11.org/kernel/qozap/zapata.conf.duoBRI	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zapata.conf.duoBRI	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,43 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+; p2mp TE mode (for connecting ISDN lines in point-to-multipoint mode)
+signalling = bri_cpe_ptmp
+; p2p TE mode (for connecting ISDN lines in point-to-point mode)
+;signalling = bri_cpe
+; p2mp NT mode (for connecting ISDN phones in point-to-multipoint mode)
+;signalling = bri_net_ptmp
+; p2p NT mode (for connecting an ISDN pbx in point-to-point mode)
+;signalling = bri_net
+
+pridialplan = local
+prilocaldialplan = dynamic
+nationalprefix = 0
+internationalprefix = 00
+
+priindication = passthrough
+
+echocancel = yes
+
+context=demo
+group = 1
+; S/T port 1
+channel => 1-2
+
+group = 2
+; S/T port 2
+channel => 4-5
+
diff -urN zaptel-1.4.11.org/kernel/qozap/zapata.conf.octoBRI zaptel-1.4.11/kernel/qozap/zapata.conf.octoBRI
--- zaptel-1.4.11.org/kernel/qozap/zapata.conf.octoBRI	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zapata.conf.octoBRI	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,67 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+; p2mp TE mode (for connecting ISDN lines in point-to-multipoint mode)
+signalling = bri_cpe_ptmp
+; p2p TE mode (for connecting ISDN lines in point-to-point mode)
+;signalling = bri_cpe
+; p2mp NT mode (for connecting ISDN phones in point-to-multipoint mode)
+;signalling = bri_net_ptmp
+; p2p NT mode (for connecting an ISDN pbx in point-to-point mode)
+;signalling = bri_net
+
+pridialplan = local
+prilocaldialplan = dynamic
+nationalprefix = 0
+internationalprefix = 00
+
+priindication = passthrough
+
+echocancel = yes
+
+context=demo
+group = 1
+; S/T port 1
+channel => 1-2
+
+group = 2
+; S/T port 2
+channel => 4-5
+
+group = 3
+; S/T port 3
+channel => 7-8
+
+group = 4
+; S/T port 4
+channel => 10-11
+
+group = 5
+; S/T port 5
+channel => 13-14
+
+group = 6
+; S/T port 6
+channel => 16-17
+
+group = 7
+; S/T port 7
+channel => 19-20
+
+group = 8
+; S/T port 8
+channel => 22-23
+
diff -urN zaptel-1.4.11.org/kernel/qozap/zaptel.conf zaptel-1.4.11/kernel/qozap/zaptel.conf
--- zaptel-1.4.11.org/kernel/qozap/zaptel.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zaptel.conf	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,18 @@
+loadzone=nl
+defaultzone=nl
+# qozap span definitions
+# most of the values should be bogus because we are not really zaptel
+span=1,1,3,ccs,ami
+span=2,2,3,ccs,ami
+span=3,3,3,ccs,ami
+span=4,4,3,ccs,ami
+
+bchan=1,2
+dchan=3
+bchan=4,5
+dchan=6
+bchan=7,8
+dchan=9
+bchan=10,11
+dchan=12
+
diff -urN zaptel-1.4.11.org/kernel/qozap/zaptel.conf.duoBRI zaptel-1.4.11/kernel/qozap/zaptel.conf.duoBRI
--- zaptel-1.4.11.org/kernel/qozap/zaptel.conf.duoBRI	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zaptel.conf.duoBRI	2008-07-16 22:06:17.211146394 +0200
@@ -0,0 +1,11 @@
+loadzone=nl
+defaultzone=nl
+# qozap span definitions
+# most of the values should be bogus because we are not really zaptel
+span=1,1,3,ccs,ami
+span=2,2,3,ccs,ami
+
+bchan=1,2
+dchan=3
+bchan=4,5
+dchan=6
diff -urN zaptel-1.4.11.org/kernel/qozap/zaptel.conf.octoBRI zaptel-1.4.11/kernel/qozap/zaptel.conf.octoBRI
--- zaptel-1.4.11.org/kernel/qozap/zaptel.conf.octoBRI	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/qozap/zaptel.conf.octoBRI	2008-07-16 22:06:17.215522885 +0200
@@ -0,0 +1,30 @@
+loadzone=nl
+defaultzone=nl
+# qozap span definitions
+# most of the values should be bogus because we are not really zaptel
+span=1,1,3,ccs,ami
+span=2,2,3,ccs,ami
+span=3,3,3,ccs,ami
+span=4,4,3,ccs,ami
+span=5,5,3,ccs,ami
+span=6,6,3,ccs,ami
+span=7,7,3,ccs,ami
+span=8,8,3,ccs,ami
+
+bchan=1,2
+dchan=3
+bchan=4,5
+dchan=6
+bchan=7,8
+dchan=9
+bchan=10,11
+dchan=12
+bchan=13,14
+dchan=15
+bchan=16,17
+dchan=18
+bchan=19,20
+dchan=21
+bchan=22,23
+dchan=24
+
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/ChangeLog zaptel-1.4.11/kernel/vzaphfc/ChangeLog
--- zaptel-1.4.11.org/kernel/vzaphfc/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/ChangeLog	2008-07-16 22:06:17.215522885 +0200
@@ -0,0 +1,13 @@
+1.44 - 2007aug26 - Jens Wilke <jw_vzaphfc@headissue.com>
+- Fix for changes irq callback signature (pt_reqs removed)
+- Fix for missing CHECKSUM_COMPLETE in newer kernel version
+- Fix for missing linux/config.h in kernel headers
+- tested with Linux kernel 2.6.20
+
+1.43 - 2006oct03 - Jens Wilke <jw_vzaphfc@headissue.com>
+- fix wrong nt_modes parsing, found with kernel 2.6.15
+
+1.42 - 2006jun06 - Jens Wilke <jw_vzaphfc@headissue.com>
+- fixed fifo timing issue
+- added statistics for fifo underruns (RXU&TXU)
+- maintanance now done by jw
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/fifo.c zaptel-1.4.11/kernel/vzaphfc/fifo.c
--- zaptel-1.4.11.org/kernel/vzaphfc/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/fifo.c	2008-07-16 22:06:17.215522885 +0200
@@ -0,0 +1,366 @@
+/*
+ * fifo.c - HFC FIFO management routines
+ *
+ * Copyright (C) 2006 headissue GmbH; Jens Wilke
+ * Copyright (C) 2004 Daniele Orlandi
+ * Copyright (C) 2002, 2003, 2004, Junghanns.NET GmbH
+ *
+ * Original author of this code is
+ * Daniele "Vihai" Orlandi <daniele@orlandi.com>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#include <linux/kernel.h>
+
+#include "../zaptel.h"
+
+#include "fifo.h"
+
+static void hfc_fifo_mem_read(struct hfc_chan_simplex *chan,
+	int z_start,
+	void *data, int size)
+{
+	int bytes_to_boundary = chan->z_max - z_start + 1;
+	if (bytes_to_boundary >= size) {
+		memcpy(data,
+			chan->z_base + z_start,
+			size);
+	} else {
+		// Buffer wrap
+		memcpy(data,
+			chan->z_base + z_start,
+			bytes_to_boundary);
+
+		memcpy(data + bytes_to_boundary,
+			chan->fifo_base,
+			size - bytes_to_boundary);
+	}
+}
+
+static void hfc_fifo_mem_write(struct hfc_chan_simplex *chan,
+	void *data, int size)
+{
+	int bytes_to_boundary = chan->z_max - *Z1_F1(chan) + 1;
+	if (bytes_to_boundary >= size) {
+		memcpy(chan->z_base + *Z1_F1(chan),
+			data,
+			size);
+	} else {
+		// FIFO wrap
+
+		memcpy(chan->z_base + *Z1_F1(chan),
+			data,
+			bytes_to_boundary);
+
+		memcpy(chan->fifo_base,
+			data + bytes_to_boundary,
+			size - bytes_to_boundary);
+	}
+}
+
+int hfc_fifo_get(struct hfc_chan_simplex *chan,
+		void *data, int size)
+{
+	int available_bytes;
+
+	// Some useless statistic
+	chan->bytes += size;
+
+	available_bytes = hfc_fifo_used_rx(chan);
+
+	if (available_bytes < size && !chan->fifo_underrun++) {
+		// print the warning only once
+		printk(KERN_WARNING hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"RX FIFO not enough (%d) bytes to receive!\n",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			available_bytes);
+		return -1;
+	}
+
+	hfc_fifo_mem_read(chan, *Z2_F2(chan), data, size);
+	*Z2_F2(chan) = Z_inc(chan, *Z2_F2(chan), size);
+	return available_bytes - size;
+}
+
+/*
+static void hfc_fifo_drop(struct hfc_chan_simplex *chan, int size)
+{
+	int available_bytes = hfc_fifo_used_rx(chan);
+	if (available_bytes + 1 < size) {
+		printk(KERN_WARNING hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"RX FIFO not enough (%d) bytes to drop!\n",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			available_bytes);
+
+		return;
+	}
+
+	*Z2_F2(chan) = Z_inc(chan, *Z2_F2(chan), size);
+}
+*/
+
+void hfc_fifo_put(struct hfc_chan_simplex *chan,
+			void *data, int size)
+{
+	struct hfc_card *card = chan->chan->card;
+	int used_bytes = hfc_fifo_used_tx(chan);
+	int free_bytes = hfc_fifo_free_tx(chan);
+
+	if (!used_bytes && !chan->fifo_underrun++) {
+		// print warning only once, to make timing not worse
+		printk(KERN_WARNING hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"TX FIFO has become empty\n",
+			card->cardnum,
+			chan->chan->name);
+	}
+	if (free_bytes < size) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"TX FIFO full!\n",
+			chan->chan->card->cardnum,
+			chan->chan->name);
+		chan->fifo_full++;
+		hfc_clear_fifo_tx(chan);
+	}
+
+	hfc_fifo_mem_write(chan, data, size);
+	chan->bytes += size;
+	*Z1_F1(chan) = Z_inc(chan, *Z1_F1(chan), size);
+}
+
+int hfc_fifo_get_frame(struct hfc_chan_simplex *chan, void *data, int max_size)
+{
+	int frame_size;
+	u16 newz2 ;
+	
+	if (*chan->f1 == *chan->f2) {
+		// nothing received, strange uh?
+		printk(KERN_WARNING hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"get_frame called with no frame in FIFO.\n",
+			chan->chan->card->cardnum,
+			chan->chan->name);
+
+		return -1;
+	}
+
+	// frame_size includes CRC+CRC+STAT
+	frame_size = hfc_fifo_get_frame_size(chan);
+
+#ifdef DEBUG
+	if(debug_level == 3) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"RX len %2d: ",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			frame_size);
+	} else if(debug_level >= 4) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"RX (f1=%02x, f2=%02x, z1=%04x, z2=%04x) len %2d: ",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			*chan->f1, *chan->f2, *Z1_F2(chan), *Z2_F2(chan),
+			frame_size);
+	}
+
+	if(debug_level >= 3) {
+		int i;
+		for (i=0; i < frame_size; i++) {
+			printk("%02x", hfc_fifo_u8(chan,
+				Z_inc(chan, *Z2_F2(chan), i)));
+		}
+
+		printk("\n"); 
+	}
+#endif
+
+	if (frame_size <= 0) {
+#ifdef DEBUG
+		if (debug_level >= 2) {
+			printk(KERN_DEBUG hfc_DRIVER_PREFIX
+				"card %d: "
+				"chan %s: "
+				"invalid (empty) frame received.\n",
+				chan->chan->card->cardnum,
+				chan->chan->name);
+		}
+#endif
+
+		hfc_fifo_drop_frame(chan);
+		return -1;
+	}
+
+	// STAT is not really received
+	chan->bytes += frame_size - 1;
+
+	// Calculate beginning of the next frame
+	newz2 = Z_inc(chan, *Z2_F2(chan), frame_size);
+
+	// We cannot use hfc_fifo_get because of different semantic of
+	// "available bytes" and to avoid useless increment of Z2
+	hfc_fifo_mem_read(chan, *Z2_F2(chan), data,
+		frame_size < max_size ? frame_size : max_size);
+
+	if (hfc_fifo_u8(chan, Z_inc(chan, *Z2_F2(chan),
+		frame_size - 1)) != 0x00) {
+		// CRC not ok, frame broken, skipping
+#ifdef DEBUG
+		if(debug_level >= 2) {
+			printk(KERN_WARNING hfc_DRIVER_PREFIX
+				"card %d: "
+				"chan %s: "
+				"Received frame with wrong CRC\n",
+				chan->chan->card->cardnum,
+				chan->chan->name);
+		}
+#endif
+
+		chan->crc++;
+		chan->chan->net_device_stats.rx_errors++;
+
+		hfc_fifo_drop_frame(chan);
+		return -1;
+	}
+
+	chan->frames++;
+
+	*chan->f2 = F_inc(chan, *chan->f2, 1);
+
+	// Set Z2 for the next frame we're going to receive
+	*Z2_F2(chan) = newz2;
+
+	return frame_size;
+}
+
+void hfc_fifo_drop_frame(struct hfc_chan_simplex *chan)
+{
+	int available_bytes;
+	u16 newz2;
+
+	if (*chan->f1 == *chan->f2) {
+		// nothing received, strange eh?
+		printk(KERN_WARNING hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"skip_frame called with no frame in FIFO.\n",
+			chan->chan->card->cardnum,
+			chan->chan->name);
+
+		return;
+	}
+
+//	chan->drops++;
+
+	available_bytes = hfc_fifo_used_rx(chan) + 1;
+
+	// Calculate beginning of the next frame
+	newz2 = Z_inc(chan, *Z2_F2(chan), available_bytes);
+
+	*chan->f2 = F_inc(chan, *chan->f2, 1);
+
+	// Set Z2 for the next frame we're going to receive
+	*Z2_F2(chan) = newz2;
+}
+
+void hfc_fifo_put_frame(struct hfc_chan_simplex *chan,
+		 void *data, int size)
+{
+	u16 newz1;
+	int available_frames;
+
+#ifdef DEBUG
+	if (debug_level == 3) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"TX len %2d: ",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			size);
+	} else if (debug_level >= 4) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"TX (f1=%02x, f2=%02x, z1=%04x, z2=%04x) len %2d: ",
+			chan->chan->card->cardnum,
+			chan->chan->name,
+			*chan->f1, *chan->f2, *Z1_F1(chan), *Z2_F1(chan),
+			size);
+	}
+
+	if (debug_level >= 3) {
+		int i;
+		for (i=0; i<size; i++)
+			printk("%02x",((u8 *)data)[i]);
+
+		printk("\n");
+	}
+#endif
+
+	available_frames = hfc_fifo_free_frames(chan);
+
+	if (available_frames >= chan->f_num) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s: "
+			"TX FIFO total number of frames exceeded!\n",
+			chan->chan->card->cardnum,
+			chan->chan->name);
+
+		chan->fifo_full++;
+
+		return;
+	}
+
+	hfc_fifo_put(chan, data, size);
+
+	newz1 = *Z1_F1(chan);
+
+	*chan->f1 = F_inc(chan, *chan->f1, 1);
+
+	*Z1_F1(chan) = newz1;
+
+	chan->frames++;
+}
+
+void hfc_clear_fifo_rx(struct hfc_chan_simplex *chan)
+{
+	*chan->f2 = *chan->f1;
+	*Z2_F2(chan) = *Z1_F2(chan);
+}
+
+void hfc_clear_fifo_tx(struct hfc_chan_simplex *chan)
+{
+	*chan->f1 = *chan->f2;
+	*Z1_F1(chan) = *Z2_F1(chan);
+
+	if (chan->chan->status == open_voice) {
+		// Make sure that at least hfc_TX_FIFO_PRELOAD bytes are
+		// present in the TX FIFOs
+
+		// Create hfc_TX_FIFO_PRELOAD bytes of empty data
+		// (0x7f is mute audio)
+		u8 empty_fifo[hfc_TX_FIFO_PRELOAD + ZT_CHUNKSIZE + hfc_RX_FIFO_PRELOAD];
+		memset(empty_fifo, 0x7f, sizeof(empty_fifo));
+
+		hfc_fifo_put(chan, empty_fifo, sizeof(empty_fifo));
+	}
+}
+
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/fifo.h zaptel-1.4.11/kernel/vzaphfc/fifo.h
--- zaptel-1.4.11.org/kernel/vzaphfc/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/fifo.h	2008-07-16 22:06:17.215522885 +0200
@@ -0,0 +1,131 @@
+/*
+ * zaphfc.c - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * Copyright (C) 2004 Daniele Orlandi
+ * Copyright (C) 2002, 2003, 2004, Junghanns.NET GmbH
+ *
+ * Daniele "Vihai" Orlandi <daniele@orlandi.com> 
+ *
+ * Major rewrite of the driver made by
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#ifndef _HFC_FIFO_H
+#define _HFC_FIFO_H
+
+#include "vzaphfc.h"
+
+static inline u16 *Z1_F1(struct hfc_chan_simplex *chan)
+{
+	return chan->z1_base + (*chan->f1 * 4);
+}
+
+static inline u16 *Z2_F1(struct hfc_chan_simplex *chan)
+{
+	return chan->z2_base + (*chan->f1 * 4);
+}
+
+static inline u16 *Z1_F2(struct hfc_chan_simplex *chan)
+{
+	return chan->z1_base + (*chan->f2 * 4);
+}
+
+static inline u16 *Z2_F2(struct hfc_chan_simplex *chan)
+{
+	return chan->z2_base + (*chan->f2 * 4);
+}
+
+static inline u16 Z_inc(struct hfc_chan_simplex *chan, u16 z, u16 inc)
+{
+	// declared as u32 in order to manage overflows
+	u32 newz = z + inc;
+	if (newz > chan->z_max)
+		newz -= chan->fifo_size;
+
+	return newz;
+}
+
+static inline u8 F_inc(struct hfc_chan_simplex *chan, u8 f, u8 inc)
+{
+	// declared as u16 in order to manage overflows
+	u16 newf = f + inc;
+	if (newf > chan->f_max)
+		newf -= chan->f_num;
+
+	return newf;
+}
+
+static inline u16 hfc_fifo_used_rx(struct hfc_chan_simplex *chan)
+{
+	return (*Z1_F2(chan) - *Z2_F2(chan) + chan->fifo_size) % chan->fifo_size;
+}
+
+static inline u16 hfc_fifo_get_frame_size(struct hfc_chan_simplex *chan)
+{
+ // This +1 is needed because in frame mode the available bytes are Z2-Z1+1
+ // while in transparent mode I wouldn't consider the byte pointed by Z2 to
+ // be available, otherwise, the FIFO would always contain one byte, even
+ // when Z1==Z2
+
+	return hfc_fifo_used_rx(chan) + 1;
+}
+
+static inline u8 hfc_fifo_u8(struct hfc_chan_simplex *chan, u16 z)
+{
+	return *((u8 *)(chan->z_base + z));
+}
+
+static inline u16 hfc_fifo_used_tx(struct hfc_chan_simplex *chan)
+{
+	return (*Z1_F1(chan) - *Z2_F1(chan) + chan->fifo_size) % chan->fifo_size;
+}
+
+static inline u16 hfc_fifo_free_rx(struct hfc_chan_simplex *chan)
+{
+	u16 free_bytes=*Z2_F1(chan) - *Z1_F1(chan);
+
+	if (free_bytes > 0)
+		return free_bytes;
+	else
+		return free_bytes + chan->fifo_size;
+}
+
+static inline u16 hfc_fifo_free_tx(struct hfc_chan_simplex *chan)
+{
+	u16 free_bytes=*Z2_F1(chan) - *Z1_F1(chan);
+
+	if (free_bytes > 0)
+		return free_bytes;
+	else
+		return free_bytes + chan->fifo_size;
+}
+
+static inline int hfc_fifo_has_frames(struct hfc_chan_simplex *chan)
+{
+	return *chan->f1 != *chan->f2;
+}
+
+static inline u8 hfc_fifo_used_frames(struct hfc_chan_simplex *chan)
+{
+	return (*chan->f1 - *chan->f2 + chan->f_num) % chan->f_num;
+}
+
+static inline u8 hfc_fifo_free_frames(struct hfc_chan_simplex *chan)
+{
+	return (*chan->f2 - *chan->f1 + chan->f_num) % chan->f_num;
+}
+
+int hfc_fifo_get(struct hfc_chan_simplex *chan, void *data, int size);
+void hfc_fifo_put(struct hfc_chan_simplex *chan, void *data, int size);
+void hfc_fifo_drop(struct hfc_chan_simplex *chan, int size);
+int hfc_fifo_get_frame(struct hfc_chan_simplex *chan, void *data, int max_size);
+void hfc_fifo_drop_frame(struct hfc_chan_simplex *chan);
+void hfc_fifo_put_frame(struct hfc_chan_simplex *chan, void *data, int size);
+void hfc_clear_fifo_rx(struct hfc_chan_simplex *chan);
+void hfc_clear_fifo_tx(struct hfc_chan_simplex *chan);
+
+#endif
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/Kbuild zaptel-1.4.11/kernel/vzaphfc/Kbuild
--- zaptel-1.4.11.org/kernel/vzaphfc/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/Kbuild	2008-07-16 22:21:23.784389983 +0200
@@ -0,0 +1,11 @@
+obj-m += vzaphfc.o
+
+vzaphfc-objs := vzaphfc_main.o fifo.o lapd.o
+
+FIRM_DIR	:= ../../firmware
+
+EXTRA_CFLAGS := -I$(src)/.. -Wno-undef
+
+ifeq ($(HOTPLUG_FIRMWARE),yes)
+  EXTRA_CFLAGS+=-DHOTPLUG_FIRMWARE
+endif
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/lapd.c zaptel-1.4.11/kernel/vzaphfc/lapd.c
--- zaptel-1.4.11.org/kernel/vzaphfc/lapd.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/lapd.c	2008-07-16 22:06:17.217813615 +0200
@@ -0,0 +1,48 @@
+/*
+ * lapd.c
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+
+#include "lapd.h"
+
+static int lapd_change_mtu(struct net_device *dev, int mtu)
+{
+	return -EINVAL;
+}
+
+static int lapd_mac_addr(struct net_device *dev, void *addr)
+{
+	return -EINVAL;
+}
+
+void setup_lapd(struct net_device *netdev)
+{
+
+	netdev->change_mtu         = lapd_change_mtu;
+	netdev->set_mac_address    = lapd_mac_addr;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	netdev->hard_header        = NULL;
+	netdev->rebuild_header     = NULL;
+	netdev->hard_header_cache  = NULL;
+	netdev->header_cache_update= NULL;
+#endif
+
+	netdev->type               = ARPHRD_LAPD;
+	netdev->hard_header_len    = 0;
+	netdev->mtu                = 512;
+	netdev->addr_len           = 0;
+	netdev->tx_queue_len       = 10;
+
+	memset(netdev->broadcast, 0x00, sizeof(netdev->broadcast));
+
+	netdev->flags              = IFF_NOARP;
+}
+
+
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/lapd.h zaptel-1.4.11/kernel/vzaphfc/lapd.h
--- zaptel-1.4.11.org/kernel/vzaphfc/lapd.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/lapd.h	2008-07-16 22:06:17.217813615 +0200
@@ -0,0 +1,26 @@
+/*
+ * lapd.c - net_device LAPD link layer support functionss
+ *
+ * Copyright (C) 2004 Daniele Orlandi
+ *
+ * Daniele "Vihai" Orlandi <daniele@orlandi.com> 
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#ifndef _HFC_LAPD_H
+#define _HFC_LAPD_H
+
+#ifndef ARPHRD_LAPD
+#define ARPHRD_LAPD 1000	/* LAPD pseudo type */
+#endif
+
+#ifndef ETH_P_LAPD
+#define ETH_P_LAPD 0x0030	/* LAPD pseudo type */
+#endif
+
+void setup_lapd(struct net_device *netdev);
+
+#endif
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/Makefile zaptel-1.4.11/kernel/vzaphfc/Makefile
--- zaptel-1.4.11.org/kernel/vzaphfc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/Makefile	2008-07-16 22:06:17.217813615 +0200
@@ -0,0 +1,38 @@
+#
+#  Copyright (C) 2006 headissue GmbH; Jens Wilke
+#
+#  This program is free software and may be modified and
+#  distributed under the terms of the GNU Public License.
+#
+
+KSOURCE ?= /lib/modules/`uname -r`/build
+
+ifndef src
+	src=$(shell pwd)
+endif
+
+ZAPTEL_SOURCE = $(src)/../../bristuff12/zaptel/
+
+EXTRA_CFLAGS += -I $(ZAPTEL_SOURCE)
+
+obj-m	:= vzaphfc.o
+vzaphfc-objs := vzaphfc_main.o fifo.o lapd.o
+
+all:
+	$(MAKE) -C $(KSOURCE) SUBDIRS=`pwd` modules
+
+clean:
+	$(MAKE) -C $(KSOURCE) SUBDIRS=`pwd` clean
+
+debug:
+	$(MAKE) -C $(KSOURCE) modules SUBDIRS=`pwd` EXTRA_CFLAGS="$(EXTRA_CFLAGS) -DDEBUG" CONFIG_DEBUG_INFO=1
+
+# 2.4 stuff ####
+modules: $(obj-m)
+	sync
+
+vzaphfc.o: vzaphfc_main.c fifo.c vzaphfc.h fifo.h lapd.h
+	$(CC) -c vzaphfc_main.c fifo.c $(CFLAGS) $(EXTRA_CFLAGS)
+
+install:
+	install -D -m 644 vzaphfc.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/vzaphfc.ko
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/README zaptel-1.4.11/kernel/vzaphfc/README
--- zaptel-1.4.11.org/kernel/vzaphfc/README	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/README	2008-07-16 22:06:17.217813615 +0200
@@ -0,0 +1,45 @@
+== General Info ==
+
+This is a Zaptel driver for HFC-S PCI A based ISDN BRI cards (Cologne
+Chipdesign).
+
+== Driver Build ==
+
+You need the kernel source (2.6) and the Zaptel driver sources
+to build the module.
+
+== Module Parameters ==
+
+  nt_modes:
+  comma seperated list 
+
+  sniff_zaptel_d_channel:
+  Make frames transmitted from Zaptel appear as received by the board
+  Set this to 1 if you want to debug D channel signaling with Etherreal
+
+  force_l1_up:
+  Keep ISDN bus activated. Usually set by PtP TE interfaces.
+
+  nt_modes:
+  Comma-separated list of card IDs to configure in NT mode (array of int)
+
+== Information in the proc file system ==
+
+  You will find valuable data about the current state of your ISDN
+  interface in /proc/drivers/vzaphfc/<cardnum>. The following files
+  are present for each card:
+
+  info:
+  Information about the bus activation, transmit errors (CRC), and 
+  overall transfer statistics
+
+  bufs:
+  Except from the data that is currently transmitted
+
+  fifo:
+  sizes and counter values from the FIFOs, mainly for debugging
+  purposes
+
+
+Latest Change: 6 Jun 2006 Jens Wilke <jw_vzaphfc@headissue.com>
+
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/vzaphfc.h zaptel-1.4.11/kernel/vzaphfc/vzaphfc.h
--- zaptel-1.4.11.org/kernel/vzaphfc/vzaphfc.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/vzaphfc.h	2008-07-16 22:06:17.217813615 +0200
@@ -0,0 +1,387 @@
+/*
+ * zaphfc.c - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * Copyright (C) 2006 headissue GmbH; Jens Wilke
+ * Copyright (C) 2004 Daniele Orlandi
+ * Copyright (C) 2002, 2003, 2004, Junghanns.NET GmbH
+ *
+ * Jens Wilke <jw_vzaphfc@headissue.com>
+ * 
+ * Orginal author of this code is
+ * Daniele "Vihai" Orlandi <daniele@orlandi.com> 
+ *
+ * Major rewrite of the driver made by
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#ifndef _HFC_ZAPHFC_H
+#define _HFC_ZAPHFC_H
+
+#include <asm/io.h>
+#include <linux/netdevice.h>
+
+#include "../zaptel.h"
+
+#define hfc_DRIVER_NAME "vzaphfc"
+#define hfc_DRIVER_PREFIX hfc_DRIVER_NAME ": "
+#define hfc_DRIVER_DESCR "HFC-S PCI A Zaptel Driver"
+#define hfc_DRIVER_VERSION "1.44"
+#define hfc_DRIVER_STRING hfc_DRIVER_DESCR " (V" hfc_DRIVER_VERSION ")"
+
+#define hfc_MAX_BOARDS 32
+
+#ifndef LINUX26
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define irqreturn_t void
+#endif
+
+#ifndef PCI_DMA_32BIT
+#define PCI_DMA_32BIT	0x00000000ffffffffULL
+#endif
+
+#ifndef PCI_VENDOR_ID_SITECOM
+#define PCI_VENDOR_ID_SITECOM 0x182D
+#endif
+
+#ifndef PCI_DEVICE_ID_SITECOM_3069
+#define PCI_DEVICE_ID_SITECOM_3069 0x3069
+#endif
+
+#define hfc_RESET_DELAY 20
+
+#define hfc_CLKDEL_TE	0x0f	/* CLKDEL in TE mode */
+#define hfc_CLKDEL_NT	0x6c	/* CLKDEL in NT mode */
+
+/* PCI memory mapped I/O */
+
+#define hfc_PCI_MEM_SIZE	0x0100
+#define hfc_PCI_MWBA		0x80
+
+/* GCI/IOM bus monitor registers */
+
+#define hfc_C_I       0x08
+#define hfc_TRxR      0x0C
+#define hfc_MON1_D    0x28
+#define hfc_MON2_D    0x2C
+
+
+/* GCI/IOM bus timeslot registers */
+
+#define hfc_B1_SSL    0x80
+#define hfc_B2_SSL    0x84
+#define hfc_AUX1_SSL  0x88
+#define hfc_AUX2_SSL  0x8C
+#define hfc_B1_RSL    0x90
+#define hfc_B2_RSL    0x94
+#define hfc_AUX1_RSL  0x98
+#define hfc_AUX2_RSL  0x9C
+
+/* GCI/IOM bus data registers */
+
+#define hfc_B1_D      0xA0
+#define hfc_B2_D      0xA4
+#define hfc_AUX1_D    0xA8
+#define hfc_AUX2_D    0xAC
+
+/* GCI/IOM bus configuration registers */
+
+#define hfc_MST_EMOD  0xB4
+#define hfc_MST_MODE	 0xB8
+#define hfc_CONNECT 	 0xBC
+
+
+/* Interrupt and status registers */
+
+#define hfc_FIFO_EN   0x44
+#define hfc_TRM       0x48
+#define hfc_B_MODE    0x4C
+#define hfc_CHIP_ID   0x58
+#define hfc_CIRM  	 0x60
+#define hfc_CTMT	 0x64
+#define hfc_INT_M1  	 0x68
+#define hfc_INT_M2  	 0x6C
+#define hfc_INT_S1  	 0x78
+#define hfc_INT_S2  	 0x7C
+#define hfc_STATUS  	 0x70
+
+/* S/T section registers */
+
+#define hfc_STATES  	 0xC0
+#define hfc_SCTRL  	 0xC4
+#define hfc_SCTRL_E   0xC8
+#define hfc_SCTRL_R   0xCC
+#define hfc_SQ  	 0xD0
+#define hfc_CLKDEL  	 0xDC
+#define hfc_B1_REC    0xF0
+#define hfc_B1_SEND   0xF0
+#define hfc_B2_REC    0xF4
+#define hfc_B2_SEND   0xF4
+#define hfc_D_REC     0xF8
+#define hfc_D_SEND    0xF8
+#define hfc_E_REC     0xFC
+
+/* Bits and values in various HFC PCI registers */
+
+/* bits in status register (READ) */
+#define hfc_STATUS_PCI_PROC   0x02
+#define hfc_STATUS_NBUSY	  0x04 
+#define hfc_STATUS_TIMER_ELAP 0x10
+#define hfc_STATUS_STATINT	  0x20
+#define hfc_STATUS_FRAMEINT	  0x40
+#define hfc_STATUS_ANYINT	  0x80
+
+/* bits in CTMT (Write) */
+#define hfc_CTMT_TRANSB1	0x01
+#define hfc_CTMT_TRANSB2	0x02
+#define hfc_CTMT_TIMER_CLEAR	0x80
+#define hfc_CTMT_TIMER_MASK	0x1C
+#define hfc_CTMT_TIMER_3_125	(0x01 << 2)
+#define hfc_CTMT_TIMER_6_25	(0x02 << 2)
+#define hfc_CTMT_TIMER_12_5	(0x03 << 2)
+#define hfc_CTMT_TIMER_25	(0x04 << 2)
+#define hfc_CTMT_TIMER_50	(0x05 << 2)
+#define hfc_CTMT_TIMER_400	(0x06 << 2)
+#define hfc_CTMT_TIMER_800	(0x07 << 2)
+#define hfc_CTMT_AUTO_TIMER	0x20
+
+/* bits in CIRM (Write) */
+#define hfc_CIRM_AUX_MSK    0x07
+#define hfc_CIRM_RESET  	  0x08
+#define hfc_CIRM_B1_REV     0x40
+#define hfc_CIRM_B2_REV     0x80
+
+/* bits in INT_M1 and INT_S1 */
+#define hfc_INTS_B1TRANS  0x01
+#define hfc_INTS_B2TRANS  0x02
+#define hfc_INTS_DTRANS   0x04
+#define hfc_INTS_B1REC    0x08
+#define hfc_INTS_B2REC    0x10
+#define hfc_INTS_DREC     0x20
+#define hfc_INTS_L1STATE  0x40
+#define hfc_INTS_TIMER    0x80
+
+/* bits in INT_M2 */
+#define hfc_M2_PROC_TRANS    0x01
+#define hfc_M2_GCI_I_CHG     0x02
+#define hfc_M2_GCI_MON_REC   0x04
+#define hfc_M2_IRQ_ENABLE    0x08
+#define hfc_M2_PMESEL        0x80
+
+/* bits in STATES */
+#define hfc_STATES_STATE_MASK     0x0F
+#define hfc_STATES_LOAD_STATE    0x10
+#define hfc_STATES_ACTIVATE	     0x20
+#define hfc_STATES_DO_ACTION     0x40
+#define hfc_STATES_NT_G2_G3      0x80
+
+/* bits in HFCD_MST_MODE */
+#define hfc_MST_MODE_MASTER	     0x01
+#define hfc_MST_MODE_SLAVE         0x00
+/* remaining bits are for codecs control */
+
+/* bits in HFCD_SCTRL */
+#define hfc_SCTRL_B1_ENA	     0x01
+#define hfc_SCTRL_B2_ENA	     0x02
+#define hfc_SCTRL_MODE_TE        0x00
+#define hfc_SCTRL_MODE_NT        0x04
+#define hfc_SCTRL_LOW_PRIO	     0x08
+#define hfc_SCTRL_SQ_ENA	     0x10
+#define hfc_SCTRL_TEST	     0x20
+#define hfc_SCTRL_NONE_CAP	     0x40
+#define hfc_SCTRL_PWR_DOWN	     0x80
+
+/* bits in SCTRL_E  */
+#define hfc_SCTRL_E_AUTO_AWAKE    0x01
+#define hfc_SCTRL_E_DBIT_1        0x04
+#define hfc_SCTRL_E_IGNORE_COL    0x08
+#define hfc_SCTRL_E_CHG_B1_B2     0x80
+
+/* bits in SCTRL_R  */
+#define hfc_SCTRL_R_B1_ENA	     0x01
+#define hfc_SCTRL_R_B2_ENA	     0x02
+
+/* bits in FIFO_EN register */
+#define hfc_FIFOEN_B1TX   0x01
+#define hfc_FIFOEN_B1RX   0x02
+#define hfc_FIFOEN_B2TX   0x04
+#define hfc_FIFOEN_B2RX   0x08
+#define hfc_FIFOEN_DTX    0x10
+#define hfc_FIFOEN_DRX    0x20
+
+#define hfc_FIFOEN_B1     (hfc_FIFOEN_B1TX|hfc_FIFOEN_B1RX)
+#define hfc_FIFOEN_B2     (hfc_FIFOEN_B2TX|hfc_FIFOEN_B2RX)
+#define hfc_FIFOEN_D      (hfc_FIFOEN_DTX|hfc_FIFOEN_DRX)
+
+/* bits in the CONNECT register */
+#define	hfc_CONNECT_B1_HFC_from_ST		0x00
+#define	hfc_CONNECT_B1_HFC_from_GCI		0x01
+#define hfc_CONNECT_B1_ST_from_HFC		0x00
+#define hfc_CONNECT_B1_ST_from_GCI		0x02
+#define hfc_CONNECT_B1_GCI_from_HFC		0x00
+#define hfc_CONNECT_B1_GCI_from_ST		0x04
+
+#define	hfc_CONNECT_B2_HFC_from_ST		0x00
+#define	hfc_CONNECT_B2_HFC_from_GCI		0x08
+#define hfc_CONNECT_B2_ST_from_HFC		0x00
+#define hfc_CONNECT_B2_ST_from_GCI		0x10
+#define hfc_CONNECT_B2_GCI_from_HFC		0x00
+#define hfc_CONNECT_B2_GCI_from_ST		0x20
+
+/* bits in the TRM register */
+#define hfc_TRM_TRANS_INT_00	0x00
+#define hfc_TRM_TRANS_INT_01	0x01
+#define hfc_TRM_TRANS_INT_10	0x02
+#define hfc_TRM_TRANS_INT_11	0x04
+#define hfc_TRM_ECHO		0x20
+#define hfc_TRM_B1_PLUS_B2	0x40
+#define hfc_TRM_IOM_TEST_LOOP	0x80
+
+/* bits in the __SSL and __RSL registers */
+#define	hfc_SRSL_STIO		0x40
+#define hfc_SRSL_ENABLE		0x80
+#define hfc_SRCL_SLOT_MASK	0x1f
+
+/* FIFO memory definitions */
+
+#define hfc_FIFO_SIZE   0x8000
+
+#define hfc_UGLY_FRAMEBUF 0x2000
+
+#define hfc_TX_FIFO_PRELOAD ZT_CHUNKSIZE + 2
+#define hfc_RX_FIFO_PRELOAD 4
+
+/* NOTE: FIFO pointers are not declared volatile because accesses to the
+ *       FIFOs are inherently safe.
+ */
+
+#ifdef DEBUG
+extern int debug_level;
+#endif
+
+struct hfc_chan;
+
+struct hfc_chan_simplex {
+	struct hfc_chan_duplex *chan;
+
+	u8 zaptel_buffer[ZT_CHUNKSIZE];
+
+	u8 ugly_framebuf[hfc_UGLY_FRAMEBUF];
+	int ugly_framebuf_size;
+	u16 ugly_framebuf_off;
+
+	void *z1_base,*z2_base;
+	void *fifo_base;
+	void *z_base;
+	u16 z_min;
+	u16 z_max;
+	u16 fifo_size;
+
+	u8 *f1,*f2;
+	u8 f_min;
+	u8 f_max;
+	u8 f_num;
+	
+	unsigned long long frames;
+	unsigned long long bytes;
+	unsigned long long fifo_full;
+	unsigned long long crc;
+	unsigned long long fifo_underrun;
+};
+
+enum hfc_chan_status {
+	free,
+	open_framed,
+	open_voice,
+	sniff_aux,
+	loopback,
+};
+
+struct hfc_chan_duplex {
+	struct hfc_card *card;
+
+	char *name;
+	int number;
+
+	enum hfc_chan_status status;
+	int open_by_netdev;
+	int open_by_zaptel;
+
+	unsigned short protocol;
+
+	spinlock_t lock;
+
+	struct hfc_chan_simplex rx;
+	struct hfc_chan_simplex tx;
+
+	struct net_device *netdev;
+	struct net_device_stats net_device_stats;
+};
+
+typedef struct hfc_card {
+	int cardnum;
+	spinlock_t lock;
+
+	int ticks;
+
+	struct pci_dev *pcidev;
+
+	struct proc_dir_entry *proc_dir;
+	char proc_dir_name[32];
+
+	struct proc_dir_entry *proc_info;
+	struct proc_dir_entry *proc_fifos;
+	struct proc_dir_entry *proc_bufs;
+
+	unsigned long io_bus_mem;
+	void *io_mem;
+
+	dma_addr_t fifo_bus_mem;
+	void *fifo_mem;
+	void *fifos;
+
+	int nt_mode;
+	int sync_loss_reported;
+	int late_irqs;
+
+	u8 l1_state;
+	int fifo_suspended;
+	int ignore_first_timer_interrupt;
+
+	struct {
+		u8 m1;
+		u8 m2;
+		u8 fifo_en;
+		u8 trm;
+		u8 connect;
+		u8 sctrl;
+		u8 sctrl_r;
+		u8 sctrl_e;
+		u8 ctmt;
+		u8 cirm;
+	} regs;
+
+	struct hfc_chan_duplex chans[3];
+	int echo_enabled;
+
+	struct zt_span zt_span;
+	struct zt_chan zt_chans[3];
+
+	int debug_event;
+} hfc_card;
+
+static inline u8 hfc_inb(struct hfc_card *card, int offset)
+{
+ return readb(card->io_mem + offset);
+}
+
+static inline void hfc_outb(struct hfc_card *card, int offset, u8 value)
+{
+ writeb(value, card->io_mem + offset);
+}
+
+#endif
diff -urN zaptel-1.4.11.org/kernel/vzaphfc/vzaphfc_main.c zaptel-1.4.11/kernel/vzaphfc/vzaphfc_main.c
--- zaptel-1.4.11.org/kernel/vzaphfc/vzaphfc_main.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/vzaphfc/vzaphfc_main.c	2008-07-16 22:06:17.221146969 +0200
@@ -0,0 +1,2037 @@
+/*
+ * zaphfc.c - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * Copyright (C) 2006, headiisue GmbH; Jens Wilke
+ * Copyright (C) 2004 Daniele Orlandi
+ * Copyright (C) 2002, 2003, 2004, Junghanns.NET GmbH
+ *
+ * Jens Wilke <jw_vzaphfc@headissue.com>
+ *
+ * Original author of this code is
+ * Daniele "Vihai" Orlandi <daniele@orlandi.com> 
+ *
+ * Major rewrite of the driver made by
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ * Please read the README file for important infos.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+
+#include "vzaphfc.h"
+#include "fifo.h"
+#include "lapd.h"
+
+#if CONFIG_PCI
+
+#define ZT_B1 0
+#define ZT_B2 1
+#define ZT_D 2
+
+#define D 0
+#define B1 1
+#define B2 2
+
+static int modes = 0; // all TE
+static int nt_modes[hfc_MAX_BOARDS] = { [0 ... (hfc_MAX_BOARDS-1)] = -1 };
+static int force_l1_up = 0;
+static int sniff_zaptel_d_channel = 0;
+static struct proc_dir_entry *hfc_proc_zaphfc_dir;
+
+#ifdef DEBUG
+int debug_level = 0;
+#endif
+
+static struct pci_device_id hfc_pci_ids[] = {
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_2BD0,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B000,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B006,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B007,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B008,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B009,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00A,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00B,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00C,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B100,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ABOCOM, PCI_DEVICE_ID_ABOCOM_2BD1,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASUSTEK, PCI_DEVICE_ID_ASUSTEK_0675,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_T_CONCEPT,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_A1T,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ANIGMA, PCI_DEVICE_ID_ANIGMA_MC145575,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ZOLTRIX, PCI_DEVICE_ID_ZOLTRIX_2BD0,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_E,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_E,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_A,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_A,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_SITECOM, PCI_DEVICE_ID_SITECOM_3069,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, hfc_pci_ids);
+
+static int __devinit hfc_probe(struct pci_dev *dev
+			, const struct pci_device_id *ent);
+static void __devexit hfc_remove(struct pci_dev *dev);
+
+struct pci_driver hfc_driver = {
+	.name     = hfc_DRIVER_NAME,
+	.id_table = hfc_pci_ids,
+	.probe    = hfc_probe,
+	.remove   = hfc_remove,
+};
+
+/******************************************
+ * HW routines
+ ******************************************/
+
+static void hfc_softreset(struct hfc_card *card)
+{
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"resetting\n",
+		card->cardnum);
+
+	hfc_outb(card, hfc_CIRM, hfc_CIRM_RESET);	// softreset on
+	udelay(6);	  // wait at least 5.21us
+	hfc_outb(card, hfc_CIRM, 0);	// softreset off
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((hfc_RESET_DELAY * HZ) / 1000);	// wait 20 ms
+}
+
+void hfc_resetCard(struct hfc_card *card)
+{
+	card->regs.m1 = 0;
+	hfc_outb(card, hfc_INT_M1, card->regs.m1);	// no ints
+
+	card->regs.m2 = 0;
+	hfc_outb(card, hfc_INT_M2, card->regs.m2);	// not at all
+
+	hfc_softreset(card);
+
+	card->regs.trm = 0;
+	hfc_outb(card, hfc_TRM, card->regs.trm);
+
+	// Select the non-capacitive line mode for the S/T interface */
+	card->regs.sctrl = hfc_SCTRL_NONE_CAP;
+
+	if (card->nt_mode) {
+		// ST-Bit delay for NT-Mode
+		hfc_outb(card, hfc_CLKDEL, hfc_CLKDEL_NT);
+
+		card->regs.sctrl |= hfc_SCTRL_MODE_NT;
+	} else {
+		// ST-Bit delay for TE-Mode
+		hfc_outb(card, hfc_CLKDEL, hfc_CLKDEL_TE);
+
+		card->regs.sctrl |= hfc_SCTRL_MODE_TE;
+	}
+
+	hfc_outb(card, hfc_SCTRL, card->regs.sctrl);
+
+	// S/T Auto awake
+	card->regs.sctrl_e = hfc_SCTRL_E_AUTO_AWAKE;
+	hfc_outb(card, hfc_SCTRL_E, card->regs.sctrl_e);
+
+	// No B-channel enabled at startup
+	card->regs.sctrl_r = 0;
+	hfc_outb(card, hfc_SCTRL_R, card->regs.sctrl_r);
+
+	// HFC Master Mode
+	hfc_outb(card, hfc_MST_MODE, hfc_MST_MODE_MASTER);
+
+	// Connect internal blocks
+	card->regs.connect =
+		hfc_CONNECT_B1_HFC_from_ST |
+		hfc_CONNECT_B1_ST_from_HFC |
+		hfc_CONNECT_B1_GCI_from_HFC |
+		hfc_CONNECT_B2_HFC_from_ST |
+		hfc_CONNECT_B2_ST_from_HFC |
+		hfc_CONNECT_B2_GCI_from_HFC;
+	hfc_outb(card, hfc_CONNECT, card->regs.connect);
+
+	// All bchans are HDLC by default, not useful, actually
+	// since mode is set during open()
+	hfc_outb(card, hfc_CTMT, 0);
+
+	// bit order
+	hfc_outb(card, hfc_CIRM, 0);
+
+	// Enable D-rx FIFO. At least one FIFO must be enabled (by specs)
+	card->regs.fifo_en = hfc_FIFOEN_DRX;
+	hfc_outb(card, hfc_FIFO_EN, card->regs.fifo_en);
+
+	card->late_irqs=0;
+
+	// Clear already pending ints
+	hfc_inb(card, hfc_INT_S1);
+	hfc_inb(card, hfc_INT_S2);
+
+	// Enable IRQ output
+	card->regs.m1 = hfc_INTS_DREC | hfc_INTS_L1STATE | hfc_INTS_TIMER;
+	hfc_outb(card, hfc_INT_M1, card->regs.m1);
+
+	card->regs.m2 = hfc_M2_IRQ_ENABLE;
+	hfc_outb(card, hfc_INT_M2, card->regs.m2);
+
+	// Unlocks the states machine
+	hfc_outb(card, hfc_STATES, 0);
+
+	// There's no need to explicitly activate L1 now.
+	// Activation is managed inside the interrupt routine.
+}
+
+static void hfc_update_fifo_state(struct hfc_card *card)
+{
+	// I'm not sure if irqsave is needed but there could be a race
+	// condition since hfc_update_fifo_state could be called from
+	// both the IRQ handler and the *_(open|close) functions
+
+	unsigned long flags;
+	spin_lock_irqsave(&card->chans[B1].lock, flags);
+	if (!card->fifo_suspended &&
+		(card->chans[B1].status == open_framed ||
+		card->chans[B1].status == open_voice)) {
+
+ 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_B1RX)) {
+			card->regs.fifo_en |= hfc_FIFOEN_B1RX;
+			hfc_clear_fifo_rx(&card->chans[B1].rx);
+		}
+
+ 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_B1TX)) {
+			card->regs.fifo_en |= hfc_FIFOEN_B1TX;
+			hfc_clear_fifo_tx(&card->chans[B1].tx);
+		}
+	} else {
+ 	 	if(card->regs.fifo_en & hfc_FIFOEN_B1RX)
+			card->regs.fifo_en &= ~hfc_FIFOEN_B1RX;
+ 	 	if(card->regs.fifo_en & hfc_FIFOEN_B1TX)
+			card->regs.fifo_en &= ~hfc_FIFOEN_B1TX;
+	}
+	spin_unlock_irqrestore(&card->chans[B1].lock, flags);
+
+	spin_lock_irqsave(&card->chans[B2].lock, flags);
+	if (!card->fifo_suspended &&
+		(card->chans[B2].status == open_framed ||
+		card->chans[B2].status == open_voice ||
+		card->chans[B2].status == sniff_aux)) {
+
+ 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_B2RX)) {
+			card->regs.fifo_en |= hfc_FIFOEN_B2RX;
+			hfc_clear_fifo_rx(&card->chans[B2].rx);
+		}
+
+ 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_B2TX)) {
+			card->regs.fifo_en |= hfc_FIFOEN_B2TX;
+			hfc_clear_fifo_tx(&card->chans[B2].tx);
+		}
+	} else {
+ 	 	if(card->regs.fifo_en & hfc_FIFOEN_B2RX)
+			card->regs.fifo_en &= ~hfc_FIFOEN_B2RX;
+ 	 	if(card->regs.fifo_en & hfc_FIFOEN_B2TX)
+			card->regs.fifo_en &= ~hfc_FIFOEN_B2TX;
+	}
+	spin_unlock_irqrestore(&card->chans[B2].lock, flags);
+
+	spin_lock_irqsave(&card->chans[D].lock, flags);
+	if (!card->fifo_suspended &&
+		card->chans[D].status == open_framed) {
+
+// 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_DRX)) {
+//			hfc_clear_fifo_rx(&card->chans[B2].rx);
+//
+//			card->chans[B2].rx.ugly_framebuf_size = 0;
+//			card->chans[B2].rx.ugly_framebuf_off = 0;
+//		}
+//
+ 	 	if(!(card->regs.fifo_en & hfc_FIFOEN_DTX)) {
+			card->regs.fifo_en |= hfc_FIFOEN_DTX;
+
+			card->chans[D].tx.ugly_framebuf_size = 0;
+			card->chans[D].tx.ugly_framebuf_off = 0;
+		}
+	} else {
+// 	 	if(card->regs.fifo_en & hfc_FIFOEN_DRX)
+//			card->regs.fifo_en &= ~hfc_FIFOEN_DRX;
+ 	 	if(card->regs.fifo_en & hfc_FIFOEN_DTX)
+			card->regs.fifo_en &= ~hfc_FIFOEN_DTX;
+	}
+	spin_unlock_irqrestore(&card->chans[D].lock, flags);
+
+	hfc_outb(card, hfc_FIFO_EN, card->regs.fifo_en);
+}
+
+static inline void hfc_suspend_fifo(struct hfc_card *card)
+{
+	card->fifo_suspended = TRUE;
+
+	hfc_update_fifo_state(card);
+
+	// When L1 goes down D rx receives garbage; it is nice to
+	// clear it to avoid a CRC error on reactivation
+	// udelay is needed because the FIFO deactivation happens
+	// in 250us
+	udelay(250);
+	hfc_clear_fifo_rx(&card->chans[D].rx);
+
+#ifdef DEBUG
+	if (debug_level >= 3) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"FIFOs suspended\n",
+			card->cardnum);
+	}
+#endif
+}
+
+static inline void hfc_resume_fifo(struct hfc_card *card)
+{
+	card->fifo_suspended = FALSE;
+
+	hfc_update_fifo_state(card);
+
+#ifdef DEBUG
+	if (debug_level >= 3) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"FIFOs resumed\n",
+			card->cardnum);
+	}
+#endif
+}
+
+static void hfc_check_l1_up(struct hfc_card *card)
+{
+	if ((!card->nt_mode && card->l1_state != 7) ||
+		(card->nt_mode && card->l1_state != 3)) {
+// 0 because this is quite verbose when an inferface is unconnected, jaw		
+#if 0
+		if(debug_level >= 1) {
+			printk(KERN_DEBUG hfc_DRIVER_PREFIX
+				"card %d: "
+				"L1 is down, bringing up L1.\n",
+				card->cardnum);
+		}
+#endif
+
+       		hfc_outb(card, hfc_STATES, hfc_STATES_DO_ACTION |
+       					hfc_STATES_ACTIVATE|
+					hfc_STATES_NT_G2_G3);
+       	}
+}
+
+/******************************************
+ * /proc interface functions
+ ******************************************/
+
+struct hfc_status_to_name_names {
+	enum hfc_chan_status status;
+	char *name;
+};
+
+static char *hfc_status_to_name(int status)
+{
+	struct hfc_status_to_name_names names[] = {
+		{ free, "free" },
+		{ open_framed, "framed" },
+		{ open_voice, "voice" },
+		{ sniff_aux, "sniff aux" },
+		{ loopback, "loopback" },
+		};
+
+	int i;
+
+	for (i=0; i<sizeof(names); i++) {
+		if (names[i].status == status)
+			return names[i].name;
+	}
+
+	return "*UNK*";
+}
+
+static void hfc_hexdump(char *src,char *dst, int size)
+{
+	static char hexchars[] = "0123456789ABCDEF";
+
+	int i;
+	for(i=0;i<size;i++) {
+		dst[i*2]  = hexchars[(src[i] & 0xf0) >> 4];
+		dst[i*2+1]= hexchars[src[i] & 0xf];
+	}
+
+	dst[size*2]='\0';
+}
+
+static int hfc_proc_read_info(char *page, char **start,
+		off_t off, int count, 
+		int *eof, void *data)
+{
+	struct hfc_card *card = data;
+	int len;
+
+	u8 chip_id;
+	chip_id = hfc_inb(card, hfc_CHIP_ID);
+
+	len = snprintf(page, PAGE_SIZE,
+		"Driver    : %s\n"
+		"Cardnum   : %d\n"
+		"IRQ       : %d\n"
+		"PCI Mem   : %#08lx (0x%p)\n"
+		"FIFO Mem  : %#08lx (0x%p)\n"
+		"Mode      : %s\n"
+		"CHIP_ID   : %#02x\n"
+		"L1 State  : %c%d\n"
+		"Sync Lost : %s\n"
+		"Late IRQs : %d\n"
+		"FIFO susp : %s\n"
+		"\nChannel     %12s %12s %12s %12s %4s %4s %4s %4s %4s\n"
+		"D         : %12llu %12llu %12llu %12llu %4llu %4llu %4llu %4llu %4llu %c%c %s\n"
+		"B1        : %12llu %12llu %12llu %12llu %4llu %4llu %4llu %4llu %4llu %c%c %s\n"
+		"B2        : %12llu %12llu %12llu %12llu %4llu %4llu %4llu %4llu %4llu %c%c %s\n"
+		,hfc_DRIVER_STRING
+		,card->cardnum
+		,card->pcidev->irq
+		,card->io_bus_mem, card->io_mem
+		,(ulong)card->fifo_bus_mem, card->fifo_mem
+		,card->nt_mode?"NT":"TE"
+		,chip_id
+		,card->nt_mode?'G':'F'
+		,card->l1_state
+		,card->sync_loss_reported?"YES":"NO"
+		,card->late_irqs
+		,card->fifo_suspended?"YES":"NO"
+
+		,"RX Frames","TX Frames","RX Bytes","TX Bytes","RXFF","TXFF","RXU","TXU","CRC"
+		,card->chans[D].rx.frames
+		,card->chans[D].tx.frames
+		,card->chans[D].rx.bytes
+		,card->chans[D].tx.bytes
+		,card->chans[D].rx.fifo_full
+		,card->chans[D].tx.fifo_full
+		,card->chans[D].rx.fifo_underrun
+		,card->chans[D].tx.fifo_underrun
+		,card->chans[D].rx.crc
+		,card->chans[D].open_by_netdev ? 'N' : ' '
+		,card->chans[D].open_by_zaptel ? 'Z' : ' '
+		,hfc_status_to_name(card->chans[D].status)
+
+		,card->chans[B1].rx.frames
+		,card->chans[B1].tx.frames
+		,card->chans[B1].rx.bytes
+		,card->chans[B1].tx.bytes
+		,card->chans[B1].rx.fifo_full
+		,card->chans[B1].tx.fifo_full
+		,card->chans[B1].rx.fifo_underrun
+		,card->chans[B1].tx.fifo_underrun
+		,card->chans[B1].rx.crc
+		,card->chans[B1].open_by_netdev ? 'N' : ' '
+		,card->chans[B1].open_by_zaptel ? 'Z' : ' '
+		,hfc_status_to_name(card->chans[B1].status)
+
+		,card->chans[B2].rx.frames
+		,card->chans[B2].tx.frames
+		,card->chans[B2].rx.bytes
+		,card->chans[B2].tx.bytes
+		,card->chans[B2].rx.fifo_full
+		,card->chans[B2].tx.fifo_full
+		,card->chans[B2].rx.fifo_underrun
+		,card->chans[B2].tx.fifo_underrun
+		,card->chans[B2].rx.crc
+		,card->chans[B2].open_by_netdev ? 'N' : ' '
+		,card->chans[B2].open_by_zaptel ? 'Z' : ' '
+		,hfc_status_to_name(card->chans[B2].status)
+		);
+
+	return len;
+}
+
+static int hfc_proc_read_fifos(char *page, char **start,
+		off_t off, int count, 
+		int *eof, void *data)
+{
+	struct hfc_card *card = data;
+
+	int len;
+	len = snprintf(page, PAGE_SIZE,
+		"            Receive                Transmit\n"
+		"Channel     F1 F2   Z1   Z2 Used   F1 F2   Z1   Z2 Used\n"
+		"D         : %02x %02x %04x %04x %4d   %02x %02x %04x %04x %4d\n"
+		"B1        : %02x %02x %04x %04x %4d   %02x %02x %04x %04x %4d\n"
+		"B2        : %02x %02x %04x %04x %4d   %02x %02x %04x %04x %4d\n"
+		,*card->chans[D].rx.f1
+		,*card->chans[D].rx.f2
+		,*Z1_F2(&card->chans[D].rx)
+		,*Z2_F2(&card->chans[D].rx)
+		,hfc_fifo_used_rx(&card->chans[D].rx)
+		,*card->chans[D].tx.f1
+		,*card->chans[D].tx.f2
+		,*Z1_F1(&card->chans[D].tx)
+		,*Z2_F1(&card->chans[D].tx)
+		,hfc_fifo_used_tx(&card->chans[D].tx)
+
+		,*card->chans[B1].rx.f1
+		,*card->chans[B1].rx.f2
+		,*Z1_F2(&card->chans[B1].rx)
+		,*Z2_F2(&card->chans[B1].rx)
+		,hfc_fifo_used_rx(&card->chans[B1].rx)
+		,*card->chans[B1].tx.f1
+		,*card->chans[B1].tx.f2
+		,*Z1_F1(&card->chans[B1].tx)
+		,*Z2_F1(&card->chans[B1].tx)
+		,hfc_fifo_used_tx(&card->chans[B1].tx)
+
+		,*card->chans[B2].rx.f1
+		,*card->chans[B2].rx.f2
+		,*Z1_F2(&card->chans[B2].rx)
+		,*Z2_F2(&card->chans[B2].rx)
+		,hfc_fifo_used_rx(&card->chans[B2].rx)
+		,*card->chans[B2].tx.f1
+		,*card->chans[B2].tx.f2
+		,*Z1_F1(&card->chans[B2].tx)
+		,*Z2_F1(&card->chans[B2].tx)
+		,hfc_fifo_used_tx(&card->chans[B2].tx)
+		);
+
+	return len;
+}
+
+static int hfc_proc_read_bufs(char *page, char **start,
+		off_t off, int count, 
+		int *eof, void *data)
+{
+	struct hfc_card *card = data;
+	int len;
+
+	char hex_rchunk[3][ZT_CHUNKSIZE * 2 + 1];
+	char hex_wchunk[3][ZT_CHUNKSIZE * 2 + 1];
+
+	hfc_hexdump(card->chans[D].rx.zaptel_buffer, hex_rchunk[0], ZT_CHUNKSIZE);
+	hfc_hexdump(card->chans[D].tx.zaptel_buffer, hex_wchunk[0], ZT_CHUNKSIZE);
+	hfc_hexdump(card->chans[B1].rx.zaptel_buffer, hex_rchunk[1], ZT_CHUNKSIZE);
+	hfc_hexdump(card->chans[B1].tx.zaptel_buffer, hex_wchunk[1], ZT_CHUNKSIZE);
+	hfc_hexdump(card->chans[B2].rx.zaptel_buffer, hex_rchunk[2], ZT_CHUNKSIZE);
+	hfc_hexdump(card->chans[B2].tx.zaptel_buffer, hex_wchunk[2], ZT_CHUNKSIZE);
+
+	len = snprintf(page, PAGE_SIZE,
+		"Channel    Read Chunk       Write Chunk\n"
+		"D         : %16s %16s\n"
+		"B1        : %16s %16s\n"
+		"B2        : %16s %16s\n"
+		,hex_rchunk[0],hex_wchunk[0]
+		,hex_rchunk[1],hex_wchunk[1]
+		,hex_rchunk[2],hex_wchunk[2]
+		);
+
+	return len;
+}
+
+/******************************************
+ * net_device interface functions
+ ******************************************/
+
+static int hfc_open(struct net_device *netdev)
+{
+	struct hfc_chan_duplex *chan = netdev->priv;
+	struct hfc_card *card = chan->card;
+
+	spin_lock(&chan->lock);
+
+	if (chan->status != free &&
+		(chan->number != D || chan->status != open_framed)) {
+		spin_unlock(&chan->lock);
+		return -EBUSY;
+	}
+
+	chan->status = open_framed;
+	chan->open_by_netdev = TRUE;
+
+	spin_unlock(&chan->lock);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"chan %s opened.\n",
+		card->cardnum,
+		chan->name);
+
+	return 0;
+}
+
+static int hfc_close(struct net_device *netdev)
+{
+	struct hfc_chan_duplex *chan = netdev->priv;
+	struct hfc_card *card = chan->card;
+
+	spin_lock(&chan->lock);
+
+	if (chan->status != open_framed) {
+		spin_unlock(&chan->lock);
+		return -EINVAL;
+	}
+
+	chan->status = free;
+	chan->open_by_netdev = FALSE;
+
+	spin_unlock(&chan->lock);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"chan %s closed.\n",
+		card->cardnum,
+		chan->name);
+
+	return 0;
+}
+
+static int hfc_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct hfc_chan_duplex *chan = netdev->priv;
+	struct hfc_card *card = chan->card;
+
+	netdev->trans_start = jiffies;
+
+	hfc_check_l1_up(card);
+
+	hfc_fifo_put_frame(&chan->tx, skb->data, skb->len);
+
+	// We're not called from IRQ handler, otherwise we'd need
+	// dev_kfree_skb
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static struct net_device_stats *hfc_get_stats(struct net_device *netdev)
+{
+	struct hfc_chan_duplex *chan = netdev->priv;
+//	struct hfc_card *card = chan->card;
+
+	return &chan->net_device_stats;
+}
+
+static void hfc_set_multicast_list(struct net_device *netdev)
+{
+	struct hfc_chan_duplex *chan = netdev->priv;
+	struct hfc_card *card = chan->card;
+
+	spin_lock(&card->lock);
+
+        if(netdev->flags & IFF_PROMISC && !card->echo_enabled) {
+		if (card->nt_mode) {
+			printk(KERN_INFO hfc_DRIVER_PREFIX
+				"card %d "
+				"is in NT mode, not going promiscuous\n",
+				card->cardnum);
+
+			spin_unlock(&card->lock);
+			return;
+		}
+
+		if (card->chans[B2].status != free) {
+			printk(KERN_INFO hfc_DRIVER_PREFIX
+				"card %d: "
+				"chan %s: is busy, not going promiscuous\n",
+				card->cardnum,
+				card->chans[B2].name);
+
+			spin_unlock(&card->lock);
+			return;
+		}
+
+		card->regs.trm |= hfc_TRM_ECHO;
+		card->regs.m1 |= hfc_INTS_B2REC;
+		card->regs.cirm &= ~hfc_CIRM_B2_REV;
+		card->regs.sctrl &= ~hfc_SCTRL_B2_ENA;
+		card->regs.sctrl_r &= ~hfc_SCTRL_R_B2_ENA;
+		card->regs.connect |= hfc_CONNECT_B2_ST_from_GCI;
+		card->regs.ctmt &= ~hfc_CTMT_TRANSB2;
+
+		card->chans[B2].status = sniff_aux;
+
+		card->echo_enabled = TRUE;
+
+		printk(KERN_INFO hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s entered echo mode on channel %s\n",
+			card->cardnum,
+			chan->name,
+			card->chans[B2].name);
+
+        } else if(!(netdev->flags & IFF_PROMISC) && card->echo_enabled) {
+		if (!card->echo_enabled) {
+			spin_unlock(&card->lock);
+			return;
+		}
+
+		card->regs.trm &= ~hfc_TRM_ECHO;
+		card->regs.m1 &= ~hfc_INTS_B2REC;
+		card->regs.cirm |= hfc_CIRM_B2_REV;
+		card->regs.sctrl &= ~hfc_SCTRL_B2_ENA;
+		card->regs.sctrl_r &= ~hfc_SCTRL_R_B2_ENA;
+		card->regs.connect =
+			hfc_CONNECT_B1_HFC_from_ST |
+			hfc_CONNECT_B1_ST_from_HFC |
+			hfc_CONNECT_B1_GCI_from_HFC |
+			hfc_CONNECT_B2_HFC_from_ST |
+			hfc_CONNECT_B2_ST_from_HFC |
+			hfc_CONNECT_B2_GCI_from_HFC;
+
+		card->chans[B2].status = free;
+
+		card->echo_enabled = FALSE;
+
+		printk(KERN_INFO hfc_DRIVER_PREFIX
+			"card %d: "
+			"chan %s left promiscuous mode.\n",
+			card->cardnum,
+			chan->name);
+	}
+
+	spin_unlock(&card->lock);
+
+	hfc_outb(card, hfc_TRM, card->regs.trm);
+	hfc_outb(card, hfc_CIRM, card->regs.cirm);
+	hfc_outb(card, hfc_SCTRL, card->regs.sctrl);
+	hfc_outb(card, hfc_SCTRL_R, card->regs.sctrl_r);
+	hfc_outb(card, hfc_CONNECT, card->regs.connect);
+	hfc_outb(card, hfc_CTMT, card->regs.ctmt);
+
+	// Enable appropriate B receive interrupt
+	hfc_outb(card, hfc_INT_M1, card->regs.m1);
+
+	hfc_update_fifo_state(card);
+}
+
+/******************************************
+ * Zaptel interface (zaptel sucks)
+ ******************************************/
+
+static int hfc_zap_open(struct zt_chan *zaptel_chan)
+{
+	struct hfc_chan_duplex *chan = zaptel_chan->pvt;
+	struct hfc_card *card = chan->card;
+
+	spin_lock(&chan->lock);
+
+	switch (chan->number) {
+		case D:
+			if (chan->status != free &&
+				chan->status != open_framed) {
+				spin_unlock(&chan->lock);
+				return -EBUSY;
+			}
+
+			chan->status = open_framed;
+		break;
+
+		case B1:
+		case B2:
+			if (chan->status != free) {
+				spin_unlock(&chan->lock);
+				return -EBUSY;
+			}
+
+			chan->status = open_voice;
+		break;
+	}
+
+	chan->open_by_zaptel = TRUE;
+
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#else
+	// Zaptel is buggy
+	try_module_get(THIS_MODULE);
+#endif
+
+	spin_unlock(&chan->lock);
+
+	switch (chan->number) {
+		case D:
+		break;
+
+		case B1:
+			// B1
+			card->regs.m2 |= hfc_M2_PROC_TRANS;
+			card->regs.ctmt |= hfc_CTMT_TRANSB1; // Enable transparent mode
+			card->regs.cirm |= hfc_CIRM_B1_REV; // Reversed bit order
+			card->regs.sctrl |= hfc_SCTRL_B1_ENA; // Enable transmission
+			card->regs.sctrl_r |= hfc_SCTRL_R_B1_ENA; // Enable reception
+		break;
+
+		case B2:
+			// B2
+			card->regs.m2 |= hfc_M2_PROC_TRANS;
+			card->regs.ctmt |= hfc_CTMT_TRANSB2; // Enable transparent mode
+			card->regs.cirm |= hfc_CIRM_B2_REV; // Reversed bit order
+			card->regs.sctrl |= hfc_SCTRL_B2_ENA; // Enable transmission
+			card->regs.sctrl_r |= hfc_SCTRL_R_B2_ENA; // Enable reception
+		break;
+
+	}
+
+	// If not already enabled, enable processing transition (8KHz)
+	// interrupt
+	hfc_outb(card, hfc_INT_M2, card->regs.m2);
+	hfc_outb(card, hfc_CTMT, card->regs.ctmt);
+	hfc_outb(card, hfc_CIRM, card->regs.cirm);
+	hfc_outb(card, hfc_SCTRL, card->regs.sctrl);
+	hfc_outb(card, hfc_SCTRL_R, card->regs.sctrl_r);
+
+	hfc_update_fifo_state(card);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"chan %s opened as %s.\n",
+		card->cardnum,
+		chan->name,
+		zaptel_chan->name);
+
+	return 0;
+}
+
+static int hfc_zap_close(struct zt_chan *zaptel_chan)
+{
+	struct hfc_chan_duplex *chan = zaptel_chan->pvt;
+	struct hfc_card *card = chan->card;
+
+	if (!card) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"hfc_zap_close called with NULL card\n");
+		return -1;
+	}
+
+	spin_lock(&chan->lock);
+
+	if (chan->status == free) {
+		spin_unlock(&chan->lock);
+		return -EINVAL;
+	}
+
+	chan->status = free;
+	chan->open_by_zaptel = FALSE;
+
+	spin_unlock(&chan->lock);
+
+	switch (chan->number) {
+		case D:
+		break;
+
+		case B1:
+			// B1
+			card->regs.ctmt &= ~hfc_CTMT_TRANSB1;
+			card->regs.cirm &= ~hfc_CIRM_B1_REV;
+			card->regs.sctrl &= ~hfc_SCTRL_B1_ENA;
+			card->regs.sctrl_r &= ~hfc_SCTRL_R_B1_ENA;
+		break;
+
+		case B2:
+			// B2
+			card->regs.ctmt &= ~hfc_CTMT_TRANSB2;
+			card->regs.cirm &= ~hfc_CIRM_B2_REV;
+			card->regs.sctrl &= ~hfc_SCTRL_B2_ENA;
+			card->regs.sctrl_r &= ~hfc_SCTRL_R_B2_ENA;
+		break;
+	}
+
+	if (card->chans[B1].status == free &&
+		card->chans[B2].status == free)
+		card->regs.m2 &= ~hfc_M2_PROC_TRANS;
+
+	hfc_outb(card, hfc_INT_M2, card->regs.m2);
+	hfc_outb(card, hfc_CTMT, card->regs.ctmt);
+	hfc_outb(card, hfc_CIRM, card->regs.cirm);
+	hfc_outb(card, hfc_SCTRL, card->regs.sctrl);
+	hfc_outb(card, hfc_SCTRL_R, card->regs.sctrl_r);
+
+	hfc_update_fifo_state(card);
+
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#else
+	// Zaptel is buggy
+	module_put(THIS_MODULE);
+#endif
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"chan %s closed as %s.\n",
+		card->cardnum,
+		chan->name,
+		zaptel_chan->name);
+
+	return 0;
+}
+
+static int hfc_zap_rbsbits(struct zt_chan *chan, int bits)
+{
+	return 0;
+}
+
+static int hfc_zap_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data)
+{
+	switch(cmd) {
+		default:
+			return -ENOTTY;
+	}
+
+	return 0;
+}
+
+static int hfc_zap_startup(struct zt_span *span)
+{
+	struct hfc_card *card = span->pvt;
+	int alreadyrunning;
+
+	if (!card) {
+		printk(KERN_INFO hfc_DRIVER_PREFIX
+			"card %d: "
+			"no card for span at startup!\n",
+			card->cardnum);
+	}
+
+	alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+
+	if (!alreadyrunning) {
+		span->chans[ZT_D].flags &= ~ZT_FLAG_HDLC;
+		span->chans[ZT_D].flags |= ZT_FLAG_BRIDCHAN;
+		span->flags |= ZT_FLAG_RUNNING;
+	}
+
+	return 0;
+}
+
+static int hfc_zap_shutdown(struct zt_span *span)
+{
+	return 0;
+}
+
+static int hfc_zap_maint(struct zt_span *span, int cmd)
+{
+	return 0;
+}
+
+static int hfc_zap_chanconfig(struct zt_chan *chan, int sigtype)
+{
+	return 0;
+}
+
+static int hfc_zap_spanconfig(struct zt_span *span, struct zt_lineconfig *lc)
+{
+	span->lineconfig = lc->lineconfig;
+
+	return 0;
+}
+
+static int hfc_zap_initialize(struct hfc_card *card)
+{
+	int i;
+	memset(&card->zt_span, 0x0, sizeof(struct zt_span));
+
+	snprintf(card->zt_span.name, sizeof(card->zt_span.name),
+		 "ZTHFC%d", card->cardnum + 1);
+
+	snprintf(card->zt_span.desc, sizeof(card->zt_span.desc),
+			hfc_DRIVER_DESCR " card %d [%s]",
+			card->cardnum,
+			card->nt_mode?"NT":"TE");
+
+	card->zt_span.spanconfig = hfc_zap_spanconfig;
+	card->zt_span.chanconfig = hfc_zap_chanconfig;
+	card->zt_span.startup = hfc_zap_startup;
+	card->zt_span.shutdown = hfc_zap_shutdown;
+	card->zt_span.maint = hfc_zap_maint;
+	card->zt_span.rbsbits = hfc_zap_rbsbits;
+	card->zt_span.open = hfc_zap_open;
+	card->zt_span.close = hfc_zap_close;
+	card->zt_span.ioctl = hfc_zap_ioctl;
+
+	card->zt_span.chans = card->zt_chans;
+	card->zt_span.channels = 3;
+	card->zt_span.deflaw = ZT_LAW_ALAW;
+	card->zt_span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_CCS; // <--- this is really BS
+	card->zt_span.offset = 0;
+	init_waitqueue_head(&card->zt_span.maintq);
+	card->zt_span.pvt = card;
+
+	for (i = 0; i < card->zt_span.channels; i++) {
+		memset(&card->zt_chans[i], 0x0, sizeof(struct zt_chan));
+
+		snprintf(card->zt_chans[i].name, sizeof(card->zt_chans[i].name),
+				"ZTHFC%d/%d/%d",
+				card->cardnum + 1, 0, i + 1);
+
+		printk(KERN_INFO hfc_DRIVER_PREFIX
+			"card %d: "
+			"registered %s\n",
+			card->cardnum,
+			card->zt_chans[i].name);
+
+		card->zt_chans[i].sigcap =  ZT_SIG_EM | ZT_SIG_CLEAR |
+			ZT_SIG_FXSLS | ZT_SIG_FXSGS |
+			ZT_SIG_FXSKS | ZT_SIG_FXOLS |
+			ZT_SIG_FXOGS | ZT_SIG_FXOKS |
+			ZT_SIG_CAS | ZT_SIG_SF;
+
+		card->zt_chans[i].chanpos = i + 1; 
+	}
+
+	card->zt_chans[ZT_D].readchunk  = card->chans[D].rx.zaptel_buffer;
+	card->zt_chans[ZT_D].writechunk = card->chans[D].tx.zaptel_buffer;
+	card->zt_chans[ZT_D].pvt = &card->chans[D];
+
+	card->zt_chans[ZT_B1].readchunk  = card->chans[B1].rx.zaptel_buffer;
+	card->zt_chans[ZT_B1].writechunk = card->chans[B1].tx.zaptel_buffer;
+	card->zt_chans[ZT_B1].pvt = &card->chans[B1];
+
+	card->zt_chans[ZT_B2].readchunk  = card->chans[B2].rx.zaptel_buffer;
+	card->zt_chans[ZT_B2].writechunk = card->chans[B2].tx.zaptel_buffer;
+	card->zt_chans[ZT_B2].pvt = &card->chans[B2];
+
+	if (zt_register(&card->zt_span,0)) {
+		printk(KERN_CRIT "unable to register zaptel device!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void hfc_zap_transmit(struct hfc_chan_simplex *chan)
+{
+	hfc_fifo_put(chan, chan->zaptel_buffer, ZT_CHUNKSIZE);
+}
+
+static void hfc_zap_receive(struct hfc_chan_simplex *chan)
+{
+	hfc_fifo_get(chan, chan->zaptel_buffer, ZT_CHUNKSIZE);
+}
+
+/******************************************
+ * Interrupt Handler
+ ******************************************/
+
+static void hfc_handle_timer_interrupt(struct hfc_card *card);
+static void hfc_handle_state_interrupt(struct hfc_card *card);
+static void hfc_handle_processing_interrupt(struct hfc_card *card);
+static void hfc_frame_arrived(struct hfc_chan_duplex *chan);
+static void hfc_handle_voice(struct hfc_card *card);
+
+ZAP_IRQ_HANDLER(hfc_interrupt)
+{
+	struct hfc_card *card = dev_id;
+	unsigned long flags;
+	u8 status,s1,s2;
+
+	if (!card) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"spurious interrupt (IRQ %d)\n",
+			irq);
+		return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&card->lock, flags);
+	status = hfc_inb(card, hfc_STATUS);
+	if (!(status & hfc_STATUS_ANYINT)) {
+		// maybe we are sharing the irq
+		spin_unlock_irqrestore(&card->lock,flags);
+		return IRQ_NONE;
+	}
+
+	/* We used to ingore the IRQ when the card was in processing
+	 * state but apparently there is no restriction to access the
+	 * card in such state:
+	 *
+	 * Joerg Ciesielski wrote:
+	 * > There is no restriction for the IRQ handler to access
+	 * > HFC-S PCI during processing phase. A IRQ latency of 375 us
+	 * > is also no problem since there are no interrupt sources in
+	 * > HFC-S PCI which must be handled very fast.
+	 * > Due to its deep fifos the IRQ latency can be several ms with
+	 * > out the risk of loosing data. Even the S/T state interrupts
+	 * > must not be handled with a latency less than <5ms.
+	 * >
+	 * > The processing phase only indicates that HFC-S PCI is
+	 * > processing the Fifos as PCI master so that data is read and
+	 * > written in the 32k memory window. But there is no restriction
+	 * > to access data in the memory window during this time.
+	 *
+	 * // if (status & hfc_STATUS_PCI_PROC) {
+	 * // return IRQ_HANDLED;
+	 * // }
+	 */
+
+	s1 = hfc_inb(card, hfc_INT_S1);
+	s2 = hfc_inb(card, hfc_INT_S2);
+
+	if (s1 != 0) {
+		if (s1 & hfc_INTS_TIMER) {
+			// timer (bit 7)
+			hfc_handle_timer_interrupt(card);
+		}
+
+		if (s1 & hfc_INTS_L1STATE) {
+			// state machine (bit 6)
+			hfc_handle_state_interrupt(card);
+		}
+
+		if (s1 & hfc_INTS_DREC) {
+			// D chan RX (bit 5)
+			hfc_frame_arrived(&card->chans[D]);
+		}
+
+		if (s1 & hfc_INTS_B1REC) {
+			// B1 chan RX (bit 3)
+			hfc_frame_arrived(&card->chans[B1]);
+		}
+
+		if (s1 & hfc_INTS_B2REC) {
+			// B2 chan RX (bit 4)
+			hfc_frame_arrived(&card->chans[B2]);
+		}
+
+		if (s1 & hfc_INTS_DTRANS) {
+			// D chan TX (bit 2)
+		}
+
+		if (s1 & hfc_INTS_B1TRANS) {
+			// B1 chan TX (bit 0)
+		}
+
+		if (s1 & hfc_INTS_B2TRANS) {
+			// B2 chan TX (bit 1)
+		}
+
+	}
+
+	if (s2 != 0) {
+		if (s2 & hfc_M2_PMESEL) {
+			// kaboom irq (bit 7)
+
+			/* CologneChip says:
+			 *
+			 * the meaning of this fatal error bit is that HFC-S PCI as PCI
+			 * master could not access the PCI bus within 125us to finish its
+			 * data processing. If this happens only very seldom it does not
+			 * cause big problems but of course some B-channel or D-channel
+			 * data will be corrupted due to this event.
+			 *
+			 * Unfortunately this bit is only set once after the problem occurs
+			 * and can only be reseted by a software reset. That means it is not
+			 * easily possible to check how often this fatal error happens.
+			 */
+
+			if(!card->sync_loss_reported) {
+				printk(KERN_CRIT hfc_DRIVER_PREFIX
+					"card %d: "
+					"sync lost, pci performance too low!\n",
+					card->cardnum);
+
+				card->sync_loss_reported = TRUE;
+			}
+		}
+
+		if (s2 & hfc_M2_GCI_MON_REC) {
+			// RxR monitor channel (bit 2)
+		}
+
+		if (s2 & hfc_M2_GCI_I_CHG) {
+			// GCI I-change  (bit 1)
+		}
+
+		if (s2 & hfc_M2_PROC_TRANS){
+			// processing/non-processing transition  (bit 0)
+			hfc_handle_processing_interrupt(card);
+		}
+
+	}
+
+	spin_unlock_irqrestore(&card->lock,flags);
+
+	return IRQ_HANDLED;
+}
+
+static void hfc_handle_timer_interrupt(struct hfc_card *card)
+{
+	if(card->ignore_first_timer_interrupt) {
+		card->ignore_first_timer_interrupt = FALSE;
+		return;
+	}
+
+	if ((card->nt_mode && card->l1_state == 3) ||
+		(!card->nt_mode && card->l1_state == 7)) {
+
+		card->regs.ctmt &= ~hfc_CTMT_TIMER_MASK;
+		hfc_outb(card, hfc_CTMT, card->regs.ctmt);
+
+		hfc_resume_fifo(card);
+	}
+}
+
+static void hfc_handle_state_interrupt(struct hfc_card *card)
+{
+	u8 new_state = hfc_inb(card,hfc_STATES)  & hfc_STATES_STATE_MASK;
+
+#ifdef DEBUG
+	if (debug_level >= 1) {
+		printk(KERN_DEBUG hfc_DRIVER_PREFIX
+			"card %d: "
+			"layer 1 state = %c%d\n",
+			card->cardnum,
+			card->nt_mode?'G':'F',
+			new_state);
+	}
+#endif
+
+	if (card->nt_mode) {
+		// NT mode
+
+		if (new_state == 3) {
+			// fix to G3 state (see specs)
+			hfc_outb(card, hfc_STATES, hfc_STATES_LOAD_STATE | 3);
+		}
+
+		if (new_state == 3 && card->l1_state != 3) {
+			hfc_resume_fifo(card);
+		}
+
+		if (new_state != 3 && card->l1_state == 3) {
+			hfc_suspend_fifo(card);
+		}
+	} else {
+		if (new_state == 3) {
+			// Keep L1 up... zaptel & libpri expects a always up L1...
+			// Enable only  when using an unpatched libpri
+
+			if (force_l1_up) {
+				hfc_outb(card, hfc_STATES,
+					hfc_STATES_DO_ACTION |
+					hfc_STATES_ACTIVATE|
+					hfc_STATES_NT_G2_G3);
+			}
+		}
+
+		if (new_state == 7 && card->l1_state != 7) {
+			// TE is now active, schedule FIFO activation after
+			// some time, otherwise the first frames are lost
+
+			card->regs.ctmt |= hfc_CTMT_TIMER_50 | hfc_CTMT_TIMER_CLEAR;
+			hfc_outb(card, hfc_CTMT, card->regs.ctmt);
+
+			// Activating the timer firest an interrupt immediately, we
+			// obviously need to ignore it
+			card->ignore_first_timer_interrupt = TRUE;
+		}
+
+		if (new_state != 7 && card->l1_state == 7) {
+			// TE has become inactive, disable FIFO
+			hfc_suspend_fifo(card);
+		}
+	}
+
+	card->l1_state = new_state;
+}
+
+static void hfc_handle_processing_interrupt(struct hfc_card *card)
+{
+	int available_bytes=0;
+
+	// Synchronize with the first enabled channel
+	if(card->regs.fifo_en & hfc_FIFOEN_B1RX)
+		available_bytes = hfc_fifo_used_rx(&card->chans[B1].rx);
+	if(card->regs.fifo_en & hfc_FIFOEN_B2RX)
+		available_bytes = hfc_fifo_used_rx(&card->chans[B2].rx);
+	else
+		available_bytes = -1;
+
+	if ((available_bytes == -1 && card->ticks == 8) ||
+		available_bytes >= ZT_CHUNKSIZE + hfc_RX_FIFO_PRELOAD) {
+		card->ticks = 0;
+
+		if (available_bytes > ZT_CHUNKSIZE*2 + hfc_RX_FIFO_PRELOAD) {
+			card->late_irqs++;
+			// we are out of sync, clear fifos, jaw
+			hfc_clear_fifo_rx(&card->chans[B1].rx);
+			hfc_clear_fifo_tx(&card->chans[B1].tx);
+			hfc_clear_fifo_rx(&card->chans[B2].rx);
+			hfc_clear_fifo_tx(&card->chans[B2].tx);
+
+#ifdef DEBUG
+			if (debug_level >= 4) {
+				printk(KERN_DEBUG hfc_DRIVER_PREFIX
+					"card %d: "
+					"late IRQ, %d bytes late\n",
+					card->cardnum,
+					available_bytes -
+						(ZT_CHUNKSIZE +
+						 hfc_RX_FIFO_PRELOAD));
+			}
+#endif
+		} else {
+			hfc_handle_voice(card);
+		}
+	}
+
+	card->ticks++;
+}
+
+static void hfc_sniff_zaptel_d_channel(struct hfc_card *card)
+{
+	struct sk_buff *skb =
+		dev_alloc_skb(card->chans[D].tx.ugly_framebuf_size);
+
+	if (!skb) {
+		printk(KERN_ERR hfc_DRIVER_PREFIX
+			"card %d: "
+			"cannot allocate skb: sniffed frame dropped\n",
+			card->cardnum);
+		return;
+	}
+
+	skb->dev = card->chans[D].netdev;
+	skb->protocol = htons(card->chans[D].protocol);
+#ifndef CHECKSUM_HW
+	skb->ip_summed = CHECKSUM_COMPLETE;
+#else
+	skb->ip_summed = CHECKSUM_HW;
+#endif	
+	skb->pkt_type = PACKET_OUTGOING;
+
+	memcpy(skb_put(skb, card->chans[D].tx.ugly_framebuf_size),
+		card->chans[D].tx.ugly_framebuf,
+		card->chans[D].tx.ugly_framebuf_size);
+
+	netif_rx(skb);
+}
+
+static void hfc_handle_voice(struct hfc_card *card)
+{
+	if (card->chans[B1].status != open_voice &&
+		card->chans[B2].status != open_voice)
+		return;
+
+	card->zt_chans[ZT_D].bytes2transmit = 0;
+	card->zt_chans[ZT_D].maxbytes2transmit = ZT_CHUNKSIZE;
+
+	zt_transmit(&card->zt_span);
+
+	if (card->regs.fifo_en & hfc_FIFOEN_B1TX)
+		hfc_zap_transmit(&card->chans[B1].tx);
+	if (card->regs.fifo_en & hfc_FIFOEN_B2TX)
+		hfc_zap_transmit(&card->chans[B2].tx);
+
+       	if (card->zt_chans[ZT_D].bytes2transmit) {
+		hfc_check_l1_up(card);
+
+       		memcpy(card->chans[D].tx.ugly_framebuf +
+       			card->chans[D].tx.ugly_framebuf_size,
+       			card->chans[D].tx.zaptel_buffer,
+       			card->zt_chans[ZT_D].bytes2transmit);
+
+       		card->chans[D].tx.ugly_framebuf_size +=
+       			card->zt_chans[ZT_D].bytes2transmit;
+
+       		if (card->zt_chans[ZT_D].eoftx) {
+       			hfc_fifo_put_frame(&card->chans[D].tx,
+       				 card->chans[D].tx.ugly_framebuf,
+       				 card->chans[D].tx.ugly_framebuf_size);
+
+			if (sniff_zaptel_d_channel)
+				hfc_sniff_zaptel_d_channel(card);
+
+			card->chans[D].tx.ugly_framebuf_size = 0;
+			card->zt_chans[ZT_D].eoftx = FALSE;
+		}
+	}
+
+	if (card->regs.fifo_en & hfc_FIFOEN_B1RX)
+		hfc_zap_receive(&card->chans[B1].rx);
+	else
+		memset(&card->chans[B1].rx.zaptel_buffer, 0x7f,
+			sizeof(card->chans[B1].rx.zaptel_buffer));
+
+	if (card->regs.fifo_en & hfc_FIFOEN_B2RX)
+		hfc_zap_receive(&card->chans[B2].rx);
+	else
+		memset(&card->chans[B2].rx.zaptel_buffer, 0x7f,
+			sizeof(card->chans[B1].rx.zaptel_buffer));
+
+	// Echo cancellation
+	zt_ec_chunk(&card->zt_chans[ZT_B1],
+			card->chans[B1].rx.zaptel_buffer,
+			card->chans[B1].tx.zaptel_buffer);
+	zt_ec_chunk(&card->zt_chans[ZT_B2],
+			card->chans[B2].rx.zaptel_buffer,
+			card->chans[B2].tx.zaptel_buffer);
+
+	// If there's a frame in the FIFO, read it all and make it
+	// available to zaptel
+	if (hfc_fifo_has_frames(&card->chans[D].rx)) {
+		hfc_frame_arrived(&card->chans[D]);
+	}
+
+	// Stupid zaptel frame handling
+	if (!card->chans[D].rx.ugly_framebuf_size) {
+		// hmm....ok, let zaptel receive nothing
+		card->zt_chans[ZT_D].bytes2receive = 0;
+		card->zt_chans[ZT_D].eofrx = FALSE;
+	}
+	else if (card->chans[D].rx.ugly_framebuf_size -
+		card->chans[D].rx.ugly_framebuf_off > ZT_CHUNKSIZE) {
+
+		// the frame is longer than ZT_CHUNKSIZE
+		memcpy(card->chans[D].rx.zaptel_buffer,
+			card->chans[D].rx.ugly_framebuf+
+			card->chans[D].rx.ugly_framebuf_off,
+			ZT_CHUNKSIZE);
+
+		card->zt_chans[ZT_D].bytes2receive = ZT_CHUNKSIZE;
+		card->zt_chans[ZT_D].eofrx = FALSE;
+
+		card->chans[D].rx.ugly_framebuf_off += ZT_CHUNKSIZE;
+	} else {
+		// we can read it all
+		memcpy(card->chans[D].rx.zaptel_buffer,
+			card->chans[D].rx.ugly_framebuf+
+			card->chans[D].rx.ugly_framebuf_off,
+			card->chans[D].rx.ugly_framebuf_size);
+
+		card->zt_chans[ZT_D].bytes2receive = card->chans[D].rx.ugly_framebuf_size-
+			card->chans[D].rx.ugly_framebuf_off;
+		card->zt_chans[ZT_D].eofrx = TRUE;
+
+		card->chans[D].rx.ugly_framebuf_size = 0;
+		card->chans[D].rx.ugly_framebuf_off = 0;
+	}
+
+	if (card->zt_span.flags & ZT_FLAG_RUNNING) {
+		zt_receive(&card->zt_span);
+	}
+
+}
+
+static void hfc_frame_arrived(struct hfc_chan_duplex *chan)
+{
+	struct hfc_card *card = chan->card;
+	int antiloop = 16;
+	struct sk_buff *skb;
+	
+	while(hfc_fifo_has_frames(&chan->rx) && --antiloop) {
+		int frame_size = hfc_fifo_get_frame_size(&chan->rx);
+
+		if (frame_size < 3) {
+#ifdef DEBUG
+			if (debug_level>=2)
+				printk(KERN_DEBUG hfc_DRIVER_PREFIX
+					"card %d: "
+					"chan %s: "
+					"invalid frame received, just %d bytes\n",
+					card->cardnum,
+					chan->name,
+					frame_size);
+#endif
+
+			hfc_fifo_drop_frame(&chan->rx);
+
+			chan->net_device_stats.rx_dropped++;
+
+			continue;
+		} else if(frame_size == 3) {
+#ifdef DEBUG
+			if (debug_level>=2)
+				printk(KERN_DEBUG hfc_DRIVER_PREFIX
+					"card %d: "
+					"chan %s: "
+					"empty frame received\n",
+					card->cardnum,
+					chan->name);
+#endif
+
+			hfc_fifo_drop_frame(&chan->rx);
+
+			chan->net_device_stats.rx_dropped++;
+
+			continue;
+		}
+
+		if (chan->open_by_zaptel &&
+			card->chans[D].rx.ugly_framebuf_size) {
+				// We have to wait for zaptel to transmit the
+				// frame... wait for next time
+
+				break;
+		}
+
+		skb = dev_alloc_skb(frame_size - 3);
+
+		if (!skb) {
+			printk(KERN_ERR hfc_DRIVER_PREFIX
+				"card %d: "
+				"chan %s: "
+				"cannot allocate skb: frame dropped\n",
+				card->cardnum,
+				chan->name);
+
+			hfc_fifo_drop_frame(&chan->rx);
+
+			chan->net_device_stats.rx_dropped++;
+
+			continue;
+		}
+
+		// Oh... this is the echo channel... redirect to D
+		// channel's netdev
+		if (card->echo_enabled && chan->number == B2) {
+			skb->protocol = htons(card->chans[D].protocol);
+			skb->dev = card->chans[D].netdev;
+			skb->pkt_type = PACKET_OTHERHOST;
+		} else {
+			skb->protocol = htons(chan->protocol);
+			skb->dev = chan->netdev;
+			skb->pkt_type = PACKET_HOST;
+		}
+
+#ifndef CHECKSUM_HW
+		skb->ip_summed = CHECKSUM_COMPLETE;
+#else
+		skb->ip_summed = CHECKSUM_HW;
+#endif
+
+		if (chan->open_by_zaptel) {
+			card->chans[D].rx.ugly_framebuf_size = frame_size - 1;
+
+			if (hfc_fifo_get_frame(&card->chans[D].rx,
+				card->chans[D].rx.ugly_framebuf,
+				frame_size - 1) == -1) {
+				dev_kfree_skb(skb);
+				continue;
+			}
+
+			memcpy(skb_put(skb, frame_size - 3),
+				card->chans[D].rx.ugly_framebuf,
+				frame_size - 3);
+		} else {
+			if (hfc_fifo_get_frame(&chan->rx,
+				skb_put(skb, frame_size - 3),
+				frame_size - 3) == -1) {
+				dev_kfree_skb(skb);
+				continue;
+			}
+		}
+
+		chan->net_device_stats.rx_packets++;
+		chan->net_device_stats.rx_bytes += frame_size - 1;
+
+		netif_rx(skb);
+	}
+
+	if (!antiloop) 
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"Infinite loop detected\n",
+			card->cardnum);
+}
+
+/******************************************
+ * Module initialization and cleanup
+ ******************************************/
+
+static void hfc_setup_lapd(struct hfc_chan_duplex *chan)
+{
+	chan->netdev->priv = chan;
+	chan->netdev->open = hfc_open;
+	chan->netdev->stop = hfc_close;
+	chan->netdev->hard_start_xmit = hfc_xmit_frame;
+	chan->netdev->get_stats = hfc_get_stats;
+	chan->netdev->set_multicast_list = hfc_set_multicast_list;
+
+	memset(chan->netdev->dev_addr, 0x00, sizeof(chan->netdev->dev_addr));
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	SET_MODULE_OWNER(chan->netdev);
+#endif
+}
+
+static int __devinit hfc_probe(struct pci_dev *pci_dev,
+	const struct pci_device_id *ent)
+{
+	static int cardnum=0;
+	int err;
+	int i;
+
+	struct hfc_card *card = NULL;
+	card = kmalloc(sizeof(struct hfc_card), GFP_KERNEL);
+	if (!card) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"unable to kmalloc!\n");
+		err = -ENOMEM;
+		goto err_alloc_hfccard;
+	}
+
+	memset(card, 0x00, sizeof(struct hfc_card));
+	card->cardnum = cardnum;
+	card->pcidev = pci_dev;
+	spin_lock_init(&card->lock);
+
+	pci_set_drvdata(pci_dev, card);
+
+	if ((err = pci_enable_device(pci_dev))) {
+		goto err_pci_enable_device;
+	}
+
+	if ((err = pci_set_dma_mask(pci_dev, PCI_DMA_32BIT))) {
+		printk(KERN_ERR hfc_DRIVER_PREFIX
+			"card %d: "
+			"No suitable DMA configuration available.\n",
+			card->cardnum);
+		goto err_pci_set_dma_mask;
+	}
+
+	pci_write_config_word(pci_dev, PCI_COMMAND, PCI_COMMAND_MEMORY);
+
+	if((err = pci_request_regions(pci_dev, hfc_DRIVER_NAME))) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"cannot request I/O memory region\n",
+			card->cardnum);
+		goto err_pci_request_regions;
+	}
+
+	pci_set_master(pci_dev);
+
+	if (!pci_dev->irq) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"no irq!\n",
+			card->cardnum);
+		err = -ENODEV;
+		goto err_noirq;
+	}
+
+	card->io_bus_mem = pci_resource_start(pci_dev,1);
+	if (!card->io_bus_mem) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"no iomem!\n",
+			card->cardnum);
+		err = -ENODEV;
+		goto err_noiobase;
+	}
+
+	if(!(card->io_mem = ioremap(card->io_bus_mem, hfc_PCI_MEM_SIZE))) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"cannot ioremap I/O memory\n",
+			card->cardnum);
+		err = -ENODEV;
+		goto err_ioremap;
+	}
+
+	// pci_alloc_consistent guarantees alignment (Documentation/DMA-mapping.txt)
+	card->fifo_mem = pci_alloc_consistent(pci_dev, hfc_FIFO_SIZE, &card->fifo_bus_mem);
+	if (!card->fifo_mem) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"unable to allocate FIFO DMA memory!\n",
+			card->cardnum);
+		err = -ENOMEM;
+		goto err_alloc_fifo;
+	}
+
+	memset(card->fifo_mem, 0x00, hfc_FIFO_SIZE);
+
+	card->fifos = card->fifo_mem;
+
+	pci_write_config_dword(card->pcidev, hfc_PCI_MWBA, card->fifo_bus_mem);
+
+	if ((err = request_irq(card->pcidev->irq, &hfc_interrupt,
+		ZAP_IRQ_SHARED, hfc_DRIVER_NAME, card))) {
+		printk(KERN_CRIT hfc_DRIVER_PREFIX
+			"card %d: "
+			"unable to register irq\n",
+			card->cardnum);
+		goto err_request_irq;
+	}
+
+	card->nt_mode = FALSE;
+
+	if (modes & (1 << card->cardnum))
+		card->nt_mode = TRUE;
+
+	for (i=0; i<hfc_MAX_BOARDS; i++) {
+		/* DEBUG printk(KERN_INFO "nt_modes[%i]=%i\n", i, nt_modes[i]); */
+		if (nt_modes[i] == card->cardnum) {
+			card->nt_mode=TRUE;
+		}
+	}
+
+//---------------------------------- D
+	card->chans[D].card = card;
+	card->chans[D].name = "D";
+	card->chans[D].status = free;
+	card->chans[D].number = D;
+	card->chans[D].protocol = ETH_P_LAPD;
+	spin_lock_init(&card->chans[D].lock);
+
+	card->chans[D].rx.chan      = &card->chans[D];
+	card->chans[D].rx.fifo_base = card->fifos + 0x4000;
+	card->chans[D].rx.z_base    = card->fifos + 0x4000;
+	card->chans[D].rx.z1_base   = card->fifos + 0x6080;
+	card->chans[D].rx.z2_base   = card->fifos + 0x6082;
+	card->chans[D].rx.z_min     = 0x0000;
+	card->chans[D].rx.z_max     = 0x01FF;
+	card->chans[D].rx.f_min     = 0x10;
+	card->chans[D].rx.f_max     = 0x1F;
+	card->chans[D].rx.f1        = card->fifos + 0x60a0;
+	card->chans[D].rx.f2        = card->fifos + 0x60a1;
+	card->chans[D].rx.fifo_size = card->chans[D].rx.z_max - card->chans[D].rx.z_min + 1;
+	card->chans[D].rx.f_num     = card->chans[D].rx.f_max - card->chans[D].rx.f_min + 1;
+
+	card->chans[D].tx.chan      = &card->chans[D];
+	card->chans[D].tx.fifo_base = card->fifos + 0x0000;
+	card->chans[D].tx.z_base    = card->fifos + 0x0000;
+	card->chans[D].tx.z1_base   = card->fifos + 0x2080;
+	card->chans[D].tx.z2_base   = card->fifos + 0x2082;
+	card->chans[D].tx.z_min     = 0x0000;
+	card->chans[D].tx.z_max     = 0x01FF;
+	card->chans[D].tx.f_min     = 0x10;
+	card->chans[D].tx.f_max     = 0x1F;
+	card->chans[D].tx.f1        = card->fifos + 0x20a0;
+	card->chans[D].tx.f2        = card->fifos + 0x20a1;
+	card->chans[D].tx.fifo_size = card->chans[D].tx.z_max - card->chans[D].tx.z_min + 1;
+	card->chans[D].tx.f_num     = card->chans[D].tx.f_max - card->chans[D].tx.f_min + 1;
+
+	if(!(card->chans[D].netdev = alloc_netdev(0, "isdn%dd", setup_lapd))) {
+		printk(KERN_ERR hfc_DRIVER_PREFIX
+			"net_device alloc failed, abort.\n");
+		err = -ENOMEM;
+		goto err_alloc_netdev_d;
+	}
+
+	hfc_setup_lapd(&card->chans[D]);
+
+	card->chans[D].netdev->irq = card->pcidev->irq;
+	card->chans[D].netdev->base_addr = card->io_bus_mem;
+/*	card->chans[D].netdev->rmem_start = card->fifo_bus_mem + 0x4000;
+	card->chans[D].netdev->rmem_end = card->fifo_bus_mem + 0x4000 +
+		card->chans[D].rx.fifo_size - 1;*/
+	card->chans[D].netdev->mem_start = card->fifo_bus_mem + 0x0000;
+	card->chans[D].netdev->mem_end = card->fifo_bus_mem + 0x0000 +
+		card->chans[D].tx.fifo_size - 1;
+
+	if((err = register_netdev(card->chans[D].netdev))) {
+		printk(KERN_INFO hfc_DRIVER_PREFIX
+			"card %d: "
+			"Cannot register net device, aborting.\n",
+			card->cardnum);
+		goto err_register_netdev_d;
+	}
+
+//---------------------------------- B1
+	card->chans[B1].card = card;
+	card->chans[B1].name = "B1";
+	card->chans[B1].status = free;
+	card->chans[B1].number = B1;
+	card->chans[B1].protocol = 0;
+	spin_lock_init(&card->chans[B1].lock);
+
+	card->chans[B1].rx.chan      = &card->chans[B1];
+	card->chans[B1].rx.fifo_base = card->fifos + 0x4200;
+	card->chans[B1].rx.z_base    = card->fifos + 0x4000;
+	card->chans[B1].rx.z1_base   = card->fifos + 0x6000;
+	card->chans[B1].rx.z2_base   = card->fifos + 0x6002;
+	card->chans[B1].rx.z_min     = 0x0200;
+	card->chans[B1].rx.z_max     = 0x1FFF;
+	card->chans[B1].rx.f_min     = 0x00;
+	card->chans[B1].rx.f_max     = 0x1F;
+	card->chans[B1].rx.f1        = card->fifos + 0x6080;
+	card->chans[B1].rx.f2        = card->fifos + 0x6081;
+	card->chans[B1].rx.fifo_size = card->chans[B1].rx.z_max - card->chans[B1].rx.z_min + 1;
+	card->chans[B1].rx.f_num     = card->chans[B1].rx.f_max - card->chans[B1].rx.f_min + 1;
+
+	card->chans[B1].tx.chan      = &card->chans[B1];
+	card->chans[B1].tx.fifo_base = card->fifos + 0x0200;
+	card->chans[B1].tx.z_base    = card->fifos + 0x0000;
+	card->chans[B1].tx.z1_base   = card->fifos + 0x2000;
+	card->chans[B1].tx.z2_base   = card->fifos + 0x2002;
+	card->chans[B1].tx.z_min     = 0x0200;
+	card->chans[B1].tx.z_max     = 0x1FFF;
+	card->chans[B1].tx.f_min     = 0x00;
+	card->chans[B1].tx.f_max     = 0x1F;
+	card->chans[B1].tx.f1        = card->fifos + 0x2080;
+	card->chans[B1].tx.f2        = card->fifos + 0x2081;
+	card->chans[B1].tx.fifo_size = card->chans[B1].tx.z_max - card->chans[B1].tx.z_min + 1;
+	card->chans[B1].tx.f_num     = card->chans[B1].tx.f_max - card->chans[B1].tx.f_min + 1;
+
+//	card->chans[B1].netdev->irq = card->pcidev->irq;
+//	card->chans[B1].netdev->base_addr = card->io_bus_mem;
+/*	card->chans[B1].netdev->rmem_start = card->fifo_bus_mem + 0x4200;
+	card->chans[B1].netdev->rmem_end = card->fifo_bus_mem + 0x4200 +
+		card->chans[B1].rx.fifo_size - 1;*/
+//	card->chans[B1].netdev->mem_start = card->fifo_bus_mem + 0x0200;
+//	card->chans[B1].netdev->mem_end = card->fifo_bus_mem + 0x0200 +
+//		card->chans[B1].tx.fifo_size - 1;
+
+//---------------------------------- B2
+	card->chans[B2].card = card;
+	card->chans[B2].name = "B2";
+	card->chans[B2].status = free;
+	card->chans[B2].number = B2;
+	card->chans[B2].protocol = 0;
+	spin_lock_init(&card->chans[B2].lock);
+
+	card->chans[B2].rx.chan      = &card->chans[B2];
+	card->chans[B2].rx.fifo_base = card->fifos + 0x6200,
+	card->chans[B2].rx.z_base    = card->fifos + 0x6000;
+	card->chans[B2].rx.z1_base   = card->fifos + 0x6100;
+	card->chans[B2].rx.z2_base   = card->fifos + 0x6102;
+	card->chans[B2].rx.z_min     = 0x0200;
+	card->chans[B2].rx.z_max     = 0x1FFF;
+	card->chans[B2].rx.f_min     = 0x00;
+	card->chans[B2].rx.f_max     = 0x1F;
+	card->chans[B2].rx.f1        = card->fifos + 0x6180;
+	card->chans[B2].rx.f2        = card->fifos + 0x6181;
+	card->chans[B2].rx.fifo_size = card->chans[B2].rx.z_max - card->chans[B2].rx.z_min + 1;
+	card->chans[B2].rx.f_num     = card->chans[B2].rx.f_max - card->chans[B2].rx.f_min + 1;
+
+	card->chans[B2].tx.chan      = &card->chans[B2];
+	card->chans[B2].tx.fifo_base = card->fifos + 0x2200;
+	card->chans[B2].tx.z_base    = card->fifos + 0x2000;
+	card->chans[B2].tx.z1_base   = card->fifos + 0x2100;
+	card->chans[B2].tx.z2_base   = card->fifos + 0x2102;
+	card->chans[B2].tx.z_min     = 0x0200;
+	card->chans[B2].tx.z_max     = 0x1FFF;
+	card->chans[B2].tx.f_min     = 0x00;
+	card->chans[B2].tx.f_max     = 0x1F;
+	card->chans[B2].tx.f1        = card->fifos + 0x2180;
+	card->chans[B2].tx.f2        = card->fifos + 0x2181;
+	card->chans[B2].tx.fifo_size = card->chans[B2].tx.z_max - card->chans[B2].tx.z_min + 1;
+	card->chans[B2].tx.f_num     = card->chans[B2].tx.f_max - card->chans[B2].tx.f_min + 1;
+
+//	card->chans[B2].netdev->irq = card->pcidev->irq;
+//	card->chans[B2].netdev->base_addr = card->io_bus_mem;
+/*	card->chans[B2].netdev->rmem_start = card->fifo_bus_mem + 0x6200;
+	card->chans[B2].netdev->rmem_end = card->fifo_bus_mem + 0x6200 +
+		card->chans[B2].rx.fifo_size - 1;*/
+//	card->chans[B2].netdev->mem_start = card->fifo_bus_mem + 0x2200;
+//	card->chans[B2].netdev->mem_end = card->fifo_bus_mem + 0x2200 +
+//		card->chans[B2].tx.fifo_size - 1;
+
+// -------------------------------------------------------
+
+	hfc_zap_initialize(card);
+
+	snprintf(card->proc_dir_name,
+			sizeof(card->proc_dir_name),
+			"%d", card->cardnum);
+	card->proc_dir = proc_mkdir(card->proc_dir_name, hfc_proc_zaphfc_dir);
+	card->proc_dir->owner = THIS_MODULE;
+
+	card->proc_info = create_proc_read_entry(
+			"info", 0444, card->proc_dir,
+			hfc_proc_read_info, card);
+	card->proc_info->owner = THIS_MODULE;
+
+	card->proc_fifos = create_proc_read_entry(
+			"fifos", 0400, card->proc_dir,
+			hfc_proc_read_fifos, card);
+	card->proc_fifos->owner = THIS_MODULE;
+
+	card->proc_bufs = create_proc_read_entry(
+			"bufs", 0400, card->proc_dir,
+			hfc_proc_read_bufs, card);
+	card->proc_bufs->owner = THIS_MODULE;
+
+	hfc_resetCard(card);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d configured for %s mode at mem %#lx (0x%p) IRQ %u\n",
+		card->cardnum,
+		card->nt_mode?"NT":"TE",
+		card->io_bus_mem,
+		card->io_mem,
+		card->pcidev->irq); 
+
+	cardnum++;
+
+	return 0;
+
+//	unregister_netdev(card->chans[D].netdev);
+err_register_netdev_d:
+	free_netdev(card->chans[D].netdev);
+err_alloc_netdev_d:
+	free_irq(pci_dev->irq, card);
+err_request_irq:
+	pci_free_consistent(pci_dev, hfc_FIFO_SIZE,
+		card->fifo_mem, card->fifo_bus_mem);
+err_alloc_fifo:
+	iounmap(card->io_mem);
+err_ioremap:
+err_noiobase:
+err_noirq:
+	pci_release_regions(pci_dev);
+err_pci_request_regions:
+err_pci_set_dma_mask:
+err_pci_enable_device:
+	kfree(card);
+err_alloc_hfccard:
+	return err;
+}
+
+static void __devexit hfc_remove(struct pci_dev *pci_dev)
+{
+	struct hfc_card *card = pci_get_drvdata(pci_dev);
+
+	unregister_netdev(card->chans[D].netdev);
+
+//	unsigned long flags;
+//	spin_lock_irqsave(&card->lock,flags);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		"card %d: "
+		"shutting down card at %p.\n",
+		card->cardnum,
+		card->io_mem);
+
+	hfc_softreset(card);
+
+	zt_unregister(&card->zt_span);
+
+
+	// disable memio and bustmaster
+	pci_write_config_word(pci_dev, PCI_COMMAND, 0);
+
+//	spin_unlock_irqrestore(&card->lock,flags);
+
+	remove_proc_entry("bufs", card->proc_dir);
+	remove_proc_entry("fifos", card->proc_dir);
+	remove_proc_entry("info", card->proc_dir);
+	remove_proc_entry(card->proc_dir_name, hfc_proc_zaphfc_dir);
+
+	free_irq(pci_dev->irq, card);
+
+	pci_free_consistent(pci_dev, hfc_FIFO_SIZE,
+		card->fifo_mem, card->fifo_bus_mem);
+
+	iounmap(card->io_mem);
+
+	pci_release_regions(pci_dev);
+
+	pci_disable_device(pci_dev);
+
+	free_netdev(card->chans[D].netdev);
+	kfree(card);
+}
+
+/******************************************
+ * Module stuff
+ ******************************************/
+
+static int __init hfc_init_module(void)
+{
+	int ret;
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		hfc_DRIVER_STRING " loading\n");
+
+	hfc_proc_zaphfc_dir = proc_mkdir(hfc_DRIVER_NAME, proc_root_driver);
+
+	ret = zap_pci_module(&hfc_driver);
+	return ret;
+}
+
+module_init(hfc_init_module);
+
+static void __exit hfc_module_exit(void)
+{
+	pci_unregister_driver(&hfc_driver);
+
+	remove_proc_entry(hfc_DRIVER_NAME, proc_root_driver);
+
+	printk(KERN_INFO hfc_DRIVER_PREFIX
+		hfc_DRIVER_STRING " unloaded\n");
+}
+
+module_exit(hfc_module_exit);
+
+#endif
+
+MODULE_DESCRIPTION(hfc_DRIVER_DESCR);
+MODULE_AUTHOR("Jens Wilke <jw_vzaphfc@headissue.com>, Daniele (Vihai) Orlandi <daniele@orlandi.com>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+#ifdef LINUX26
+
+module_param(modes, int, 0444);
+
+/*
+ * Old 2.6 kernels had module_param_array() macro that receive the counter 
+ * by value.
+ */
+int nt_modes_num_values;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+module_param_array(nt_modes, int, nt_modes_num_values, 0444);
+#else
+module_param_array(nt_modes, int, &nt_modes_num_values, 0444);
+#endif
+
+module_param(force_l1_up, int, 0444);
+module_param(sniff_zaptel_d_channel, int, 0444);
+#ifdef DEBUG
+module_param(debug_level, int, 0444);
+#endif
+
+#else
+
+MODULE_PARM(modes,"i");
+MODULE_PARM(force_l1_up,"i");
+MODULE_PARM(sniff_zaptel_d_channel,"i");
+#ifdef DEBUG
+MODULE_PARM(debug_level,"i");
+#endif
+
+#endif // LINUX26
+
+MODULE_PARM_DESC(modes, "[Deprecated] bit-mask to configure NT mode");
+MODULE_PARM_DESC(nt_modes, "Comma-separated list of card IDs to configure in NT mode");
+MODULE_PARM_DESC(force_l1_up, "Don't allow L1 to go down");
+MODULE_PARM_DESC(sniff_zaptel_d_channel, "Make frames transmitted from zaptel"
+					" appear as received by the board");
+#ifdef DEBUG
+MODULE_PARM_DESC(debug_level, "Debug verbosity level");
+#endif
diff -urN zaptel-1.4.11.org/kernel/wcopenpci.c zaptel-1.4.11/kernel/wcopenpci.c
--- zaptel-1.4.11.org/kernel/wcopenpci.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/wcopenpci.c	2008-07-16 22:06:17.221146969 +0200
@@ -0,0 +1,1843 @@
+/*
+ * Voicetronix OpenPCI Interface Driver for Zapata Telephony interface
+ *
+ * Written by Mark Spencer <markster@linux-support.net>
+ *            Matthew Fredrickson <creslin@linux-support.net>
+ *            Ben Kramer <ben@voicetronix.com.au>
+ *            Ron Lee <ron@voicetronix.com.au>
+ *
+ * Copyright (C) 2001, Linux Support Services, Inc.
+ * Copyright (C) 2005 - 2007, Voicetronix
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ */
+
+/* Conditional debug options */
+#define VERBOSE_TIMING 0
+
+/* Driver constants */
+#define DRIVER_DESCRIPTION  "Voicetronix OpenPCI zaptel driver"
+#define DRIVER_AUTHOR       "Mark Spencer <markster@digium.com> "\
+                            "Voicetronix <support@voicetronix.com.au>"
+
+#define NAME      "wcopenpci"
+#define MAX_PORTS 8	    /* Maximum number of ports on each carrier */
+#define MAX_CARDS 8	    /* Maximum number of carriers per host */
+
+#define DEFAULT_COUNTRY  "AUSTRALIA"
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#ifdef STANDALONE_ZAPATA
+ #include "zaptel.h"
+ #include "../version.h"
+ #include "proslic.h"
+ #include "wctdm.h"
+#else
+ //#include <zaptel/zaptel.h>
+ #error The wcopenpci module must be built with the full zaptel source
+#endif
+
+
+
+/* Compatibility helpers */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+ #include <linux/interrupt.h>
+#else
+ typedef void irqreturn_t;
+ #define IRQ_NONE
+ #define IRQ_HANDLED
+ #define IRQ_RETVAL(x)
+ #define __devexit_p(x) x
+#endif
+
+// Centos4.3 uses a modified 2.6.9 kernel, with no indication that
+// it is different from the mainstream (or even Centos4.2 2.6.9)
+// kernel, so we must crowbar off the dunce-hat manually here.
+#if !defined CENTOS4_3 && LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+ typedef int gfp_t;
+ static inline void *kzalloc( size_t n, gfp_t flags ){
+	void *p = kmalloc(n,flags);
+	if (p) memset(p, 0, n);
+	return p;
+ }
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+ #define DEFINE_MUTEX(x)		DECLARE_MUTEX(x)
+ #define mutex_init(x)			init_MUTEX(x)
+ #define mutex_lock(x)			down(x)
+ #define mutex_lock_interruptible(x)	down_interruptible(x)
+ #define mutex_trylock(x)		down_trylock(x)
+ #define mutex_unlock(x)		up(x)
+#else
+ #include <linux/mutex.h>
+#endif
+
+
+static struct fxo_mode {
+	char *name;
+	int ohs;
+	int ohs2;
+	int rz;
+	int rt;
+	int ilim;
+	int dcv;
+	int mini;
+	int acim;
+	int ring_osc;
+	int ring_x;
+} fxo_modes[] =
+{
+	{ "FCC", 0, 0, 0, 1, 0, 0x3, 0, 0, }, 	/* US, Canada */
+	{ "TBR21", 0, 0, 0, 0, 1, 0x3, 0, 0x2, 0x7e6c, 0x023a, },
+		/* Austria, Belgium, Denmark, Finland, France, Germany, 
+		   Greece, Iceland, Ireland, Italy, Luxembourg, Netherlands,
+		   Norway, Portugal, Spain, Sweden, Switzerland, and UK */
+	{ "ARGENTINA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "AUSTRALIA", 1, 0, 0, 0, 0, 0, 0x3, 0x3, },
+	{ "AUSTRIA", 0, 1, 0, 0, 1, 0x3, 0, 0x3, },
+	{ "BAHRAIN", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "BELGIUM", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "BRAZIL", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "BULGARIA", 0, 0, 0, 0, 1, 0x3, 0x0, 0x3, },
+	{ "CANADA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CHILE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CHINA", 0, 0, 0, 0, 0, 0, 0x3, 0xf, },
+	{ "COLUMBIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "CROATIA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "CYRPUS", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "CZECH", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "DENMARK", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ECUADOR", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "EGYPT", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "ELSALVADOR", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "FINLAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "FRANCE", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "GERMANY", 0, 1, 0, 0, 1, 0x3, 0, 0x3, },
+	{ "GREECE", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "GUAM", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "HONGKONG", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "HUNGARY", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "ICELAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "INDIA", 0, 0, 0, 0, 0, 0x3, 0, 0x4, },
+	{ "INDONESIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "IRELAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ISRAEL", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ITALY", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "JAPAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "JORDAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "KAZAKHSTAN", 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "KUWAIT", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "LATVIA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "LEBANON", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "LUXEMBOURG", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "MACAO", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "MALAYSIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },	/* Current loop >= 20ma */
+	{ "MALTA", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "MEXICO", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "MOROCCO", 0, 0, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "NETHERLANDS", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "NEWZEALAND", 0, 0, 0, 0, 0, 0x3, 0, 0x4, },
+	{ "NIGERIA", 0, 0, 0, 0, 0x1, 0x3, 0, 0x2, },
+	{ "NORWAY", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "OMAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "PAKISTAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "PERU", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "PHILIPPINES", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "POLAND", 0, 0, 1, 1, 0, 0x3, 0, 0, },
+	{ "PORTUGAL", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "ROMANIA", 0, 0, 0, 0, 0, 3, 0, 0, },
+	{ "RUSSIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "SAUDIARABIA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SINGAPORE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SLOVAKIA", 0, 0, 0, 0, 0, 0x3, 0, 0x3, },
+	{ "SLOVENIA", 0, 0, 0, 0, 0, 0x3, 0, 0x2, },
+	{ "SOUTHAFRICA", 1, 0, 1, 0, 0, 0x3, 0, 0x3, },
+	{ "SOUTHKOREA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "SPAIN", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SWEDEN", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SWITZERLAND", 0, 1, 0, 0, 1, 0x3, 0, 0x2, },
+	{ "SYRIA", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "TAIWAN", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "THAILAND", 0, 0, 0, 0, 0, 0, 0x3, 0, },
+	{ "UAE", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "UK", 0, 1, 0, 0, 1, 0x3, 0, 0x5, },
+	{ "USA", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+	{ "YEMEN", 0, 0, 0, 0, 0, 0x3, 0, 0, },
+};
+
+static struct ps_country_reg {
+	const char *country;
+	unsigned short value;
+} ps_country_regs[] = {
+	{"ARGENTINA",  0x8},
+	{"AUSTRALIA",  0xD},
+	{"AUSTRIA",    0xD},
+	{"BAHRAIN",    0xC},
+	{"BELGIUM",    0xC},
+	{"BRAZIL",     0x8},
+	{"BULGARIA",   0xD},
+	{"CANADA",     0x8},
+	{"CHILE",      0x8},
+	{"CHINA",      0xC},
+	{"COLOMBIA",   0x8},
+	{"CROATIA",    0xC},
+	{"CYPRUS",     0xC},
+	{"CZECH",      0xC},
+	{"DENMARK",    0xC},
+	{"ECUADOR",    0x8},
+	{"EGYPT",      0x8},
+	{"ELSALVADOR", 0x8},
+	{"FINLAND",    0xC},
+	{"FRANCE",     0xC},
+	{"GERMANY",    0xD},
+	{"GREECE",     0xC},
+	{"GUAM",       0x8},
+	{"HONGKONG",   0x8},
+	{"HUNGARY",    0x8},
+	{"ICELAND",    0xC},
+	{"INDIA",      0xF},
+	{"INDONESIA",  0x8},
+	{"IRELAND",    0xC},
+	{"ISRAEL",     0xC},
+	{"ITALY",      0xC},
+	{"JAPAN",      0x8},
+	{"JORDAN",     0x8},
+	{"KAZAKHSTAN", 0x8},
+	{"KUWAIT",     0x8},
+	{"LATVIA",     0xC},
+	{"LEBANON",    0xC},
+	{"LUXEMBOURG", 0xC},
+	{"MACAO",      0x8},
+	{"MALAYSIA",   0x8},
+	{"MALTA",      0xC},
+	{"MEXICO",     0x8},
+	{"MOROCCO",    0xC},
+	{"NETHERLANDS",0xC},
+	{"NEWZEALAND", 0xF},
+	{"NIGERIA",    0xC},
+	{"NORWAY",     0xC},
+	{"OMAN",       0x8},
+	{"PAKISTAN",   0x8},
+	{"PERU",       0x8},
+	{"PHILIPPINES",0x8},
+	{"POLAND",     0x8},
+	{"PORTUGAL",   0xC},
+	{"ROMANIA",    0x8},
+	{"RUSSIA",     0x8},
+	{"SAUDIARABIA",0x8},
+	{"SINGAPORE",  0x8},
+	{"SLOVAKIA",   0xE},
+	{"SLOVENIA",   0xE},
+	{"SOUTHAFRICA",0xE},
+	{"SOUTHKOREA", 0x8},
+	{"SPAIN",      0xC},
+	{"SWEDEN",     0xC},
+	{"SWITZERLAND",0xC},
+	{"SYRIA",      0x8},
+	{"TAIWAN",     0x8},
+	{"THAILAND",   0x8},
+	{"UAE",        0x8},
+	{"UK",         0xC},
+	{"USA",        0x8},
+	{"YEMEN",      0x8}
+};
+
+#define INOUT 2
+
+/* Allocate enough memory for two zt chunks, receive and transmit.  Each sample uses
+   32 bits.  Allocate an extra set just for control too */
+#define VT_PCIDMA_BLOCKSIZE (ZT_MAX_CHUNKSIZE * INOUT * MAX_PORTS * 2 * 2)
+#define VT_PCIDMA_MIDDLE    (ZT_MAX_CHUNKSIZE * MAX_PORTS - 4)
+#define VT_PCIDMA_END       (ZT_MAX_CHUNKSIZE * MAX_PORTS * 2 - 4)
+
+#define ID_DATA_MAXSIZE         30
+
+#define NUM_CAL_REGS 12
+#define NUM_FXO_REGS 60
+
+#define TREG(addr)      (wc->ioaddr + addr)
+
+#define TJ_CNTL         TREG(0x00)
+#define TJ_OPER         TREG(0x01)
+#define TJ_AUXC         TREG(0x02)
+#define TJ_AUXD         TREG(0x03)
+#define TJ_MASK0        TREG(0x04)
+#define TJ_MASK1        TREG(0x05)
+#define TJ_INTSTAT      TREG(0x06)
+#define TJ_AUXR         TREG(0x07)
+
+#define TJ_DMAWS        TREG(0x08)
+#define TJ_DMAWI        TREG(0x0c)
+#define TJ_DMAWE        TREG(0x10)
+#define TJ_DMAWC        TREG(0x14)
+#define TJ_DMARS        TREG(0x18)
+#define TJ_DMARI        TREG(0x1c)
+#define TJ_DMARE        TREG(0x20)
+#define TJ_DMARC        TREG(0x24)
+
+#define TJ_AUXINTPOL    TREG(0x2A)
+
+#define TJ_AUXFUNC      TREG(0x2b)
+#define TJ_SFDELAY      TREG(0x2c)
+#define TJ_SERCTL       TREG(0x2d)
+#define TJ_SFLC         TREG(0x2e)
+#define TJ_FSCDELAY     TREG(0x2f)
+
+#define TJ_REGBASE      TREG(0xc0)
+
+#define PIB(addr)       (TJ_REGBASE + addr * 4)
+
+#define HTXF_READY      (inb(PIB(0)) & 0x10)
+#define HRXF_READY      (inb(PIB(0)) & 0x20)
+
+
+#define VT_PORT_EMPTY	0
+#define VT_PORT_VDAA	1   /* Voice DAA - FXO */
+#define VT_PORT_PROSLIC	2   /* ProSLIC - FXS */
+
+#define VBAT 0xC7
+
+#define HKMODE_FWDACT   1
+#define HKMODE_FWDONACT	2
+#define HKMODE_RINGING	4
+
+#define HOOK_ONHOOK     0
+#define HOOK_OFFHOOK    1
+
+#define	DSP_CODEC_RING		12	/* RING rising edge detected		*/
+#define	DSP_CODEC_HKOFF		22	/* station port off hook                */
+#define	DSP_CODEC_HKON		23	/* station port on hook                 */
+#define	DSP_RING_OFF		24	/* RING falling edge detected		*/
+#define DSP_DROP		25
+
+#define	DSP_CODEC_FLASH		26	/* station port hook flash              */
+
+#define DSP_LOOP_OFFHOOK	38	/* Loop Off hook from OpenPCI           */
+#define DSP_LOOP_ONHOOK		39	/* Loop On hook from OpenPCI            */
+#define DSP_LOOP_POLARITY	40	/* Loop Polarity from OpenPCI           */
+#define DSP_LOOP_NOBATT		41
+
+#define DSP_PROSLIC_SANITY	50	/* Sanity alert from a ProSLIC port 	*/
+#define DSP_PROSLIC_PWR_ALARM	51	/* Power Alarm from a ProSLIC port 	*/
+#define DSP_VDAA_ISO_FRAME_E	52	/* ISO-cap frame sync lost on VDAA port*/
+
+#if VERBOSE_TIMING
+ #define REPORT_WAIT(n,x)						    \
+	 cardinfo(card->cardnum, #n " wait at %d, " #x " = %d", __LINE__, x )
+#else
+ #define REPORT_WAIT(n,x)
+#endif
+
+#define BUSY_WAIT(countvar,cond,delay,iter,failret)			    \
+	countvar=0;							    \
+	while(cond){							    \
+	    udelay(delay);						    \
+	    if(++countvar > iter){					    \
+		cardcrit(wc->boardnum, "busy wait FAILED at %d", __LINE__); \
+		return failret;						    \
+	    }								    \
+	}								    \
+	REPORT_WAIT(busy,i)
+
+#define LOCKED_WAIT(countvar,cond,delay,iter,failret)			    \
+	countvar=0;							    \
+	while(cond){							    \
+	    udelay(delay);						    \
+	    if(++countvar > iter){					    \
+		dbginfo(wc->boardnum,"busy wait failed at %d",__LINE__);    \
+		spin_unlock_irqrestore(&wc->lock, flags);		    \
+		return failret;						    \
+	    }								    \
+	}								    \
+	REPORT_WAIT(locked,i)
+
+#define HTXF_WAIT()                 BUSY_WAIT(i,HTXF_READY,5,500,RET_FAIL)
+#define HRXF_WAIT()                 BUSY_WAIT(i,!HRXF_READY,5,70000,RET_FAIL)
+#define HTXF_WAIT_RET(failret)      BUSY_WAIT(i,HTXF_READY,5,500,failret)
+#define HRXF_WAIT_RET(failret)      BUSY_WAIT(i,!HRXF_READY,5,1000,failret)
+
+#define HTXF_WAIT_LOCKED()	    LOCKED_WAIT(i,HTXF_READY,5,500,RET_FAIL)
+#define HRXF_WAIT_LOCKED()	    LOCKED_WAIT(i,!HRXF_READY,5,1000,RET_FAIL)
+#define HTXF_WAIT_LOCKED_RET(failret) LOCKED_WAIT(i,HTXF_READY,5,500,failret)
+#define HRXF_WAIT_LOCKED_RET(failret) LOCKED_WAIT(i,!HRXF_READY,5,1000,failret)
+
+
+struct openpci {
+	struct pci_dev *dev;
+	char *variety;
+	int boardnum;
+	int portcount;
+	int porttype[MAX_PORTS];
+
+        int firmware;
+        char serial[ID_DATA_MAXSIZE];
+
+	spinlock_t lock;
+
+	//XXX Replace these with proper try_module_get locking in the zaptel driver.
+	//int usecount;	//XXX
+	//int dead;	//XXX
+	union {
+		struct {
+			int offhook;
+		} fxo;
+		struct {
+			int ohttimer;
+			int idletxhookstate;  /* IDLE changing hook state */
+			int lasttxhook;
+		} fxs;
+	} mod[MAX_PORTS];
+
+	unsigned long		ioaddr;
+	dma_addr_t		readdma;
+	dma_addr_t		writedma;
+	volatile unsigned int  *writechunk;  /* Double-word aligned write memory */
+	volatile unsigned int  *readchunk;   /* Double-word aligned read memory */
+
+	struct zt_chan chans[MAX_PORTS];
+	struct zt_span span;
+} *cards[MAX_CARDS];
+
+// You must hold this lock anytime you access or modify the cards[] array.
+DEFINE_MUTEX(cards_mutex);
+
+static unsigned char fxo_port_lookup[8] = { 0x0, 0x8, 0x4, 0xc, 0x10, 0x18, 0x14, 0x1c};
+static unsigned char fxs_port_lookup[8] = { 0x0, 0x1, 0x2, 0x3, 0x10, 0x11, 0x12, 0x13};
+static char wcopenpci[] = "Voicetronix OpenPCI";
+
+static char *country = DEFAULT_COUNTRY;
+static int reversepolarity;  // = 0
+static int debug;            // = 0
+
+module_param(country, charp, 0444);
+module_param(debug, int, 0600);
+module_param(reversepolarity, int, 0600);
+MODULE_PARM_DESC(country, "Set the default country name");
+MODULE_PARM_DESC(debug, "Enable verbose logging");
+
+//#define DEBUG_LOOP_VOLTAGE 1
+#ifdef DEBUG_LOOP_VOLTAGE
+ // This param is a 32 bit bitfield where bit 1 << cardnum * 8 << portnum
+ // will enable voltage monitoring on that port (fxo only presently)
+ static int voltmeter;        // = 0
+ module_param(voltmeter, int, 0600);
+ MODULE_PARM_DESC(voltmeter, "Enable loop voltage metering");
+#endif
+
+
+/* boolean return values */
+#define RET_OK   1
+#define RET_FAIL 0
+
+/* Convenience macros for logging */
+#define info(format,...) printk(KERN_INFO NAME ": " format "\n" , ## __VA_ARGS__)
+#define warn(format,...) printk(KERN_WARNING NAME ": " format "\n" , ## __VA_ARGS__)
+#define crit(format,...) printk(KERN_CRIT NAME ": " format "\n" , ## __VA_ARGS__)
+#define cardinfo(cardnum,format,...) info("[%02d] " format, cardnum , ## __VA_ARGS__)
+#define cardwarn(cardnum,format,...) warn("[%02d] " format, cardnum , ## __VA_ARGS__)
+#define cardcrit(cardnum,format,...) crit("[%02d] " format, cardnum , ## __VA_ARGS__)
+#define dbginfo(cardnum,format,...) if(debug) info("[%02d] " format, cardnum , ## __VA_ARGS__)
+
+
+static inline const char *porttype(struct openpci *wc, int port)
+{ //{{{
+	switch( wc->porttype[port] ) {
+	    case VT_PORT_VDAA:    return "VDAA";
+	    case VT_PORT_PROSLIC: return "ProSLIC";
+	    case VT_PORT_EMPTY:   return "empty port";
+	    default:              return "unknown type";
+	}
+} //}}}
+
+
+static int __read_reg_fxo(struct openpci *wc, int port, unsigned char reg, unsigned char *value)
+{ //{{{
+	unsigned char portadr = fxo_port_lookup[port];
+	int i;
+
+	if (HRXF_READY) *value = inb(PIB(1));
+
+	outb(0x11, PIB(1));    HTXF_WAIT();
+	outb(0x2, PIB(1));     HTXF_WAIT();
+	outb(portadr, PIB(1)); HTXF_WAIT();
+	outb(reg, PIB(1));     HTXF_WAIT();
+	HRXF_WAIT(); *value = inb(PIB(1));
+
+	return RET_OK;
+} //}}}
+
+static int read_reg_fxo(struct openpci *wc, int port, unsigned char reg, unsigned char *value)
+{ //{{{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __read_reg_fxo(wc, port, reg, value) ){
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	cardcrit(wc->boardnum, "FXO port %d, reg %d, read failed!", port, reg);
+	return RET_FAIL;
+} //}}}
+
+static int __read_reg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned char *value)
+{ //{{{
+	unsigned char portadr = fxs_port_lookup[port];
+	int i;
+
+	if (HRXF_READY) *value = inb(PIB(1));
+
+	outb(0x13, PIB(1));    HTXF_WAIT();
+	outb(0x2, PIB(1));     HTXF_WAIT();
+	outb(portadr, PIB(1)); HTXF_WAIT();
+	outb(reg, PIB(1));     HTXF_WAIT();
+	HRXF_WAIT(); *value = inb(PIB(1));
+
+	return RET_OK;
+} //}}}
+
+static int read_reg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned char *value)
+{ //{{{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __read_reg_fxs(wc, port, reg, value) ) {
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	cardcrit(wc->boardnum, "FXS port %d, reg %d, read failed!", port, reg);
+	return RET_FAIL;
+} //}}}
+
+static int __write_reg_fxo(struct openpci *wc, int port, unsigned char reg, unsigned char value)
+{ //{{{
+	unsigned char portadr = fxo_port_lookup[port];
+	int i;
+
+        outb(0x10, PIB(1) );   HTXF_WAIT();
+        outb(0x3, PIB(1));     HTXF_WAIT();
+        outb(portadr, PIB(1)); HTXF_WAIT();
+        outb(reg, PIB(1));     HTXF_WAIT();
+        outb(value, PIB(1));   HTXF_WAIT();
+
+	return RET_OK;
+} //}}}
+
+static int write_reg_fxo(struct openpci *wc, int port, unsigned char reg, unsigned char value)
+{ //{{{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __write_reg_fxo(wc, port, reg, value) ){
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	cardcrit(wc->boardnum, "FXO port %d, reg %d, write(%d) failed!", port, reg, value);
+	return RET_FAIL;
+} //}}}
+
+static int __write_reg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned char value)
+{ //{{{
+	unsigned char portadr = fxs_port_lookup[port];
+	int i;
+
+        outb(0x12, PIB(1) );   HTXF_WAIT();
+        outb(0x3, PIB(1));     HTXF_WAIT();
+        outb(portadr, PIB(1)); HTXF_WAIT();
+        outb(reg, PIB(1));     HTXF_WAIT();
+        outb(value, PIB(1));   HTXF_WAIT();
+
+	return RET_OK;
+} //}}}
+
+static int write_reg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned char value)
+{ //{{{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __write_reg_fxs(wc, port, reg, value) ){
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	cardcrit(wc->boardnum, "FXS port %d, reg %d, write(%d) failed!", port, reg, value);
+	return RET_FAIL;
+} //}}}
+
+static int __wait_indreg_fxs(struct openpci *wc, int port)
+{ //{{{
+	unsigned char value;
+	int count = 100;
+
+	while (--count)
+	{
+		if( __read_reg_fxs(wc, port, I_STATUS, &value) ){
+			if( value == 0 )
+				return RET_OK;
+		} else {
+			cardcrit(wc->boardnum,
+				 "failed to read port %d PS_IND_ADDR_ST, retrying...",
+				 port);
+		}
+		udelay(5);
+	}
+	cardcrit(wc->boardnum, "Failed to wait for indirect reg write to port %d", port);
+	return RET_FAIL;
+} //}}}
+
+static int write_indreg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned short value)
+{ //{{{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __wait_indreg_fxs(wc, port)
+	 && __write_reg_fxs(wc, port, IDA_LO, value & 0xff)
+	 && __write_reg_fxs(wc, port, IDA_HI, (value & 0xff00)>>8)
+	 && __write_reg_fxs(wc, port, IAA, reg)
+	 && __wait_indreg_fxs(wc, port) )
+	{
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	cardcrit(wc->boardnum, "FXS indreg %d write failed on port %d", reg, port);
+	return RET_FAIL;
+} //}}}
+
+static int read_indreg_fxs(struct openpci *wc, int port, unsigned char reg, unsigned short *value)
+{ //{{{
+	unsigned long flags;
+	unsigned char lo, hi;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	if( __wait_indreg_fxs(wc, port)
+	 && __write_reg_fxs(wc, port, IAA, reg)
+	 && __wait_indreg_fxs(wc, port)
+	 && __read_reg_fxs(wc, port, IDA_LO, &lo)
+	 && __read_reg_fxs(wc, port, IDA_HI, &hi) )
+	{
+		*value = lo | hi << 8;
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return RET_OK;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return RET_FAIL;
+} //}}}
+
+static void start_dma(struct openpci *wc)
+{ //{{{
+	outb(0x0f, TJ_CNTL);
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(1);
+	outb(0x01, TJ_CNTL);
+	outb(0x01, TJ_OPER);
+} //}}}
+
+static void restart_dma(struct openpci *wc)
+{ //{{{
+	/* Reset Master and TDM */
+	outb(0x01, TJ_CNTL);
+	outb(0x01, TJ_OPER);
+} //}}}
+
+/* You must hold the card spinlock to call this function */
+static int __ping_arm(struct openpci *wc)
+{ //{{{
+	int i;
+	int pong=0;
+
+	while(pong != 0x02){
+		outb(0x02, PIB(1)); HTXF_WAIT();
+		HRXF_WAIT(); pong = inb(PIB(1));
+		dbginfo(wc->boardnum, "ping_arm returned %x", pong);
+	}
+	while(pong == 0x02){
+		// Poke no-ops into the arm while it is still returning data,
+		// if 500 usec elapses with no further response from it then
+		// the message queue is should be completely cleared.
+		outb(0x00, PIB(1)); HTXF_WAIT();
+		i = 100;
+		while( !HRXF_READY && --i ) udelay(5);
+		if( i == 0 ) break;
+		pong = inb(PIB(1));
+		dbginfo(wc->boardnum, "ping_arm returned %x.", pong);
+	}
+	return RET_OK;
+} //}}}
+
+static void arm_event(struct openpci *wc, char *msg)
+{ //{{{
+	int port = msg[0];
+
+	switch(msg[1]){
+		case DSP_LOOP_OFFHOOK:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_OFFHOOK);
+			dbginfo(wc->boardnum, "Port %d Loop OffHook", port);
+			break;
+
+		case DSP_LOOP_ONHOOK:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_ONHOOK);
+			dbginfo(wc->boardnum, "Port %d Loop OnHook", port);
+			break;
+
+		case DSP_LOOP_POLARITY:
+			zt_qevent_lock(&wc->chans[port], ZT_EVENT_POLARITY);
+			dbginfo(wc->boardnum, "Port %d Loop Polarity", port);
+			break;
+
+		case DSP_CODEC_RING:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_RING);
+			dbginfo(wc->boardnum, "Port %d Ring On", port);
+			break;
+
+		case DSP_RING_OFF:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_OFFHOOK);
+			dbginfo(wc->boardnum, "Port %d Ring Off", port);
+			break;
+
+		case DSP_CODEC_HKOFF:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_OFFHOOK);
+			dbginfo(wc->boardnum, "Port %d Station OffHook", port);
+			if (reversepolarity)
+				wc->mod[port].fxs.idletxhookstate = 5;
+			else
+				wc->mod[port].fxs.idletxhookstate = 1;
+			break;
+
+		case DSP_CODEC_HKON:
+			zt_hooksig(&wc->chans[port], ZT_RXSIG_ONHOOK);
+			dbginfo(wc->boardnum, "Port %d Station OnHook", port);
+			if (reversepolarity)
+				wc->mod[port].fxs.idletxhookstate = 6;
+			else
+				wc->mod[port].fxs.idletxhookstate = 2;
+			break;
+
+		case DSP_CODEC_FLASH:
+			zt_qevent_lock(&wc->chans[port], ZT_EVENT_WINKFLASH);
+			dbginfo(wc->boardnum, "Port %d Station Flash", port);
+			break;
+
+		case DSP_DROP:
+		case DSP_LOOP_NOBATT:
+			break;
+
+			//XXX What to do to recover from these?
+		case DSP_PROSLIC_SANITY:
+			dbginfo(wc->boardnum, "Port %d ProSlic has gone insane!", port);
+			break;
+
+		case DSP_PROSLIC_PWR_ALARM:
+		{
+			char errbuf[32] = " Unknown", *p = errbuf;
+			int i = 49;
+
+			msg[2] >>= 2;
+			for(; i < 55; ++i, msg[2] >>= 1 )
+			    if(msg[2] & 1){ *(++p)='Q'; *(++p)=i; *(++p)=','; }
+			if( p != errbuf ) *p = '\0';
+			cardcrit(wc->boardnum,"%d: ProSlic power ALARM:%s",msg[0],errbuf);
+			//write_reg_fxs(wc, port, 64, wc->mod[port].fxs.lasttxhook );
+			return;
+		}
+
+		case DSP_VDAA_ISO_FRAME_E:
+			dbginfo(wc->boardnum, "Port %d VDAA has lost ISO-Cap frame lock", port);
+			break;
+
+		default:
+			cardwarn(wc->boardnum, "Unknown message from Arm[%d] for port %d",
+						msg[1], port);
+			break;
+	}
+} //}}}
+
+/* You must hold the card spinlock to call this function */
+static inline int __read_arm_byte( struct openpci *wc, unsigned char *msg )
+{ //{{{
+	int i;
+
+	HRXF_WAIT(); *msg = inb(PIB(1));
+	return RET_OK;
+} //}}}
+
+static inline int read_arm_msg( struct openpci *wc, unsigned char *msg )
+{ //{{{
+	unsigned long flags;
+	int i, d, count;
+	int ret = RET_OK;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0x08, PIB(1)); HTXF_WAIT_LOCKED();
+	//XXX Do we need to clear the interrupt flag even if this fails?
+	HRXF_WAIT_LOCKED(); count = inb(PIB(1));
+	if( count == 0 ){
+		ret = RET_FAIL;
+	} else if( count < 3 || count > 4 ){
+		cardcrit(wc->boardnum, "BOGUS arm message size %d, flushing queue", count);
+		// NB: This may take a while (up to 500usec or more) to complete
+		//     and we are in the isr at present when this is called, so
+		//     we may miss an interrupt or two while this is done in the
+		//     bottom half, but we are already in trouble, so...
+		d = debug; debug = 5; __ping_arm( wc ); debug = d;
+		ret = RET_FAIL;
+	} else while( --count ){
+		if( ! __read_arm_byte(wc, msg) ){
+			cardcrit(wc->boardnum,
+				 "Failed to read arm message %d more bytes expected",
+				 count);
+			ret = RET_FAIL;
+			break;
+		}
+		++msg;
+	}
+	outb(0x09, PIB(1)); HTXF_WAIT_LOCKED();
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return ret;
+} //}}}
+
+static void openpci_arm_work( void *cardptr )
+{ //{{{
+	struct openpci *wc = (struct openpci*)cardptr;
+	unsigned char armmsg[4];
+
+	if( read_arm_msg(wc, armmsg) ) arm_event(wc, armmsg);
+} //}}}
+
+
+static inline void openpci_write(struct openpci *wc, unsigned char flags)
+{ //{{{
+	int x,y;
+	volatile unsigned int *writechunk;
+
+	if (flags & 0x01)
+		writechunk = wc->writechunk;
+	else if (flags & 0x02)
+		writechunk = wc->writechunk + ZT_CHUNKSIZE*2;
+	else {
+		cardcrit(wc->boardnum, "bad write interrupt flags %x, at %x",
+					flags, inb(TJ_DMAWC) );
+		return;
+	}
+	/* get data */
+	zt_transmit(&wc->span);
+	for (y=0,x=0;x<ZT_CHUNKSIZE;++x) {
+		/* Send a sample, as a 32-bit word */
+#ifdef __BIG_ENDIAN
+#error No big endian support (yet)
+#else
+		/* transmit second 4 ports */
+		writechunk[y]=0;
+		if (wc->porttype[4])
+			writechunk[y] |= (wc->chans[4].writechunk[x] << 24);
+		else
+			writechunk[y] |= (0x01 << 24);
+		if (wc->porttype[5])
+			writechunk[y] |= (wc->chans[5].writechunk[x] << 16);
+		if (wc->porttype[6])
+			writechunk[y] |= (wc->chans[6].writechunk[x] << 8);
+		if (wc->porttype[7])
+			writechunk[y] |= (wc->chans[7].writechunk[x]);
+		++y;
+
+		/* transmit first 4 ports */
+		writechunk[y]=0x01000000;
+		/* Make sure first port doesnt equal 0x00 */
+		if (wc->porttype[0]){
+			if (wc->chans[0].writechunk[x] == 0)
+				writechunk[y] |= (0x01 << 24);
+			else
+				writechunk[y] |= (wc->chans[0].writechunk[x] << 24);
+		}
+		//else writechunk[y] |= (0x00 << 24);
+		if (wc->porttype[1])
+			writechunk[y] |= (wc->chans[1].writechunk[x] << 16);
+		if (wc->porttype[2])
+			writechunk[y] |= (wc->chans[2].writechunk[x] << 8);
+		if (wc->porttype[3])
+			writechunk[y] |= (wc->chans[3].writechunk[x]);
+		++y;
+#endif
+	}
+} //}}}
+
+static inline void openpci_read(struct openpci *wc, unsigned char flags)
+{ //{{{
+	int x,y;
+	volatile unsigned int *readchunk;
+
+	if (flags & 0x08)
+		readchunk = wc->readchunk + ZT_CHUNKSIZE*2;
+	else if (flags & 0x04)
+		readchunk = wc->readchunk;
+	else {
+		cardcrit(wc->boardnum, "bad read interrupt flags %x, at %x",
+					flags, inb(TJ_DMARC));
+		return;
+	}
+
+	for (y=0,x=0;x<ZT_CHUNKSIZE;++x) {
+#ifdef __BIG_ENDIAN
+#error No big endian support (yet)
+#else
+		/* Receive first 4 ports */
+
+		if (wc->porttype[0])
+			wc->chans[0].readchunk[x] = (readchunk[y] >> 24) & 0xff;
+		if (wc->porttype[1])
+			wc->chans[1].readchunk[x] = (readchunk[y] >> 16) & 0xff;
+		if (wc->porttype[2])
+			wc->chans[2].readchunk[x] = (readchunk[y] >> 8) & 0xff;
+		if (wc->porttype[3])
+			wc->chans[3].readchunk[x] = (readchunk[y]) & 0xff;
+		++y;
+		/* Receive second 4 ports */
+		if (wc->porttype[4])
+			wc->chans[4].readchunk[x] = (readchunk[y] >> 24) & 0xff;
+		if (wc->porttype[5])
+			wc->chans[5].readchunk[x] = (readchunk[y] >> 16) & 0xff;
+		if (wc->porttype[6])
+			wc->chans[6].readchunk[x] = (readchunk[y] >> 8) & 0xff;
+		if (wc->porttype[7])
+			wc->chans[7].readchunk[x] = (readchunk[y]) & 0xff;
+		++y;
+#endif
+	}
+	/* XXX We're wasting 8 taps.  We should get closer :( */
+	for (x = 0; x < MAX_PORTS; x++) {
+		if (wc->porttype[x])
+			zt_ec_chunk(&wc->chans[x], wc->chans[x].readchunk, wc->chans[x].writechunk);
+	}
+	zt_receive(&wc->span);
+} //}}}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t openpci_isr(int irq, void *dev_id, struct pt_regs *regs)
+#else
+static irqreturn_t openpci_isr(int irq, void *dev_id)
+#endif
+{ //{{{
+	struct openpci *wc = dev_id;
+	unsigned long flags;
+	unsigned char status;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	status = inb(TJ_INTSTAT);
+	outb(status, TJ_INTSTAT);
+
+	if (!status) {
+		if(inb(TJ_AUXR) & 0x02) {
+			spin_unlock_irqrestore(&wc->lock, flags);
+			return IRQ_NONE;
+		}
+		spin_unlock_irqrestore(&wc->lock, flags);
+		openpci_arm_work(wc);
+		return IRQ_HANDLED;
+	}
+	if (status & 0x10){
+		/* PCI Master abort */
+		cardcrit(wc->boardnum, "PCI Master Abort.");
+		/* Stop DMA, wait for watchdog */
+		outb(0x00, TJ_OPER);
+		spin_unlock_irqrestore(&wc->lock, flags);
+		return IRQ_HANDLED;
+	}
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	if (status & 0x20){
+		/* PCI Target abort */
+		cardcrit(wc->boardnum, "PCI Target Abort.");
+		return IRQ_HANDLED;
+	}
+	if (status & 0x03){
+		openpci_write(wc, status);
+	}
+	if (status & 0x0c){
+	    #ifdef DEBUG_LOOP_VOLTAGE
+	    //{{{
+		static int counter[MAX_CARDS];
+		int card = wc->boardnum;
+		int port = ++counter[card] & 0x07;
+		int ignore = counter[card] & 0xf0;
+
+		if( ! ignore && (voltmeter & ((1 << (card * 8)) << port)) ) {
+			unsigned char lv;
+			if( wc->porttype[port] == VT_PORT_VDAA && read_reg_fxo(wc, port, 29, &lv) )
+				cardinfo(wc->boardnum, "Port %d loop voltage %d",
+							port, lv < 128 ? lv : lv - 256);
+		}
+	    //}}}
+	    #endif
+		openpci_read(wc, status);
+	}
+
+	return IRQ_HANDLED;
+} //}}}
+
+static int openpci_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data)
+{ //{{{
+	struct wctdm_stats stats;
+	struct wctdm_regs regs;
+	struct wctdm_regop regop;
+	struct wctdm_echo_coefs echoregs;
+	struct openpci *wc = chan->pvt;
+	int port = chan->chanpos - 1;
+	int x;
+
+	switch (cmd) {
+	case ZT_ONHOOKTRANSFER:
+		if (wc->porttype[port] != VT_PORT_PROSLIC)
+			return -EINVAL;
+		if (get_user(x, (int *)data))
+			return -EFAULT;
+		wc->mod[port].fxs.ohttimer = x << 3;
+		if (reversepolarity)
+			wc->mod[port].fxs.idletxhookstate = 0x6;	/* OHT mode when idle */
+		else
+			wc->mod[port].fxs.idletxhookstate = 0x2;
+		switch(wc->mod[port].fxs.lasttxhook) {
+		    case 0x1:
+		    case 0x5:
+			if (reversepolarity)
+				wc->mod[port].fxs.lasttxhook = 0x6;
+			else
+				wc->mod[port].fxs.lasttxhook = 0x2;
+			if( ! write_reg_fxs(wc, port, 64, wc->mod[port].fxs.lasttxhook) )
+				return -EIO;
+		}
+		break;
+	case ZT_SETPOLARITY:
+		if (get_user(x, (int *)data))
+			return -EFAULT;
+		if (wc->porttype[port] != VT_PORT_PROSLIC)
+			return -EINVAL;
+		/* Can't change polarity while ringing or when open */
+		if ((wc->mod[port].fxs.lasttxhook == 0x04) ||
+		    (wc->mod[port].fxs.lasttxhook == 0x00))
+			return -EINVAL;
+
+		if ((x && !reversepolarity) || (!x && reversepolarity))
+			wc->mod[port].fxs.lasttxhook |= 0x04;
+		else
+			wc->mod[port].fxs.lasttxhook &= ~0x04;
+		if( ! write_reg_fxs(wc, port, 64, wc->mod[port].fxs.lasttxhook) )
+			return -EIO;
+		break;
+	case WCTDM_GET_STATS:
+		if (wc->porttype[port] == VT_PORT_PROSLIC) {
+			unsigned char	linevolt;
+			if( read_reg_fxs(wc, port, 80, &linevolt) )
+				stats.tipvolt = linevolt * -376;
+			else
+				return -EIO;
+			if( read_reg_fxs(wc, port, 81, &linevolt) )
+				stats.ringvolt = linevolt * -376;
+			else
+				return -EIO;
+			if( read_reg_fxs(wc, port, 82, &linevolt) )
+				stats.batvolt = linevolt * -376;
+			else
+				return -EIO;
+		} else if (wc->porttype[port] == VT_PORT_VDAA) {
+			unsigned char	linevolt;
+			if( read_reg_fxo(wc, port, 29, &linevolt) )
+				stats.tipvolt = stats.ringvolt = stats.batvolt = linevolt * 1000;
+			else
+				return -EIO;
+		} else
+			return -EINVAL;
+		if (copy_to_user((struct wctdm_stats *)data, &stats, sizeof(stats)))
+			return -EFAULT;
+		break;
+	case WCTDM_GET_REGS:
+		if (wc->porttype[port] == VT_PORT_PROSLIC) {
+			for (x=0;x<NUM_INDIRECT_REGS;x++)
+				if( ! read_indreg_fxs(wc, port, x, &regs.indirect[x]) )
+					return -EIO;
+			for (x=0;x<NUM_REGS;x++)
+				if( ! read_reg_fxs(wc, port, x, &regs.direct[x]) )
+					return -EIO;
+		} else {
+			memset(&regs, 0, sizeof(regs));
+			for (x=0;x<NUM_FXO_REGS;x++){
+				if( ! read_reg_fxo(wc, port, x, &regs.direct[x]) )
+					return -EIO;
+			}
+		}
+		if (copy_to_user((struct wctdm_regs *)data, &regs, sizeof(regs)))
+			return -EFAULT;
+		break;
+	case WCTDM_SET_REG:
+		if (copy_from_user(&regop, (struct wctdm_regop *)data, sizeof(regop)))
+			return -EFAULT;
+		if (regop.indirect) {
+			if (wc->porttype[port] != VT_PORT_PROSLIC)
+				return -EINVAL;
+			printk("Setting indirect %d to 0x%04x on %d\n",
+				regop.reg, regop.val, chan->chanpos);
+			if( ! write_indreg_fxs(wc, port, regop.reg, regop.val) )
+				return -EIO;
+		} else {
+			regop.val &= 0xff;
+			printk("Setting direct %d to %04x on %d\n",
+				regop.reg, regop.val, chan->chanpos);
+			if (wc->porttype[port] == VT_PORT_PROSLIC) {
+				if( ! write_reg_fxs(wc, port, regop.reg, regop.val) )
+					return -EIO;
+			} else {
+				if( ! write_reg_fxo(wc, port, regop.reg, regop.val) )
+					return -EIO;
+			}
+		}
+		break;
+	case WCTDM_SET_ECHOTUNE:
+		cardinfo(wc->boardnum, "Setting echo registers");
+		if (copy_from_user(&echoregs, (struct wctdm_echo_coefs*)data, sizeof(echoregs)))
+			return -EFAULT;
+
+		if (wc->porttype[port] == VT_PORT_VDAA) {
+			/* Set the ACIM and digital echo canceller registers */
+			if( ! write_reg_fxo(wc, port, 30, echoregs.acim)
+			 || ! write_reg_fxo(wc, port, 45, echoregs.coef1)
+			 || ! write_reg_fxo(wc, port, 46, echoregs.coef2)
+			 || ! write_reg_fxo(wc, port, 47, echoregs.coef3)
+			 || ! write_reg_fxo(wc, port, 48, echoregs.coef4)
+			 || ! write_reg_fxo(wc, port, 49, echoregs.coef5)
+			 || ! write_reg_fxo(wc, port, 50, echoregs.coef6)
+			 || ! write_reg_fxo(wc, port, 51, echoregs.coef7)
+			 || ! write_reg_fxo(wc, port, 52, echoregs.coef8) )
+			{
+				cardcrit(wc->boardnum, "Failed to set echo registers");
+				return -EIO;
+			}
+			break;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+} //}}}
+
+static int openpci_open(struct zt_chan *chan)
+{
+	struct openpci *wc = chan->pvt;
+	if( ! wc->porttype[chan->chanpos-1] )
+		return -ENODEV;
+
+	//XXX This is WRONG and can prang in a race.  We must pass THIS_MODULE
+	//    as the owner of the span that holds the pointer to this function,
+	//    then bump the refcount in the zaptel code _BEFORE_ the potentially
+	//    fatal call to an invalid pointer is made.
+	//if( wc->dead ) return -ENODEV;
+	//wc->usecount++;
+	try_module_get(THIS_MODULE);  //XXX
+
+	return 0;
+}
+
+static int openpci_watchdog(struct zt_span *span, int event)
+{
+	info("TDM: Restarting DMA");
+	restart_dma(span->pvt);
+	return 0;
+}
+
+static int openpci_close(struct zt_chan *chan)
+{
+	struct openpci *wc = chan->pvt;
+	int port = chan->chanpos - 1;
+
+	//XXX wc->usecount--;
+	//XXX This is WRONG and can prang in a race.  We must pass THIS_MODULE
+	//    as the owner of the span that holds the pointer to this function,
+	//    then bump the refcount in the zaptel code _BEFORE_ the potentially
+	//    fatal call to an invalid pointer is made.
+	module_put(THIS_MODULE);
+	if (wc->porttype[port] == VT_PORT_PROSLIC) {
+		if (reversepolarity)
+			wc->mod[port].fxs.idletxhookstate = 5;
+		else
+			wc->mod[port].fxs.idletxhookstate = 1;
+	}
+	/* If we're dead, release us now */
+	//XXX if (!wc->usecount && wc->dead) openpci_release(wc);
+
+	return 0;
+}
+
+static int openpci_hooksig(struct zt_chan *chan, zt_txsig_t txsig)
+{ //{{{
+	struct openpci *wc = chan->pvt;
+	int port = chan->chanpos - 1;
+	int new_hk_state;
+
+	dbginfo(wc->boardnum, "Setting %s port %d hook state %s",
+		 wc->porttype[port] == VT_PORT_VDAA ? "FXO" : "FXS",
+		 port,
+		 txsig == 0 ? "ONHOOK" :
+		 txsig == 1 ? "OFFHOOK" :
+		 txsig == 2 ? "START" :
+		 txsig == 3 ? "KEWL" : "UNKNOWN" );
+
+	switch(wc->porttype[port]) {
+	    case VT_PORT_VDAA:
+		switch(txsig) {
+		    case ZT_TXSIG_START:
+		    case ZT_TXSIG_OFFHOOK:
+			if( write_reg_fxo(wc, port, 5, 0x9)
+			 && write_reg_fxo(wc, port, 0x20, 0x0) )
+				wc->mod[port].fxo.offhook = 1;
+			else
+				cardcrit(wc->boardnum, "Failed set fxo off-hook");
+			break;
+
+		    case ZT_TXSIG_ONHOOK:
+			if( write_reg_fxo(wc, port, 5, 0x8)
+			 && write_reg_fxo(wc, port, 0x20, 0x3) )
+				wc->mod[port].fxo.offhook = 0;
+			else
+				cardcrit(wc->boardnum, "Failed set fxo on-hook");
+			break;
+
+		    default:
+			cardcrit(wc->boardnum,
+				 "Can't set FXO port %d tx state to %d",
+				 port, txsig);
+		}
+		break;
+
+	    case VT_PORT_PROSLIC:
+		new_hk_state = wc->mod[port].fxs.lasttxhook;
+		switch(txsig) {
+		    case ZT_TXSIG_ONHOOK:
+			switch(chan->sig) {
+			case ZT_SIG_EM:
+			case ZT_SIG_FXOKS:
+			case ZT_SIG_FXOLS:
+				new_hk_state = wc->mod[port].fxs.idletxhookstate;
+				break;
+			case ZT_SIG_FXOGS:
+				new_hk_state = 3;
+				break;
+			}
+			break;
+
+		    case ZT_TXSIG_OFFHOOK:
+			switch(chan->sig) {
+			case ZT_SIG_EM:
+				new_hk_state = 5;
+				break;
+			default:
+				new_hk_state = wc->mod[port].fxs.idletxhookstate;
+				break;
+			}
+			break;
+
+		    case ZT_TXSIG_START:
+			new_hk_state = 4;
+			break;
+
+		    case ZT_TXSIG_KEWL:
+			new_hk_state = 0;
+			break;
+
+		    default:
+			cardinfo(wc->boardnum,
+				 "Can't set FXS port %d tx state to %d",
+				 port, txsig);
+		}
+		dbginfo(wc->boardnum, "%s port %d hook state old %d, new %d",
+			 wc->porttype[port] == VT_PORT_VDAA ? "FXO" : "FXS",
+			 port, wc->mod[port].fxs.lasttxhook, new_hk_state );
+
+		if (new_hk_state != wc->mod[port].fxs.lasttxhook){
+			if( write_reg_fxs(wc, port, 64, new_hk_state) )
+				wc->mod[port].fxs.lasttxhook = new_hk_state;
+			else
+				cardcrit(wc->boardnum,
+					 "Failed to set port %d fxs hookstate from %d to %d",
+					 port, wc->mod[port].fxs.lasttxhook, new_hk_state);
+		}
+		break;
+
+	    default:
+		cardcrit(wc->boardnum,
+			 "Unknown module type %d in openpci_hooksig",
+			 wc->porttype[port] );
+	}
+	return 0;
+} //}}}
+
+static int span_initialize(struct openpci *wc)
+{ //{{{
+	int x;
+
+	//XXX Set a THIS_MODULE as the owner of the span...
+	/* Zapata stuff */
+	sprintf(wc->span.name, "WCTDM/%d", wc->boardnum);
+	sprintf(wc->span.desc, "%s Board %d", wc->variety, wc->boardnum + 1);
+	for (x = 0; x < MAX_PORTS; x++) {
+		sprintf(wc->chans[x].name, "WCTDM/%d/%d", wc->boardnum, x);
+		wc->chans[x].sigcap = ZT_SIG_FXOKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS
+				    | ZT_SIG_SF | ZT_SIG_EM | ZT_SIG_CLEAR;
+		wc->chans[x].sigcap |= ZT_SIG_FXSKS | ZT_SIG_FXSLS | ZT_SIG_SF | ZT_SIG_CLEAR;
+		wc->chans[x].chanpos = x+1;
+		wc->chans[x].pvt = wc;
+	}
+	wc->span.deflaw = ZT_LAW_MULAW;
+	wc->span.chans = wc->chans;
+	wc->span.channels = MAX_PORTS;
+	wc->span.hooksig = openpci_hooksig;
+	wc->span.open = openpci_open;
+	wc->span.close = openpci_close;
+	wc->span.flags = ZT_FLAG_RBS;
+	wc->span.ioctl = openpci_ioctl;
+	wc->span.watchdog = openpci_watchdog;
+	init_waitqueue_head(&wc->span.maintq);
+
+	wc->span.pvt = wc;
+	if (zt_register(&wc->span, 0)) {
+		cardcrit(wc->boardnum, "Unable to register span with zaptel");
+		return RET_FAIL;
+	}
+	return RET_OK;
+} //}}}
+
+static int get_port_type(struct openpci *wc, int port)
+{ //{{{
+	int i, type;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0x20, PIB(1)); HTXF_WAIT_LOCKED_RET(VT_PORT_EMPTY);
+	outb(port, PIB(1)); HTXF_WAIT_LOCKED_RET(VT_PORT_EMPTY);
+	HRXF_WAIT_LOCKED_RET(VT_PORT_EMPTY); type = inb(PIB(1));
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	return type;
+} //}}}
+
+static int check_ports(struct openpci *wc)
+{ //{{{
+	int i = 0;
+
+	wc->portcount = 0;
+	for(; i < MAX_PORTS; ++i ){
+		wc->porttype[i] = get_port_type(wc, i);
+		dbginfo(wc->boardnum,"%d: %s", i, porttype(wc,i));
+
+		switch( wc->porttype[i] ) {
+		    case VT_PORT_PROSLIC:
+			/* By default, don't send on hook */
+			if (reversepolarity)
+				wc->mod[i].fxs.idletxhookstate = 5;
+			else
+				wc->mod[i].fxs.idletxhookstate = 1;
+
+		    case VT_PORT_VDAA:
+			++wc->portcount;
+		}
+	}
+	// we 'succeed' if any ports were discovered.
+	return wc->portcount ? RET_OK : RET_FAIL;
+} //}}}
+
+static int configure_vdaa_country(struct openpci *wc, int port, char *name)
+{ //{{{
+	unsigned char value;
+	int i;
+
+	for (i=0; i < sizeof(fxo_modes)/sizeof(struct fxo_mode); ++i){
+		if(!strcmp(fxo_modes[i].name, name)){
+			dbginfo(wc->boardnum, "%d: Setting country to %s", port, name);
+			goto part2;
+		}
+	}
+	i = 3;
+	cardinfo(wc->boardnum, "Using default country %s", fxo_modes[i].name);
+
+    part2:
+	value  = (fxo_modes[i].ohs << 6);
+	value |= (fxo_modes[i].rz << 1);
+	value |= (fxo_modes[i].rt << 0);
+	if( ! write_reg_fxo(wc, port, 16, value) ) goto hell;
+
+	/* DC Termination Control - Register 26 */
+	value  = (fxo_modes[i].dcv << 6);
+	value |= (fxo_modes[i].mini << 4);
+	value |= (fxo_modes[i].ilim << 1);
+	if( ! write_reg_fxo(wc, port, 26, value) ) goto hell;
+
+	/* AC Termination Control - Register 30 */
+	value = (fxo_modes[i].acim << 0);
+	if( ! write_reg_fxo(wc, port, 30, value) ) goto hell;
+
+	/* DAA Control 5 - Register 31 */
+	msleep(1);
+	if( ! read_reg_fxo(wc, port, 31, &value) ) goto hell;
+
+	value = (value & 0xf7) | (fxo_modes[i].ohs2 << 3);
+	value = value | 0x02;
+	if( ! write_reg_fxo(wc, port, 31, value) ) goto hell;
+
+	return RET_OK;
+
+    hell:
+	cardcrit(wc->boardnum, "port %d failed configure vdaa country", port);
+	return RET_FAIL;
+} //}}}
+
+// Do not call this from an interrupt context, it may sleep.
+static void configure_vdaa_port(struct openpci *wc, int port)
+{ //{{{
+	/* Set Country - default to Australia */
+	if( configure_vdaa_country(wc, port, country) )
+		++wc->portcount;
+	else {
+		cardcrit(wc->boardnum, "FAILED to configure vdaa port %d.  Disabled.", port);
+		wc->porttype[port] = VT_PORT_EMPTY;
+	}
+} //}}}
+
+static int configure_proslic_country(struct openpci *wc, int port, const char *name)
+{ //{{{
+	int i;
+
+	for(i=0; i < sizeof(ps_country_regs)/sizeof(struct ps_country_reg); ++i) {
+		if(!strcmp(ps_country_regs[i].country, name)){
+			dbginfo(wc->boardnum, "%d: Setting country to %s", port, name);
+			goto part2;
+		}
+	}
+	return -EINVAL;
+
+    part2:
+
+	if( ! write_reg_fxs(wc, port, 10, ps_country_regs[i].value) ){
+		cardcrit(wc->boardnum,"%d: failed to write PS_IMPEDANCE", port);
+		return -EIO;
+	}
+	return 0;
+} //}}}
+
+// Do not call this from an interrupt context, it may sleep.
+static void configure_proslic_port(struct openpci *wc, int port)
+{ //{{{
+	/* Set Country - default to Australia */
+	switch( configure_proslic_country(wc, port, country) ){
+	    case 0:
+		break;
+
+	    case -EINVAL:
+		cardwarn(wc->boardnum,"%d: Country '%s' unknown, using default", port, country);
+		if( configure_proslic_country(wc, port, DEFAULT_COUNTRY) == 0 )
+			goto hell;
+
+	    default:
+		goto hell;
+	}
+
+	++wc->portcount;
+	return;
+
+    hell:
+	cardcrit(wc->boardnum, "FAILED to configure proslic port %d.  Disabled.", port);
+	wc->porttype[port] = VT_PORT_EMPTY;
+} //}}}
+
+// Do not call this from an interrupt context, it may (indirectly) sleep.
+static int configure_ports(struct openpci *wc)
+{ //{{{
+	unsigned long flags;
+	int i;
+
+	wc->portcount = 0;
+	for(i=0; i < MAX_PORTS; ++i){
+		switch (wc->porttype[i]){
+		    case VT_PORT_VDAA:    configure_vdaa_port(wc,i);    break;
+		    case VT_PORT_PROSLIC: configure_proslic_port(wc,i); break;
+		}
+	}
+
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0x2c, PIB(1)); HTXF_WAIT_LOCKED();
+	outb(0xff, PIB(1)); HTXF_WAIT_LOCKED();
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	// otherwise we 'succeed' if any ports were configured successfully.
+	return wc->portcount ? RET_OK : RET_FAIL;
+} //}}}
+
+static int __get_arm_id(struct openpci *wc, int field, char *value)
+{ //{{{
+	int i;
+	int x=0;
+	int count=0;
+
+	outb(0x01, PIB(1));  HTXF_WAIT();
+	outb(field, PIB(1)); HTXF_WAIT();
+	HRXF_WAIT(); count = inb(PIB(1));
+	if (count > ID_DATA_MAXSIZE){
+		cardcrit(wc->boardnum, "Too many bytes of id(%d) data %d/%d",
+					 field, count, ID_DATA_MAXSIZE);
+		return RET_FAIL;
+	}
+	//cardinfo(wc->boardnum, "get_arm_id(%d): byte count %d",field,count);
+	for(; x < count; ++x){
+		HRXF_WAIT(); *value = inb(PIB(1));
+		//cardinfo(wc->boardnum, "get_arm_id(%d): byte %d => 0x%02x",field,x,tmp);
+		++value;
+	}
+	return RET_OK;
+} //}}}
+
+static void enable_interrupts(struct openpci *wc)
+{ //{{{
+	outb(0x3f, TJ_MASK0);
+	outb(0x02, TJ_MASK1);
+} //}}}
+
+static void disable_interrupts(struct openpci *wc)
+{ //{{{
+	outb(0x00, TJ_MASK0);
+	outb(0x00, TJ_MASK1);
+} //}}}
+
+// Do not call this from an interrupt context, it may sleep.
+static int check_arm(struct openpci *wc)
+{ //{{{
+	char model[ID_DATA_MAXSIZE+1] = { 0 };
+	char date[ID_DATA_MAXSIZE+1]  = { 0 };
+	unsigned long flags;
+	int i=0;
+	int tmp=0;
+
+	spin_lock_irqsave(&wc->lock, flags);
+	while ((tmp != 0x88)&&(++i<100)){
+		outb(0x88, PIB(0));
+		msleep(1);
+		tmp = inb(PIB(1));
+	}
+	if (i>=1000) goto limbo;
+	dbginfo(wc->boardnum, "Arm responded on attempt %d",i);
+
+	// Flush out the queue if we sent several pings before a response.
+	if(i>1)	__ping_arm(wc);
+
+	if( ! __get_arm_id(wc, 0, model) )  goto hell;
+	sscanf(model, "OpenPCI8.%02d", &(wc->firmware));
+	cardinfo(wc->boardnum, "  model: %s", model);
+
+	if( ! __get_arm_id(wc, 1, date) )   goto hell;
+	cardinfo(wc->boardnum, "  date: %s", date);
+
+	if( ! __get_arm_id(wc, 2, wc->serial) ) goto hell;
+	cardinfo(wc->boardnum, "  serial: %s", wc->serial);
+
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return RET_OK;
+
+    hell:
+	spin_unlock_irqrestore(&wc->lock, flags);
+        cardwarn(wc->boardnum, "Found ARM processor, dumb firmware.");
+	return RET_OK;
+
+    limbo:
+	spin_unlock_irqrestore(&wc->lock, flags);
+	return RET_FAIL;
+} //}}}
+
+static int arm_monitor(struct openpci *wc, int on)
+{ //{{{
+	int i;
+	outb( on ? 0x06 : 0x07, PIB(1) ); HTXF_WAIT();
+	return RET_OK;
+} //}}}
+
+static int __devinit openpci_probe_board(struct pci_dev *pdev, const struct pci_device_id *ent)
+{ //{{{
+	struct openpci *wc;
+	int boardnum = 0;
+	int failret = -ENOMEM;
+	int tmp = 0;
+	int i;
+	unsigned long flags;
+
+	if( ent->driver_data != (kernel_ulong_t)&wcopenpci )
+	{
+	    info("Probe of non-OpenPCI card, ignoring.");
+	    return -EINVAL;
+	}
+	wc = kzalloc(sizeof(struct openpci), GFP_KERNEL);
+	if (!wc){
+		return -ENOMEM;
+	}
+
+	mutex_lock(&cards_mutex);
+	for (; boardnum < MAX_CARDS && cards[boardnum]; ++boardnum);
+	if (boardnum >= MAX_CARDS){
+		crit("Too many OpenPCI cards(%d), max is %d.", boardnum, MAX_CARDS);
+		mutex_unlock(&cards_mutex);
+		goto hell;
+	}
+	cards[boardnum] = wc;
+	mutex_unlock(&cards_mutex);
+
+	spin_lock_init(&wc->lock);
+	pci_set_drvdata(pdev, wc);
+
+	wc->boardnum = boardnum;
+	wc->dev      = pdev;
+	wc->variety  = wcopenpci;
+
+	cardinfo(boardnum, "Initialising card");
+	if (pci_enable_device(pdev)) {
+		failret = -EIO;
+		goto hell_2;
+	}
+	wc->ioaddr = pci_resource_start(pdev, 0);
+	if( ! request_region(wc->ioaddr, 0xff, NAME) ){
+                cardcrit(boardnum, "Failed to lock IO region, another driver already using it");
+		failret = -EBUSY;
+		goto hell_2;
+	}
+
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0xff, TJ_AUXD);            /* Set up TJ to access the ARM */
+	outb(0x78, TJ_AUXC);            /* Set up for Jtag */
+	outb(0x00, TJ_CNTL);            /* pull ERST low */
+	spin_unlock_irqrestore(&wc->lock, flags);
+	msleep(1);	                /* Wait a bit */
+
+	dbginfo(boardnum,"Starting ARM");
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0x01, TJ_CNTL);            /* pull ERST high again */
+	spin_unlock_irqrestore(&wc->lock, flags);
+	msleep(100);                    /* Give it all a chance to boot */
+
+	if( ! check_arm(wc) ){
+		cardcrit(boardnum, "Couldnt find ARM processor");
+		failret = -EIO;
+		goto hell_3;
+	}
+	if( wc->firmware < 11 ){
+		cardcrit(boardnum,
+			 "Firmware version %d not supported by this driver",
+			 wc->firmware);
+		cardcrit(boardnum, " contact Voicetronix to have it updated");
+		failret = -ENODEV;
+		goto hell_3;
+	}
+	if( ! check_ports(wc) ){
+		cardcrit(boardnum, "Couldnt find ports!");
+		failret = -EIO;
+		goto hell_3;
+	}
+
+	wc->writechunk = pci_alloc_consistent(pdev, VT_PCIDMA_BLOCKSIZE, &wc->writedma);
+	if (!wc->writechunk) {
+		cardcrit(boardnum, "Couldnt get DMA memory.");
+		goto hell_3;
+	}
+	wc->readchunk = wc->writechunk + ZT_MAX_CHUNKSIZE * (MAX_PORTS*2 / sizeof(int));
+	wc->readdma = wc->writedma + ZT_MAX_CHUNKSIZE * (MAX_PORTS*2);
+
+	memset((void*)wc->writechunk,0,VT_PCIDMA_BLOCKSIZE);
+
+	spin_lock_irqsave(&wc->lock, flags);
+	outb(0xc1, TJ_SERCTL);
+	outb(0x0, TJ_FSCDELAY);
+
+	outl(wc->writedma,                    TJ_DMAWS);
+	outl(wc->writedma + VT_PCIDMA_MIDDLE, TJ_DMAWI);
+	outl(wc->writedma + VT_PCIDMA_END,    TJ_DMAWE);
+	outl(wc->readdma,                     TJ_DMARS);
+	outl(wc->readdma + VT_PCIDMA_MIDDLE,  TJ_DMARI);
+	outl(wc->readdma + VT_PCIDMA_END,     TJ_DMARE);
+
+	/* Clear interrupts */
+	outb(0xff, TJ_INTSTAT);
+	spin_unlock_irqrestore(&wc->lock, flags);
+
+	if( ! arm_monitor(wc, 1) ){
+		cardcrit(boardnum, "failed to start arm monitoring");
+		failret = -EIO;
+		goto hell_4;
+	}
+	msleep(1000);
+
+	i = 0;
+	while(tmp != 0x88 && ++i < 1000) {
+		outb(0x88, PIB(0));
+		msleep(250);
+		tmp = inb(PIB(1));
+	}
+	if(i>=1000) {
+		cardcrit(boardnum, "FAILED to initialise board");
+		goto hell_4;
+	}
+
+	if( ! check_ports(wc) ) {
+		cardcrit(boardnum, "FAILED to initialise ports");
+		failret = -EIO;
+		goto hell_4;
+	}
+	if( ! configure_ports(wc) ){
+		cardcrit(boardnum, "Failed to configure ports.");
+		failret = -EIO;
+		goto hell_4;
+	}
+	cardinfo(wc->boardnum, "have %d configured ports", wc->portcount);
+
+	if( ! span_initialize(wc) ) {
+		cardcrit(boardnum, "Failed to register with zaptel driver");
+		failret = -EFAULT;
+		goto hell_4;
+	}
+
+	/* Finalize signalling  */
+	for (i=0; i < MAX_PORTS; ++i) {
+		if (wc->porttype[i] == VT_PORT_VDAA)
+		    wc->chans[i].sigcap = ZT_SIG_FXSKS | ZT_SIG_FXSLS
+					| ZT_SIG_CLEAR | ZT_SIG_SF;
+		else if (wc->porttype[i] == VT_PORT_PROSLIC)
+		    wc->chans[i].sigcap = ZT_SIG_FXOKS | ZT_SIG_FXOLS
+					| ZT_SIG_FXOGS | ZT_SIG_SF
+					| ZT_SIG_CLEAR | ZT_SIG_EM;
+		else if (wc->porttype[i])
+		    cardcrit(wc->boardnum, "Port %d has unknown type (%d)",
+					   i, wc->porttype[i]);
+	}
+
+	/* Enable bus mastering */
+	pci_set_master(pdev);
+
+	if (request_irq(pdev->irq, openpci_isr, ZAP_IRQ_SHARED, NAME, wc)) {
+		cardcrit(boardnum, "Cant get IRQ!");
+		failret = -EIO;
+		goto hell_5;
+	}
+	cardinfo(boardnum, "Got IRQ %d", pdev->irq);
+
+	enable_interrupts(wc);
+	start_dma(wc);
+
+	cardinfo(boardnum,"Initialised card.");
+	return 0;
+
+    hell_5:
+	zt_unregister(&wc->span);
+    hell_4:
+	if (wc->writechunk){
+		pci_free_consistent(pdev, VT_PCIDMA_BLOCKSIZE,
+				    (void*)wc->writechunk, wc->writedma);
+	}
+    hell_3:
+	outb(0x00, TJ_CNTL);
+	release_region(wc->ioaddr, 0xff);
+    hell_2:
+	cards[boardnum] = NULL;
+    hell:
+	kfree(wc);
+	return failret;
+} //}}}
+
+static void __devexit openpci_remove_board(struct pci_dev *pdev)
+{ //{{{
+	struct openpci *wc = pci_get_drvdata(pdev);
+
+	if(!wc) return;
+
+	arm_monitor(wc,0);
+
+	/* Stop DMA */
+	outb(0x00, TJ_OPER);
+	disable_interrupts(wc);
+
+	//XXX Replace this usecount business...
+	//    and do this BEFORE we invalidate everything above...
+	//    check that we wont try to write to it in the meantime.
+	/* Release span, possibly delayed */
+	//XXX if (!wc->usecount) openpci_release(wc); else wc->dead = 1;
+
+	zt_unregister(&wc->span);
+	outb(0x00, TJ_CNTL);
+
+	pci_free_consistent(pdev, VT_PCIDMA_BLOCKSIZE, (void *)wc->writechunk, wc->writedma);
+	free_irq(pdev->irq, wc);
+
+	release_region(wc->ioaddr, 0xff);
+
+	mutex_lock(&cards_mutex);
+	cards[wc->boardnum] = NULL;
+	mutex_unlock(&cards_mutex);
+
+	kfree(wc);
+	cardinfo(wc->boardnum, "Removed OpenPCI card.");
+} //}}}
+
+static struct pci_device_id openpci_pci_tbl[] = {
+	{ 0xe159, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (kernel_ulong_t) &wcopenpci },
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, openpci_pci_tbl);
+
+static struct pci_driver openpci_driver = {
+	name: 	  NAME,
+	probe: 	  openpci_probe_board,
+	remove:	  __devexit_p(openpci_remove_board),
+	suspend:  NULL,
+	resume:	  NULL,
+	id_table: openpci_pci_tbl,
+};
+
+static int __init openpci_init(void)
+{
+	if( zap_pci_module(&openpci_driver) )
+		return -ENODEV;
+
+	info("Module loaded %s", debug ? "with debug enabled" : "");
+	return 0;
+}
+
+static void __exit openpci_cleanup(void)
+{
+	pci_unregister_driver(&openpci_driver);
+	info("Module exit");
+}
+
+module_init(openpci_init);
+module_exit(openpci_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_VERSION(ZAPTEL_VERSION);
+MODULE_LICENSE("GPL");
+
diff -urN zaptel-1.4.11.org/kernel/zaphfc/Kbuild zaptel-1.4.11/kernel/zaphfc/Kbuild
--- zaptel-1.4.11.org/kernel/zaphfc/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/Kbuild	2008-07-16 22:21:51.934385852 +0200
@@ -0,0 +1,9 @@
+obj-m += zaphfc.o
+
+FIRM_DIR	:= ../../firmware
+
+EXTRA_CFLAGS := -I$(src)/.. -Wno-undef
+
+ifeq ($(HOTPLUG_FIRMWARE),yes)
+  EXTRA_CFLAGS+=-DHOTPLUG_FIRMWARE
+endif
diff -urN zaptel-1.4.11.org/kernel/zaphfc/Makefile zaptel-1.4.11/kernel/zaphfc/Makefile
--- zaptel-1.4.11.org/kernel/zaphfc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/Makefile	2008-07-16 22:06:17.254480083 +0200
@@ -0,0 +1,116 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel")
+RTAI = $(shell [ -f /usr/realtime/include/rtai.h ] && echo "-DRTAITIMING -I/usr/realtime/include")
+
+CFLAGS+=-I. $(ZAP) $(RTAI) -O2 -g -Wall -DBUILDING_TONEZONE 
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP) $(RTAI) -Wall
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+OBJS=zaphfc.o
+
+MODULES=zaphfc
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+
+zaphfc.o: zaphfc.c zaphfc.h
+	$(CC) -c zaphfc.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	rm -rf .tmp_versions
+
+test: all
+	modprobe zaptel
+	insmod ./zaphfc.o
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod zaphfc
+	rmmod zaptel
+
+load:	load$(BUILDVER)
+
+loadNT:	load$(BUILDVER)NT
+
+load-debug:	load$(BUILDVER)-debug
+
+loadNT-debug:	load$(BUILDVER)NT-debug
+
+loadlinux24: all
+	modprobe zaptel
+	insmod ./zaphfc.o
+	ztcfg -v
+
+loadlinux24-debug: all
+	modprobe zaptel
+	insmod ./zaphfc.o debug=1
+	ztcfg -v
+
+loadlinux26: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko
+	ztcfg -v
+
+loadlinux26-debug: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko debug=1
+	ztcfg -v
+
+loadlinux24NT: all
+	modprobe zaptel
+	insmod ./zaphfc.o modes=1
+	ztcfg -v
+
+loadlinux24NT-debug: all
+	modprobe zaptel
+	insmod ./zaphfc.o modes=1 debug=1
+	ztcfg -v
+
+loadlinux26NT: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko modes=1
+	ztcfg -v
+
+loadlinux26NT-debug: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko modes=1 debug=1
+	ztcfg -v
+
+unload: 
+	-rmmod zaphfc zaptel
+
+zaphfc.ko: zaphfc.c zaphfc.h
+
+linux26: 
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 zaphfc.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/zaphfc.ko
+
+installlinux24:
+	install -D -m 644 zaphfc.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/zaphfc.o
+
diff -urN zaptel-1.4.11.org/kernel/zaphfc/zapata.conf zaptel-1.4.11/kernel/zaphfc/zapata.conf
--- zaptel-1.4.11.org/kernel/zaphfc/zapata.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/zapata.conf	2008-07-16 22:06:17.254480083 +0200
@@ -0,0 +1,38 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+; p2mp TE mode
+signalling = bri_cpe_ptmp
+
+; p2p TE mode
+;signalling = bri_cpe
+; p2mp NT mode
+;signalling = bri_net_ptmp
+; p2p NT mode
+;signalling = bri_net
+
+pridialplan = dynamic
+prilocaldialplan = local
+nationalprefix = 0
+internationalprefix = 00
+
+echocancel=yes
+echotraining = 100
+echocancelwhenbridged=yes
+
+immediate=yes
+group = 1
+context=demo
+channel => 1-2
diff -urN zaptel-1.4.11.org/kernel/zaphfc/zaphfc.c zaptel-1.4.11/kernel/zaphfc/zaphfc.c
--- zaptel-1.4.11.org/kernel/zaphfc/zaphfc.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/zaphfc.c	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,1155 @@
+/*
+ * zaphfc.c - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * kernel module inspired by HFC PCI ISDN4Linux and Zaptel drivers
+ *
+ * Copyright (C) 2002, 2003, 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#ifdef RTAITIMING
+#include <asm/io.h>
+#include <rtai.h>
+#include <rtai_sched.h>
+#include <rtai_fifos.h>
+#endif
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <zaptel.h>
+#include "zaphfc.h"
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+#if CONFIG_PCI
+
+#define CLKDEL_TE	0x0f	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0x6c	/* CLKDEL in NT mode */
+
+typedef struct {
+        int vendor_id;
+        int device_id;
+        char *vendor_name;
+        char *card_name;
+} PCI_ENTRY;
+
+static const PCI_ENTRY id_list[] =
+{
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_2BD0, "CCD/Billion/Asuscom", "2BD0"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B000, "Billion", "B000"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B006, "Billion", "B006"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B007, "Billion", "B007"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B008, "Billion", "B008"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B009, "Billion", "B009"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00A, "Billion", "B00A"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00B, "Billion", "B00B"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00C, "Billion", "B00C"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B100, "Seyeon", "B100"},
+        {PCI_VENDOR_ID_ABOCOM, PCI_DEVICE_ID_ABOCOM_2BD1, "Abocom/Magitek", "2BD1"},
+        {PCI_VENDOR_ID_ASUSTEK, PCI_DEVICE_ID_ASUSTEK_0675, "Asuscom/Askey", "675"},
+        {PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_T_CONCEPT, "German telekom", "T-Concept"},
+        {PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_A1T, "German telekom", "A1T"},
+        {PCI_VENDOR_ID_ANIGMA, PCI_DEVICE_ID_ANIGMA_MC145575, "Motorola MC145575", "MC145575"},
+        {PCI_VENDOR_ID_ZOLTRIX, PCI_DEVICE_ID_ZOLTRIX_2BD0, "Zoltrix", "2BD0"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_E,"Digi International", "Digi DataFire Micro V IOM2 (Europe)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_E,"Digi International", "Digi DataFire Micro V (Europe)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_A,"Digi International", "Digi DataFire Micro V IOM2 (North America)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_A,"Digi International", "Digi DataFire Micro V (North America)"},
+	{0x182d, 0x3069,"Sitecom","Isdn 128 PCI"},
+        {0, 0, NULL, NULL},
+};
+
+static struct hfc_card *hfc_dev_list = NULL;
+static int hfc_dev_count = 0;
+static int modes = 0; // all TE
+static int debug = 0;
+static struct pci_dev *multi_hfc = NULL;
+static spinlock_t registerlock = SPIN_LOCK_UNLOCKED;
+
+void hfc_shutdownCard(struct hfc_card *hfctmp) {
+    unsigned long flags;
+
+    if (hfctmp == NULL) {
+	return;
+    }
+
+    if (hfctmp->pci_io == NULL) {
+	return;
+    }
+    
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    printk(KERN_INFO "zaphfc: shutting down card at %p.\n",hfctmp->pci_io);
+
+    /* Clear interrupt mask */
+    hfctmp->regs.int_m2 = 0;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+    /* Reset pending interrupts */
+    hfc_inb(hfctmp, hfc_INT_S1);
+
+    /* Wait for interrupts that might still be pending */
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    /* Remove interrupt handler */
+    if (hfctmp->irq) {
+	free_irq(hfctmp->irq, hfctmp);
+    }
+
+    /* Soft-reset the card */
+    hfc_outb(hfctmp, hfc_CIRM, hfc_CIRM_RESET); // softreset on
+
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    hfc_outb(hfctmp,hfc_CIRM,0);	// softreset off
+
+    pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, 0);	// disable memio and bustmaster
+
+    if (hfctmp->fifomem != NULL) {
+        kfree(hfctmp->fifomem);
+    }
+    iounmap((void *) hfctmp->pci_io);
+    hfctmp->pci_io = NULL;
+    if (hfctmp->pcidev != NULL) {
+        pci_disable_device(hfctmp->pcidev);
+    }
+    spin_unlock_irqrestore(&hfctmp->lock,flags);
+    if (hfctmp->ztdev != NULL) {
+	zt_unregister(&hfctmp->ztdev->span);
+	kfree(hfctmp->ztdev);
+	printk(KERN_INFO "unregistered from zaptel.\n");
+    }
+}
+
+void hfc_resetCard(struct hfc_card *hfctmp) {
+    unsigned long flags;
+
+    spin_lock_irqsave(&hfctmp->lock,flags);
+    pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+    hfctmp->regs.int_m2 = 0;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+//    printk(KERN_INFO "zaphfc: resetting card.\n");
+    pci_set_master(hfctmp->pcidev);
+    hfc_outb(hfctmp, hfc_CIRM, hfc_CIRM_RESET);	// softreset on
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    hfc_outb(hfctmp, hfc_CIRM, 0);	// softreset off
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((20 * HZ) / 1000);	// wait 20 ms
+    if (hfc_inb(hfctmp,hfc_STATUS) & hfc_STATUS_PCI_PROC) {
+	printk(KERN_WARNING "zaphfc: hfc busy.\n");
+    }
+
+//    hfctmp->regs.fifo_en = hfc_FIFOEN_D | hfc_FIFOEN_B1 | hfc_FIFOEN_B2;
+//    hfctmp->regs.fifo_en = hfc_FIFOEN_D;	/* only D fifos enabled */
+    hfctmp->regs.fifo_en = 0;	/* no fifos enabled */
+    hfc_outb(hfctmp, hfc_FIFO_EN, hfctmp->regs.fifo_en);
+
+    hfctmp->regs.trm = 2;
+    hfc_outb(hfctmp, hfc_TRM, hfctmp->regs.trm);
+
+    if (hfctmp->regs.nt_mode == 1) {
+	hfc_outb(hfctmp, hfc_CLKDEL, CLKDEL_NT); /* ST-Bit delay for NT-Mode */
+    } else {
+	hfc_outb(hfctmp, hfc_CLKDEL, CLKDEL_TE); /* ST-Bit delay for TE-Mode */
+    }
+    hfctmp->regs.sctrl_e = hfc_SCTRL_E_AUTO_AWAKE;
+    hfc_outb(hfctmp, hfc_SCTRL_E, hfctmp->regs.sctrl_e);	/* S/T Auto awake */
+    hfctmp->regs.bswapped = 0;	/* no exchange */
+
+    hfctmp->regs.ctmt = hfc_CTMT_TRANSB1 | hfc_CTMT_TRANSB2; // all bchans are transparent , no freaking hdlc
+    hfc_outb(hfctmp, hfc_CTMT, hfctmp->regs.ctmt);
+
+    hfctmp->regs.int_m1 = 0;
+    hfc_outb(hfctmp, hfc_INT_M1, hfctmp->regs.int_m1);
+
+#ifdef RTAITIMING
+    hfctmp->regs.int_m2 = 0;
+#else
+    hfctmp->regs.int_m2 = hfc_M2_PROC_TRANS;
+#endif
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+    /* Clear already pending ints */
+    hfc_inb(hfctmp, hfc_INT_S1);
+
+    if (hfctmp->regs.nt_mode == 1) {
+	hfctmp->regs.sctrl = 3 | hfc_SCTRL_NONE_CAP | hfc_SCTRL_MODE_NT;	/* set tx_lo mode, error in datasheet ! */
+    } else {
+	hfctmp->regs.sctrl = 3 | hfc_SCTRL_NONE_CAP | hfc_SCTRL_MODE_TE;	/* set tx_lo mode, error in datasheet ! */
+    }
+
+    hfctmp->regs.mst_mode = hfc_MST_MODE_MASTER;	/* HFC Master Mode */
+    hfc_outb(hfctmp, hfc_MST_MODE, hfctmp->regs.mst_mode);
+
+    hfc_outb(hfctmp, hfc_SCTRL, hfctmp->regs.sctrl);
+    hfctmp->regs.sctrl_r = 3;
+    hfc_outb(hfctmp, hfc_SCTRL_R, hfctmp->regs.sctrl_r);
+
+    hfctmp->regs.connect = 0;
+    hfc_outb(hfctmp, hfc_CONNECT, hfctmp->regs.connect);
+
+    hfc_outb(hfctmp, hfc_CIRM, 0x80 | 0x40);	// bit order
+
+    /* Finally enable IRQ output */
+#ifndef RTAITIMING
+    hfctmp->regs.int_m2 |= hfc_M2_IRQ_ENABLE;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+#endif
+
+    /* clear pending ints */
+    hfc_inb(hfctmp, hfc_INT_S1); 
+    hfc_inb(hfctmp, hfc_INT_S2);
+}
+
+void hfc_registerCard(struct hfc_card *hfccard) {
+    spin_lock(&registerlock);
+    if (hfccard != NULL) {
+	hfccard->cardno = hfc_dev_count++;
+	hfccard->next = hfc_dev_list;
+	hfc_dev_list = hfccard;
+    }
+    spin_unlock(&registerlock);
+}
+
+static void hfc_btrans(struct hfc_card *hfctmp, char whichB) {
+    // we are called with irqs disabled from the irq handler
+    int count, maxlen, total;
+    unsigned char *f1, *f2;
+    unsigned short *z1, *z2, newz1;
+    int freebytes;
+
+    if (whichB == 1) {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B1TX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B1TX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1TX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1TX_Z2 + (*f1 * 4));
+    } else {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B2TX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B2TX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2TX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2TX_Z2 + (*f1 * 4));
+    }
+
+    freebytes = *z2 - *z1;
+    if (freebytes <= 0) {
+	freebytes += hfc_B_FIFO_SIZE;
+    }
+    count = ZT_CHUNKSIZE;
+
+    total = count;
+    if (freebytes < count) {
+	hfctmp->clicks++;
+	/* only spit out this warning once per second to not make things worse! */
+	if (hfctmp->clicks > 100) {
+	    printk(KERN_CRIT "zaphfc: bchan tx fifo full, dropping audio! (z1=%d, z2=%d)\n",*z1,*z2);
+	    hfctmp->clicks = 0;
+	}
+	return;
+    }
+    
+    maxlen = (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL) - *z1;
+    if (maxlen > count) {
+        maxlen = count;
+    }
+    newz1 = *z1 + total;
+    if (newz1 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { newz1 -= hfc_B_FIFO_SIZE; }
+
+	if (whichB == 1) {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_B1TX_ZOFF + *z1),hfctmp->ztdev->chans[0].writechunk, maxlen);
+	} else {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_B2TX_ZOFF + *z1),hfctmp->ztdev->chans[1].writechunk, maxlen);
+	}
+	
+	count -= maxlen;
+	if (count > 0) {
+	// Buffer wrap
+	    if (whichB == 1) {
+	        memcpy((char *)(hfctmp->fifos + hfc_FIFO_B1TX_ZOFF + hfc_B_SUB_VAL),hfctmp->ztdev->chans[0].writechunk+maxlen, count);
+	    } else {
+	        memcpy((char *)(hfctmp->fifos + hfc_FIFO_B2TX_ZOFF + hfc_B_SUB_VAL),hfctmp->ztdev->chans[1].writechunk+maxlen, count);
+	    }
+	}
+
+    *z1 = newz1;	/* send it now */
+
+//    if (count > 0) printk(KERN_CRIT "zaphfc: bchan tx fifo (f1=%d, f2=%d, z1=%d, z2=%d)\n",(*f1) & hfc_FMASK,(*f2) & hfc_FMASK, *z1, *z2);
+    return;    
+}
+
+static void hfc_brec(struct hfc_card *hfctmp, char whichB) {
+    // we are called with irqs disabled from the irq handler
+    int count, maxlen, drop;
+    volatile unsigned char *f1, *f2;
+    volatile unsigned short *z1, *z2, newz2;
+    int bytes = 0;
+
+    if (whichB == 1) {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B1RX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B1RX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z2 + (*f1 * 4));
+    } else {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B2RX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B2RX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z2 + (*f1 * 4));
+    }
+
+    bytes = *z1 - *z2;
+    if (bytes < 0) {
+	bytes += hfc_B_FIFO_SIZE;
+    }
+    count = ZT_CHUNKSIZE;
+    
+    if (bytes < ZT_CHUNKSIZE) {
+#ifndef RTAITIMING
+	printk(KERN_CRIT "zaphfc: bchan rx fifo not enough bytes to receive! (z1=%d, z2=%d, wanted %d got %d), probably a buffer overrun.\n",*z1,*z2,ZT_CHUNKSIZE,bytes);
+#endif
+	return;
+    }
+
+    /* allowing the buffering of hfc_BCHAN_BUFFER bytes of audio data works around irq jitter */
+    if (bytes > hfc_BCHAN_BUFFER + ZT_CHUNKSIZE) {
+	/* if the system is too slow to handle it, we will have to drop it all (except 1 zaptel chunk) */
+	drop = bytes - ZT_CHUNKSIZE;
+	hfctmp->clicks++;
+	/* only spit out this warning once per second to not make things worse! */
+	if (hfctmp->clicks > 100) {
+	    printk(KERN_CRIT "zaphfc: dropped audio (z1=%d, z2=%d, wanted %d got %d, dropped %d).\n",*z1,*z2,count,bytes,drop);
+	    hfctmp->clicks = 0;
+	}
+	/* hm, we are processing the b chan data tooooo slowly... let's drop the lost audio */
+	newz2 = *z2 + drop;
+	if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+	    newz2 -= hfc_B_FIFO_SIZE; 
+	}
+	*z2 = newz2;
+    }
+
+    
+    maxlen = (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL) - *z2;
+    if (maxlen > count) {
+        maxlen = count;
+    }
+    if (whichB == 1) {
+        memcpy(hfctmp->ztdev->chans[0].readchunk,(char *)(hfctmp->fifos + hfc_FIFO_B1RX_ZOFF + *z2), maxlen);
+    } else {
+        memcpy(hfctmp->ztdev->chans[1].readchunk,(char *)(hfctmp->fifos + hfc_FIFO_B2RX_ZOFF + *z2), maxlen);
+    }
+    newz2 = *z2 + count;
+    if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+        newz2 -= hfc_B_FIFO_SIZE; 
+    }
+    *z2 = newz2;
+	
+    count -= maxlen;
+    if (count > 0) {
+    // Buffer wrap
+        if (whichB == 1) {
+	    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z2 + (*f1 * 4));
+    	    memcpy(hfctmp->ztdev->chans[0].readchunk + maxlen,(char *)(hfctmp->fifos + hfc_FIFO_B1RX_ZOFF + hfc_B_SUB_VAL), count);
+	} else {
+	    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z2 + (*f1 * 4));
+	    memcpy(hfctmp->ztdev->chans[1].readchunk + maxlen,(char *)(hfctmp->fifos + hfc_FIFO_B2RX_ZOFF + hfc_B_SUB_VAL), count);
+	}
+	newz2 = *z2 + count;
+	if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+	    newz2 -= hfc_B_FIFO_SIZE; 
+	}
+    }
+
+
+    if (whichB == 1) {
+	zt_ec_chunk(&hfctmp->ztdev->chans[0], hfctmp->ztdev->chans[0].readchunk, hfctmp->ztdev->chans[0].writechunk);
+    } else {
+	zt_ec_chunk(&hfctmp->ztdev->chans[1], hfctmp->ztdev->chans[1].readchunk, hfctmp->ztdev->chans[1].writechunk);
+    }
+    return;    
+}
+
+
+static void hfc_dtrans(struct hfc_card *hfctmp) {
+    // we are called with irqs disabled from the irq handler
+    int x;
+    int count, maxlen, total;
+    unsigned char *f1, *f2, newf1;
+    unsigned short *z1, *z2, newz1;
+    int frames, freebytes;
+
+    if (hfctmp->ztdev->chans[2].bytes2transmit == 0) {
+	return;
+    }
+
+    f1 = (char *)(hfctmp->fifos + hfc_FIFO_DTX_F1);
+    f2 = (char *)(hfctmp->fifos + hfc_FIFO_DTX_F2);
+    z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z1 + (*f1 * 4));
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z2 + (*f1 * 4));
+
+    frames = (*f1 - *f2) & hfc_FMASK;
+    if (frames < 0) {
+	frames += hfc_MAX_DFRAMES + 1;
+    }
+
+    if (frames >= hfc_MAX_DFRAMES) {
+	printk(KERN_CRIT "zaphfc: dchan tx fifo total number of frames exceeded!\n");
+	return;
+    }
+
+    freebytes = *z2 - *z1;
+    if (freebytes <= 0) {
+	freebytes += hfc_D_FIFO_SIZE;
+    }
+    count = hfctmp->ztdev->chans[2].bytes2transmit;
+
+    total = count;
+    if (freebytes < count) {
+	printk(KERN_CRIT "zaphfc: dchan tx fifo not enough free bytes! (z1=%d, z2=%d)\n",*z1,*z2);
+	return;
+    }
+    
+    newz1 = (*z1 + count) & hfc_ZMASK;
+    newf1 = ((*f1 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	// next frame
+    
+    if (count > 0) {
+	if (debug) {
+    	    printk(KERN_CRIT "zaphfc: card %d TX [ ", hfctmp->cardno);
+	    for (x=0; x<count; x++) {
+		printk("%#2x ",hfctmp->dtransbuf[x]);
+	    }
+	    if (hfctmp->ztdev->chans[2].eoftx == 1) {
+		printk("] %d bytes\n", count);
+	    } else {
+		printk("..] %d bytes\n", count);
+	    }
+	}
+	maxlen = hfc_D_FIFO_SIZE - *z1;
+	if (maxlen > count) {
+	    maxlen = count;
+	}
+	memcpy((char *)(hfctmp->fifos + hfc_FIFO_DTX_ZOFF + *z1),hfctmp->ztdev->chans[2].writechunk, maxlen);
+	count -= maxlen;
+	if (count > 0) {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_DTX_ZOFF),(char *)(hfctmp->ztdev->chans[2].writechunk + maxlen), count);
+	}
+    }
+
+    *z1 = newz1;
+
+    if (hfctmp->ztdev->chans[2].eoftx == 1) {
+	*f1 = newf1;
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z1 + (*f1 * 4));
+	*z1 = newz1;
+	hfctmp->ztdev->chans[2].eoftx = 0;
+    }
+//    printk(KERN_CRIT "zaphfc: dchan tx fifo (f1=%d, f2=%d, z1=%d, z2=%d)\n",(*f1) & hfc_FMASK,(*f2) & hfc_FMASK, *z1, *z2);
+    return;    
+}
+
+/* receive a complete hdlc frame, skip broken or short frames */
+static void hfc_drec(struct hfc_card *hfctmp) {
+    int count=0, maxlen=0, framelen=0;
+    unsigned char *f1, *f2, *crcstat;
+    unsigned short *z1, *z2, oldz2, newz2;
+
+    hfctmp->ztdev->chans[2].bytes2receive=0;
+    hfctmp->ztdev->chans[2].eofrx = 0;
+
+    /* put the received data into the zaptel buffer
+       we'll call zt_receive() later when the timer fires. */
+    f1 = (char *)(hfctmp->fifos + hfc_FIFO_DRX_F1);
+    f2 = (char *)(hfctmp->fifos + hfc_FIFO_DRX_F2);
+
+    if (*f1 == *f2) return; /* nothing received, strange eh? */
+
+    z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z1 + (*f2 * 4));
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+    
+    /* calculate length of frame, including 2 bytes CRC and 1 byte STAT */
+    count = *z1 - *z2;
+    
+    if (count < 0) { 
+	count += hfc_D_FIFO_SIZE; /* ring buffer wrapped */
+    }
+    count++;
+    framelen = count;
+
+    crcstat = (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF + *z1);
+
+    if ((framelen < 4) || (*crcstat != 0x0)) {
+	/* the frame is too short for a valid HDLC frame or the CRC is borked */
+	printk(KERN_CRIT "zaphfc: empty HDLC frame or bad CRC received (framelen = %d, stat = %#x, card = %d).\n", framelen, *crcstat, hfctmp->cardno);
+	oldz2 = *z2;
+	*f2 = ((*f2 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	/* NEXT!!! */
+        // recalculate z2, because Z2 is a function of F2 Z2(F2) and we INCed F2!!!
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+	*z2 = (oldz2 + framelen) & hfc_ZMASK;
+	hfctmp->drecinframe = 0;
+	hfctmp->regs.int_drec--;
+	/* skip short or broken frames */
+        hfctmp->ztdev->chans[2].bytes2receive = 0; 
+	return;
+    }
+
+    count -= 1;	/* strip STAT */
+    hfctmp->ztdev->chans[2].eofrx = 1;
+
+    if (count + *z2 <= hfc_D_FIFO_SIZE) {
+	maxlen = count;
+    } else {
+	maxlen = hfc_D_FIFO_SIZE - *z2;
+    }
+
+    /* copy first part */
+    memcpy(hfctmp->drecbuf, (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF + *z2), maxlen);
+    hfctmp->ztdev->chans[2].bytes2receive += maxlen; 
+    
+    count -= maxlen;
+    if (count > 0) {
+	/* ring buffer wrapped, copy rest from start of d fifo */
+	memcpy(hfctmp->drecbuf + maxlen, (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF), count);
+	hfctmp->ztdev->chans[2].bytes2receive += count; 
+    }
+
+    /* frame read */
+    oldz2 = *z2;
+    newz2 = (oldz2 + framelen) & hfc_ZMASK;
+    *f2 = ((*f2 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	/* NEXT!!! */
+    /* recalculate z2, because Z2 is a function of F2 Z2(F2) and we INCed F2!!! */
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+    *z2 = newz2;
+    hfctmp->drecinframe = 0;
+    hfctmp->regs.int_drec--; 
+}
+
+#ifndef RTAITIMING
+ZAP_IRQ_HANDLER(hfc_interrupt) {
+    struct hfc_card *hfctmp = dev_id;
+    unsigned long flags = 0;
+    unsigned char stat;
+#else
+static void hfc_service(struct hfc_card *hfctmp) {
+#endif
+    struct zt_hfc *zthfc;
+    unsigned char s1, s2, l1state;
+    int x;
+
+    if (!hfctmp) {
+#ifndef RTAITIMING
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+#else
+	/* rtai */
+	return;
+#endif
+    }
+
+    if (!hfctmp->pci_io) {
+	    printk(KERN_WARNING "%s: IO-mem disabled, cannot handle interrupt\n",
+		   __FUNCTION__);
+#ifndef RTAITIMING
+#ifdef LINUX26
+	    return IRQ_NONE;
+#else
+	    return;
+#endif		
+#else
+	/* rtai */
+	return;
+#endif
+    }
+    
+    /*	we assume a few things in this irq handler:
+	- the hfc-pci will only generate "timer" irqs (proc/non-proc)
+	- we need to use every 8th IRQ (to generate 1khz timing)
+	OR
+	- if we use rtai for timing the hfc-pci will not generate ANY irq,
+	  instead rtai will call this "fake" irq with a 1khz realtime timer. :)
+	- rtai will directly service the card, not like it used to by triggering
+	  the linux irq
+    */
+
+#ifndef RTAITIMING
+    spin_lock_irqsave(&hfctmp->lock, flags);
+    stat = hfc_inb(hfctmp, hfc_STATUS);
+
+    if ((stat & hfc_STATUS_ANYINT) == 0) {
+        // maybe we are sharing the irq
+	spin_unlock_irqrestore(&hfctmp->lock,flags);
+#ifdef LINUX26
+	return IRQ_NONE;
+#else
+	return;
+#endif		
+    }
+#endif
+
+    s1 = hfc_inb(hfctmp, hfc_INT_S1);
+    s2 = hfc_inb(hfctmp, hfc_INT_S2); 
+    if (s1 != 0) {
+	if (s1 & hfc_INTS_TIMER) {
+	    // timer (bit 7)
+	    // printk(KERN_CRIT "timer %d %d %d.\n", stat, s1, s2);
+	}
+	if (s1 & hfc_INTS_L1STATE) {
+	    // state machine (bit 6)
+	    // printk(KERN_CRIT "zaphfc: layer 1 state machine interrupt\n");
+	    zthfc = hfctmp->ztdev;
+	    l1state = hfc_inb(hfctmp,hfc_STATES)  & hfc_STATES_STATE_MASK;
+	    if (hfctmp->regs.nt_mode == 1) {
+		if (debug) {
+	    	    printk(KERN_CRIT "zaphfc: card %d layer 1 state = G%d\n", hfctmp->cardno, l1state);
+		}
+		switch (l1state) {
+		    case 3:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 ACTIVATED (G%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 ACTIVATED (G%d)", hfctmp->cardno, l1state);
+#endif
+			break;
+		    default:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 DEACTIVATED (G%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 DEACTIVATED (G%d)", hfctmp->cardno, l1state);
+#endif
+		}
+		if (l1state == 2) {
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_ACTIVATE | hfc_STATES_DO_ACTION | hfc_STATES_NT_G2_G3);
+		} else if (l1state == 3) {
+		    // fix to G3 state (see specs)
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_LOAD_STATE | 3);
+		}
+	    } else {
+		if (debug) {
+	    	    printk(KERN_CRIT "zaphfc: card %d layer 1 state = F%d\n", hfctmp->cardno, l1state);
+		}
+		switch (l1state) {
+		    case 7:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 ACTIVATED (F%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 ACTIVATED (F%d)", hfctmp->cardno, l1state);
+#endif
+			break;
+		    default:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 DEACTIVATED (F%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 DEACTIVATED (F%d)", hfctmp->cardno, l1state);
+#endif
+		}
+		if (l1state == 3) {
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_DO_ACTION | hfc_STATES_ACTIVATE);
+		}
+	    }
+	    
+	}
+	if (s1 & hfc_INTS_DREC) {
+	    // D chan RX (bit 5)
+	    hfctmp->regs.int_drec++;
+	    // mr. zapata there is something for you!
+	//    printk(KERN_CRIT "d chan rx\n");		    
+	}
+	if (s1 & hfc_INTS_B2REC) {
+	    // B2 chan RX (bit 4)
+	}
+	if (s1 & hfc_INTS_B1REC) {
+	    // B1 chan RX (bit 3)
+	}
+	if (s1 & hfc_INTS_DTRANS) {
+	    // D chan TX (bit 2)
+//	    printk(KERN_CRIT "zaphfc: dchan frame transmitted.\n");
+	}
+	if (s1 & hfc_INTS_B2TRANS) {
+	    // B2 chan TX (bit 1)
+	}
+	if (s1 & hfc_INTS_B1TRANS) {
+	    // B1 chan TX (bit 0)
+	}
+    }
+#ifdef RTAITIMING
+    /* fake an irq */
+    s2 |= hfc_M2_PROC_TRANS;
+#endif
+    if (s2 != 0) {
+	if (s2 & hfc_M2_PMESEL) {
+	    // kaboom irq (bit 7)
+	    printk(KERN_CRIT "zaphfc: sync lost, pci performance too low. you might have some cpu throtteling enabled.\n");
+	}
+	if (s2 & hfc_M2_GCI_MON_REC) {
+	    // RxR monitor channel (bit 2)
+	}
+	if (s2 & hfc_M2_GCI_I_CHG) {
+	    // GCI I-change  (bit 1)
+	}
+	if (s2 & hfc_M2_PROC_TRANS) {
+	    // processing/non-processing transition  (bit 0)
+	    hfctmp->ticks++;
+#ifndef RTAITIMING
+	    if (hfctmp->ticks > 7) {
+		// welcome to zaptel timing :)
+#endif
+	    	hfctmp->ticks = 0;
+
+		if (hfctmp->ztdev->span.flags & ZT_FLAG_RUNNING) {
+		    // clear dchan buffer
+		    hfctmp->ztdev->chans[2].bytes2transmit = 0;
+		    hfctmp->ztdev->chans[2].maxbytes2transmit = hfc_D_FIFO_SIZE;
+
+		    zt_transmit(&(hfctmp->ztdev->span));
+
+		    hfc_btrans(hfctmp,1);
+		    hfc_btrans(hfctmp,2);
+		    hfc_dtrans(hfctmp);
+		}
+
+		hfc_brec(hfctmp,1);
+		hfc_brec(hfctmp,2);
+		if (hfctmp->regs.int_drec > 0) {
+		    // dchan data to read
+		    hfc_drec(hfctmp);
+		    if (hfctmp->ztdev->chans[2].bytes2receive > 0) {
+			    if (debug) {
+    				printk(KERN_CRIT "zaphfc: card %d RX [ ", hfctmp->cardno);
+				if (hfctmp->ztdev->chans[2].eofrx) {
+				    /* dont output CRC == less user confusion */
+				    for (x=0; x < hfctmp->ztdev->chans[2].bytes2receive - 2; x++) {
+					printk("%#2x ", hfctmp->drecbuf[x]);
+				    }
+				    printk("] %d bytes\n", hfctmp->ztdev->chans[2].bytes2receive - 2);
+				} else {
+				    for (x=0; x < hfctmp->ztdev->chans[2].bytes2receive; x++) {
+					printk("%#2x ", hfctmp->drecbuf[x]);
+				    }
+				    printk("..] %d bytes\n", hfctmp->ztdev->chans[2].bytes2receive);
+				}
+			    }
+		    }
+		} else {
+			// hmm....ok, let zaptel receive nothing
+		    hfctmp->ztdev->chans[2].bytes2receive = 0;
+		}
+		if (hfctmp->ztdev->span.flags & ZT_FLAG_RUNNING) {
+		    zt_receive(&(hfctmp->ztdev->span));
+		}
+		
+#ifndef RTAITIMING
+	    }
+#endif
+	}
+
+    }
+#ifndef RTAITIMING
+    spin_unlock_irqrestore(&hfctmp->lock,flags);
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+#endif
+}
+
+
+static int zthfc_open(struct zt_chan *chan) {
+    struct zt_hfc *zthfc = chan->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+    
+    if (!hfctmp) {
+    return 0;
+    }
+#ifndef LINUX26  
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int zthfc_close(struct zt_chan *chan) {
+    struct zt_hfc *zthfc = chan->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+
+    if (!hfctmp) {
+	return 0;
+    }
+
+#ifndef LINUX26  
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int zthfc_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int zthfc_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int zthfc_startup(struct zt_span *span) {
+    struct zt_hfc *zthfc = span->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+    int alreadyrunning;
+    
+    if (hfctmp == NULL) {
+	printk(KERN_INFO "zaphfc: no card for span at startup!\n");
+    }
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	span->chans[2].flags &= ~ZT_FLAG_HDLC;
+	span->chans[2].flags |= ZT_FLAG_BRIDCHAN;
+	
+	span->flags |= ZT_FLAG_RUNNING;
+
+	hfctmp->ticks = -2;
+	hfctmp->clicks = 0;
+	hfctmp->regs.fifo_en = hfc_FIFOEN_D | hfc_FIFOEN_B1 | hfc_FIFOEN_B2;
+        hfc_outb(hfctmp, hfc_FIFO_EN, hfctmp->regs.fifo_en);
+    } else {
+	return 0;
+    }
+
+    // drivers, start engines!
+    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_DO_ACTION | hfc_STATES_ACTIVATE);
+    return 0;
+}
+
+static int zthfc_shutdown(struct zt_span *span) {
+    return 0;
+}
+
+static int zthfc_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int zthfc_chanconfig(struct zt_chan *chan, int sigtype) {
+//    printk(KERN_CRIT "chan_config sigtype=%d\n", sigtype);
+    return 0;
+}
+
+static int zthfc_spanconfig(struct zt_span *span, struct zt_lineconfig *lc) {
+    span->lineconfig = lc->lineconfig;
+    return 0;
+}
+
+static int zthfc_initialize(struct zt_hfc *zthfc) {
+    struct hfc_card *hfctmp = zthfc->card;
+    int i;
+
+    memset(&zthfc->span, 0x0, sizeof(struct zt_span)); // you never can tell...
+
+    sprintf(zthfc->span.name, "ZTHFC%d", hfc_dev_count + 1);
+    if (hfctmp->regs.nt_mode == 1) {
+#ifdef RTAITIMING
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] [realtime]", hfc_dev_count + 1);
+#else
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT]", hfc_dev_count + 1);
+#endif
+    } else {
+#ifdef RTAITIMING
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] [realtime]", hfc_dev_count + 1);
+#else
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE]", hfc_dev_count + 1);
+#endif
+    }
+
+    zthfc->span.spanconfig = zthfc_spanconfig;
+    zthfc->span.chanconfig = zthfc_chanconfig;
+    zthfc->span.startup = zthfc_startup;
+    zthfc->span.shutdown = zthfc_shutdown;
+    zthfc->span.maint = zthfc_maint;
+    zthfc->span.rbsbits = zthfc_rbsbits;
+    zthfc->span.open = zthfc_open;
+    zthfc->span.close = zthfc_close;
+    zthfc->span.ioctl = zthfc_ioctl;
+
+    zthfc->span.chans = zthfc->chans;
+    zthfc->span.channels = 3;
+    zthfc->span.deflaw = ZT_LAW_ALAW;
+    zthfc->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_CCS; // <--- this is really BS
+    zthfc->span.offset = 0;
+    init_waitqueue_head(&zthfc->span.maintq);
+    zthfc->span.pvt = zthfc;
+
+    for (i = 0; i < zthfc->span.channels; i++) {
+	memset(&(zthfc->chans[i]), 0x0, sizeof(struct zt_chan));
+	sprintf(zthfc->chans[i].name, "ZTHFC%d/%d/%d", hfc_dev_count + 1,0,i + 1);
+	zthfc->chans[i].pvt = zthfc;
+	zthfc->chans[i].sigcap =  ZT_SIG_EM | ZT_SIG_CLEAR | ZT_SIG_FXSLS | ZT_SIG_FXSGS | ZT_SIG_FXSKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS | ZT_SIG_FXOKS | ZT_SIG_CAS | ZT_SIG_SF;
+	zthfc->chans[i].chanpos = i + 1; 
+    }
+
+    if (zt_register(&zthfc->span,0)) {
+	printk(KERN_CRIT "unable to register zaptel device!\n");
+	return -1;
+    }
+//    printk(KERN_CRIT "zaphfc: registered zaptel device!\n");
+    return 0;
+}
+
+#ifdef RTAITIMING
+#define TICK_PERIOD  1000000
+#define TICK_PERIOD2 1000000000
+#define TASK_PRIORITY 1
+#define STACK_SIZE 10000
+
+static RT_TASK rt_task;
+static struct hfc_card *rtai_hfc_list[hfc_MAX_CARDS];
+static unsigned char rtai_hfc_counter = 0;
+
+static void rtai_register_hfc(struct hfc_card *hfctmp) {
+    rtai_hfc_list[rtai_hfc_counter++] = hfctmp;
+}
+
+static void rtai_loop(int t) {
+    int i=0;
+    for (;;) {
+	for (i=0; i < rtai_hfc_counter; i++) {
+	    if (rtai_hfc_list[i] != NULL)
+		hfc_service(rtai_hfc_list[i]);
+	}
+        rt_task_wait_period();
+    }
+}
+#endif
+
+int hfc_findCards(int pcivendor, int pcidevice, char *vendor_name, char *card_name) {
+    struct pci_dev *tmp;
+    struct hfc_card *hfctmp = NULL;
+    struct zt_hfc *zthfc = NULL;
+
+    tmp = pci_get_device(pcivendor, pcidevice, multi_hfc);
+    while (tmp != NULL) {
+	multi_hfc = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_hfc = NULL;
+	    return -1;
+	}
+	pci_set_master(tmp);
+
+	hfctmp = kmalloc(sizeof(struct hfc_card), GFP_KERNEL);
+	if (!hfctmp) {
+	    printk(KERN_WARNING "zaphfc: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	}
+	memset(hfctmp, 0x0, sizeof(struct hfc_card));
+	spin_lock_init(&hfctmp->lock);
+	
+	hfctmp->pcidev = tmp;
+	hfctmp->pcibus = tmp->bus->number;
+	hfctmp->pcidevfn = tmp->devfn; 
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "zaphfc: no irq!\n");
+	} else {
+	    hfctmp->irq = tmp->irq;
+	}
+
+	hfctmp->pci_io = (char *) tmp->resource[1].start;
+	if (!hfctmp->pci_io) {
+	    printk(KERN_WARNING "zaphfc: no iomem!\n");
+	    kfree(hfctmp);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -1;
+	}
+	
+	hfctmp->fifomem = kmalloc(65536, GFP_KERNEL);
+	if (!hfctmp->fifomem) {
+	    printk(KERN_WARNING "zaphfc: unable to kmalloc fifomem!\n");
+	    kfree(hfctmp);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	} else {
+	    memset(hfctmp->fifomem, 0x0, 65536);
+	    hfctmp->fifos = (void *)(((ulong) hfctmp->fifomem) & ~0x7FFF) + 0x8000;
+	    pci_write_config_dword(hfctmp->pcidev, 0x80, (u_int) virt_to_bus(hfctmp->fifos));
+	    hfctmp->pci_io = ioremap((ulong) hfctmp->pci_io, 256);
+	}
+
+#ifdef RTAITIMING
+	/* we need no stinking irq */
+	hfctmp->irq = 0;
+#else
+	if (request_irq(hfctmp->irq, &hfc_interrupt, ZAP_IRQ_SHARED, "zaphfc", hfctmp)) {
+	    printk(KERN_WARNING "zaphfc: unable to register irq\n");
+	    kfree(hfctmp->fifomem);
+	    kfree(hfctmp);
+	    iounmap((void *) hfctmp->pci_io);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -EIO;
+	}
+#endif
+
+#ifdef RTAITIMING
+	rtai_register_hfc(hfctmp);
+#endif
+	printk(KERN_INFO
+		       "zaphfc: %s %s configured at mem %lx fifo %lx(%#x) IRQ %d HZ %d\n",
+			vendor_name, card_name,
+		       (unsigned long) hfctmp->pci_io,
+		       (unsigned long) hfctmp->fifos,
+		       (u_int) virt_to_bus(hfctmp->fifos),
+		       hfctmp->irq, HZ); 
+	pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+	hfctmp->regs.int_m1 = 0;	// no ints
+	hfctmp->regs.int_m2 = 0;	// not at all
+	hfc_outb(hfctmp,hfc_INT_M1,hfctmp->regs.int_m1);
+	hfc_outb(hfctmp,hfc_INT_M2,hfctmp->regs.int_m2);
+
+	if ((modes & (1 << hfc_dev_count)) != 0) {
+	    printk(KERN_INFO "zaphfc: Card %d configured for NT mode\n",hfc_dev_count);
+	    hfctmp->regs.nt_mode = 1;
+	} else {
+	    printk(KERN_INFO "zaphfc: Card %d configured for TE mode\n",hfc_dev_count);
+	    hfctmp->regs.nt_mode = 0;
+	}
+
+	zthfc = kmalloc(sizeof(struct zt_hfc),GFP_KERNEL);
+	if (!zthfc) {
+	    printk(KERN_CRIT "zaphfc: unable to kmalloc!\n");
+	    hfc_shutdownCard(hfctmp);
+	    kfree(hfctmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	}
+	memset(zthfc, 0x0, sizeof(struct zt_hfc));
+
+	zthfc->card = hfctmp;
+	zthfc_initialize(zthfc);
+	hfctmp->ztdev = zthfc;
+
+	memset(hfctmp->drecbuf, 0x0, sizeof(hfctmp->drecbuf));
+	hfctmp->ztdev->chans[2].readchunk = hfctmp->drecbuf;
+
+	memset(hfctmp->dtransbuf, 0x0, sizeof(hfctmp->dtransbuf));
+	hfctmp->ztdev->chans[2].writechunk = hfctmp->dtransbuf;
+
+	memset(hfctmp->brecbuf[0], 0x0, sizeof(hfctmp->brecbuf[0]));
+	hfctmp->ztdev->chans[0].readchunk = hfctmp->brecbuf[0];
+	memset(hfctmp->btransbuf[0], 0x0, sizeof(hfctmp->btransbuf[0]));
+	hfctmp->ztdev->chans[0].writechunk = hfctmp->btransbuf[0];
+
+	memset(hfctmp->brecbuf[1], 0x0, sizeof(hfctmp->brecbuf[1]));
+	hfctmp->ztdev->chans[1].readchunk = hfctmp->brecbuf[1];
+	memset(hfctmp->btransbuf[1], 0x0, sizeof(hfctmp->btransbuf[1]));
+	hfctmp->ztdev->chans[1].writechunk = hfctmp->btransbuf[1];
+
+
+	hfc_registerCard(hfctmp);
+	hfc_resetCard(hfctmp);
+	tmp = pci_get_device(pcivendor, pcidevice, multi_hfc);
+    }
+    return 0;
+}
+
+
+
+int init_module(void) {
+    int i = 0;
+#ifdef RTAITIMING
+    RTIME tick_period;
+    for (i=0; i < hfc_MAX_CARDS; i++) {
+	rtai_hfc_list[i] = NULL;
+    }
+    rt_set_periodic_mode();
+#endif
+    i = 0;
+    while (id_list[i].vendor_id) {
+	multi_hfc = NULL;
+	hfc_findCards(id_list[i].vendor_id, id_list[i].device_id, id_list[i].vendor_name, id_list[i].card_name);
+	i++;
+    }
+#ifdef RTAITIMING
+    for (i=0; i < hfc_MAX_CARDS; i++) {
+        if (rtai_hfc_list[i]) {
+	    printk(KERN_INFO
+		       "zaphfc: configured %d at mem %#x fifo %#x(%#x) for realtime servicing\n",
+			rtai_hfc_list[i]->cardno,
+		       (u_int) rtai_hfc_list[i]->pci_io,
+		       (u_int) rtai_hfc_list[i]->fifos,
+		       (u_int) virt_to_bus(rtai_hfc_list[i]->fifos));
+
+	}
+    }
+    rt_task_init(&rt_task, rtai_loop, 1, STACK_SIZE, TASK_PRIORITY, 0, 0);
+    tick_period = start_rt_timer(nano2count(TICK_PERIOD));
+    rt_task_make_periodic(&rt_task, rt_get_time() + tick_period, tick_period);
+#endif
+    printk(KERN_INFO "zaphfc: %d hfc-pci card(s) in this box.\n", hfc_dev_count);
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct hfc_card *tmpcard;
+#ifdef RTAITIMING
+    stop_rt_timer();
+    rt_task_delete(&rt_task);
+#endif
+    printk(KERN_INFO "zaphfc: stop\n");
+//    spin_lock(&registerlock);
+    while (hfc_dev_list != NULL) {
+	if (hfc_dev_list == NULL) break;
+	hfc_shutdownCard(hfc_dev_list);
+	tmpcard = hfc_dev_list;
+	hfc_dev_list = hfc_dev_list->next;
+	if (tmpcard != NULL) {
+	    kfree(tmpcard);
+	    tmpcard = NULL;
+	    printk(KERN_INFO "zaphfc: freed one card.\n");
+	}
+    }
+//    spin_unlock(&registerlock);
+}
+#endif
+
+
+#ifdef LINUX26
+module_param(modes, int, 0600);
+module_param(debug, int, 0600);
+#else
+MODULE_PARM(modes,"i");
+MODULE_PARM(debug,"i");
+#endif
+
+MODULE_DESCRIPTION("HFC-S PCI A Zaptel Driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urN zaptel-1.4.11.org/kernel/zaphfc/zaphfc.h zaptel-1.4.11/kernel/zaphfc/zaphfc.h
--- zaptel-1.4.11.org/kernel/zaphfc/zaphfc.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/zaphfc.h	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,289 @@
+/*
+ * zaphfc.h - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * kernel module based on HFC PCI ISDN4Linux and Zaptel drivers
+ *
+ * Copyright (C) 2002, 2003, 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+/* HFC register addresses - accessed using memory mapped I/O */
+/* For a list, see datasheet section 3.2.1 at page 21 */
+
+#define hfc_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define hfc_inb(a,b) (readb((a)->pci_io+(b)))
+
+/* GCI/IOM bus monitor registers */
+
+#define hfc_C_I       0x08
+#define hfc_TRxR      0x0C
+#define hfc_MON1_D    0x28
+#define hfc_MON2_D    0x2C
+
+
+/* GCI/IOM bus timeslot registers */
+
+#define hfc_B1_SSL    0x80
+#define hfc_B2_SSL    0x84
+#define hfc_AUX1_SSL  0x88
+#define hfc_AUX2_SSL  0x8C
+#define hfc_B1_RSL    0x90
+#define hfc_B2_RSL    0x94
+#define hfc_AUX1_RSL  0x98
+#define hfc_AUX2_RSL  0x9C
+
+/* GCI/IOM bus data registers */
+
+#define hfc_B1_D      0xA0
+#define hfc_B2_D      0xA4
+#define hfc_AUX1_D    0xA8
+#define hfc_AUX2_D    0xAC
+
+/* GCI/IOM bus configuration registers */
+
+#define hfc_MST_EMOD  0xB4
+#define hfc_MST_MODE	 0xB8
+#define hfc_CONNECT 	 0xBC
+
+
+/* Interrupt and status registers */
+
+#define hfc_FIFO_EN   0x44
+#define hfc_TRM       0x48
+#define hfc_B_MODE    0x4C
+#define hfc_CHIP_ID   0x58
+#define hfc_CIRM  	 0x60
+#define hfc_CTMT	 0x64
+#define hfc_INT_M1  	 0x68
+#define hfc_INT_M2  	 0x6C
+#define hfc_INT_S1  	 0x78
+#define hfc_INT_S2  	 0x7C
+#define hfc_STATUS  	 0x70
+
+/* S/T section registers */
+
+#define hfc_STATES  	 0xC0
+#define hfc_SCTRL  	 0xC4
+#define hfc_SCTRL_E   0xC8
+#define hfc_SCTRL_R   0xCC
+#define hfc_SQ  	 0xD0
+#define hfc_CLKDEL  	 0xDC
+#define hfc_B1_REC    0xF0
+#define hfc_B1_SEND   0xF0
+#define hfc_B2_REC    0xF4
+#define hfc_B2_SEND   0xF4
+#define hfc_D_REC     0xF8
+#define hfc_D_SEND    0xF8
+#define hfc_E_REC     0xFC
+
+/* Bits and values in various HFC PCI registers */
+
+/* bits in status register (READ) */
+#define hfc_STATUS_PCI_PROC   0x02
+#define hfc_STATUS_NBUSY	  0x04 
+#define hfc_STATUS_TIMER_ELAP 0x10
+#define hfc_STATUS_STATINT	  0x20
+#define hfc_STATUS_FRAMEINT	  0x40
+#define hfc_STATUS_ANYINT	  0x80
+
+/* bits in CTMT (Write) */
+#define hfc_CTMT_CLTIMER    0x80
+#define hfc_CTMT_TIM3_125   0x04
+#define hfc_CTMT_TIM25      0x10
+#define hfc_CTMT_TIM50      0x14
+#define hfc_CTMT_TIM400     0x18
+#define hfc_CTMT_TIM800     0x1C
+#define hfc_CTMT_AUTO_TIMER 0x20
+#define hfc_CTMT_TRANSB2    0x02
+#define hfc_CTMT_TRANSB1    0x01
+
+/* bits in CIRM (Write) */
+#define hfc_CIRM_AUX_MSK    0x07
+#define hfc_CIRM_RESET  	  0x08
+#define hfc_CIRM_B1_REV     0x40
+#define hfc_CIRM_B2_REV     0x80
+
+/* bits in INT_M1 and INT_S1 */
+#define hfc_INTS_B1TRANS  0x01
+#define hfc_INTS_B2TRANS  0x02
+#define hfc_INTS_DTRANS   0x04
+#define hfc_INTS_B1REC    0x08
+#define hfc_INTS_B2REC    0x10
+#define hfc_INTS_DREC     0x20
+#define hfc_INTS_L1STATE  0x40
+#define hfc_INTS_TIMER    0x80
+
+/* bits in INT_M2 */
+#define hfc_M2_PROC_TRANS    0x01
+#define hfc_M2_GCI_I_CHG     0x02
+#define hfc_M2_GCI_MON_REC   0x04
+#define hfc_M2_IRQ_ENABLE    0x08
+#define hfc_M2_PMESEL        0x80
+
+/* bits in STATES */
+#define hfc_STATES_STATE_MASK     0x0F
+#define hfc_STATES_LOAD_STATE    0x10
+#define hfc_STATES_ACTIVATE	     0x20
+#define hfc_STATES_DO_ACTION     0x40
+#define hfc_STATES_NT_G2_G3      0x80
+
+/* bits in HFCD_MST_MODE */
+#define hfc_MST_MODE_MASTER	     0x01
+#define hfc_MST_MODE_SLAVE         0x00
+/* remaining bits are for codecs control */
+
+/* bits in HFCD_SCTRL */
+#define hfc_SCTRL_B1_ENA	     0x01
+#define hfc_SCTRL_B2_ENA	     0x02
+#define hfc_SCTRL_MODE_TE        0x00
+#define hfc_SCTRL_MODE_NT        0x04
+#define hfc_SCTRL_LOW_PRIO	     0x08
+#define hfc_SCTRL_SQ_ENA	     0x10
+#define hfc_SCTRL_TEST	     0x20
+#define hfc_SCTRL_NONE_CAP	     0x40
+#define hfc_SCTRL_PWR_DOWN	     0x80
+
+/* bits in SCTRL_E  */
+#define hfc_SCTRL_E_AUTO_AWAKE    0x01
+#define hfc_SCTRL_E_DBIT_1        0x04
+#define hfc_SCTRL_E_IGNORE_COL    0x08
+#define hfc_SCTRL_E_CHG_B1_B2     0x80
+
+/* bits in FIFO_EN register */
+#define hfc_FIFOEN_B1TX   0x01
+#define hfc_FIFOEN_B1RX   0x02
+#define hfc_FIFOEN_B2TX   0x04
+#define hfc_FIFOEN_B2RX   0x08
+#define hfc_FIFOEN_DTX    0x10
+#define hfc_FIFOEN_DRX    0x20
+
+#define hfc_FIFOEN_B1     (hfc_FIFOEN_B1TX|hfc_FIFOEN_B1RX)
+#define hfc_FIFOEN_B2     (hfc_FIFOEN_B2TX|hfc_FIFOEN_B2RX)
+#define hfc_FIFOEN_D      (hfc_FIFOEN_DTX|hfc_FIFOEN_DRX)
+
+/* bits in the CONNECT register */
+#define hfc_CONNECT_B1_shift	0
+#define hfc_CONNECT_B2_shift	3
+
+#define	hfc_CONNECT_HFC_from_ST		0x0
+#define hfc_CONNECT_HFC_from_GCI	0x1
+#define hfc_CONNECT_ST_from_HFC		0x0
+#define hfc_CONNECT_ST_from_GCI		0x2
+#define hfc_CONNECT_GCI_from_HFC	0x0
+#define	hfc_CONNECT_GCI_from_ST		0x4
+
+/* bits in the __SSL and __RSL registers */
+#define	hfc_SRSL_STIO	0x40
+#define hfc_SRSL_ENABLE	0x80
+#define hfc_SRCL_SLOT_MASK	0x1f
+
+/* FIFO memory definitions */
+
+#define hfc_FMASK	0x000f
+#define hfc_ZMASK	0x01ff
+#define hfc_ZMASKB	0x1fff
+
+#define hfc_D_FIFO_SIZE	0x0200
+#define hfc_B_SUB_VAL	0x0200
+#define hfc_B_FIFO_SIZE	0x1E00
+#define hfc_MAX_DFRAMES	0x000f
+
+#define hfc_FIFO_DTX_Z1	0x2080
+#define hfc_FIFO_DTX_Z2 0x2082
+#define hfc_FIFO_DTX_F1	0x20a0
+#define hfc_FIFO_DTX_F2	0x20a1
+#define hfc_FIFO_DTX	0x0000
+#define hfc_FIFO_DTX_ZOFF	0x000
+
+#define hfc_FIFO_DRX_Z1	0x6080
+#define hfc_FIFO_DRX_Z2 0x6082
+#define hfc_FIFO_DRX_F1	0x60a0
+#define hfc_FIFO_DRX_F2	0x60a1
+#define hfc_FIFO_DRX	0x4000
+#define hfc_FIFO_DRX_ZOFF	0x4000
+
+#define hfc_FIFO_B1TX_Z1	0x2000
+#define hfc_FIFO_B1TX_Z2 	0x2002
+#define hfc_FIFO_B1RX_Z1	0x6000
+#define hfc_FIFO_B1RX_Z2 	0x6002
+
+#define hfc_FIFO_B1TX_F1	0x2080
+#define hfc_FIFO_B1TX_F2	0x2081
+#define hfc_FIFO_B1RX_F1	0x6080
+#define hfc_FIFO_B1RX_F2	0x6081
+
+#define hfc_FIFO_B1RX_ZOFF	0x4000
+#define hfc_FIFO_B1TX_ZOFF	0x0000
+
+#define hfc_FIFO_B2TX_Z1	0x2100
+#define hfc_FIFO_B2TX_Z2 	0x2102
+#define hfc_FIFO_B2RX_Z1	0x6100
+#define hfc_FIFO_B2RX_Z2 	0x6102
+
+#define hfc_FIFO_B2TX_F1	0x2180
+#define hfc_FIFO_B2TX_F2	0x2181
+#define hfc_FIFO_B2RX_F1	0x6180
+#define hfc_FIFO_B2RX_F2	0x6181
+
+#define hfc_FIFO_B2RX_ZOFF	0x6000
+#define hfc_FIFO_B2TX_ZOFF	0x2000
+
+#define hfc_BTRANS_THRESHOLD 128
+#define hfc_BTRANS_THRESMASK 0x00
+
+/* Structures */
+
+typedef struct hfc_regs {
+    unsigned char fifo_en;
+    unsigned char ctmt;
+    unsigned char int_m1;
+    unsigned char int_m2;
+    unsigned char sctrl;
+    unsigned char sctrl_e;
+    unsigned char sctrl_r;
+    unsigned char connect;
+    unsigned char trm;
+    unsigned char mst_mode;
+    unsigned char bswapped;
+    unsigned char nt_mode;
+    unsigned char int_drec;
+} hfc_regs;
+
+typedef struct hfc_card {
+    spinlock_t lock;
+    unsigned int irq;
+    unsigned int iomem;
+    int ticks;		
+    int clicks;		
+    unsigned char *pci_io;
+    void *fifomem;		// start of the shared mem
+    volatile void *fifos;	// 32k aligned mem for the fifos
+    struct hfc_regs regs;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    struct zt_hfc *ztdev;
+    int	drecinframe;
+    unsigned char drecbuf[hfc_D_FIFO_SIZE];
+    unsigned char dtransbuf[hfc_D_FIFO_SIZE];
+    unsigned char brecbuf[2][ZT_CHUNKSIZE];
+    unsigned char btransbuf[2][ZT_CHUNKSIZE];
+    unsigned char cardno;
+    struct hfc_card *next;
+} hfc_card;
+
+typedef struct zt_hfc {
+    unsigned int usecount;
+    struct zt_span span;
+    struct zt_chan chans[3];
+    struct hfc_card *card;
+} zt_hfc;
+
+/* tune this */
+#define hfc_BCHAN_BUFFER	8
+#define hfc_MAX_CARDS		8
diff -urN zaptel-1.4.11.org/kernel/zaphfc/zaptel.conf zaptel-1.4.11/kernel/zaphfc/zaptel.conf
--- zaptel-1.4.11.org/kernel/zaphfc/zaptel.conf	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaphfc/zaptel.conf	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,8 @@
+# hfc-s pci a span definition
+# most of the values should be bogus because we are not really zaptel
+loadzone=nl
+defaultzone=nl
+
+span=1,1,3,ccs,ami
+bchan=1-2
+dchan=3
diff -urN zaptel-1.4.11.org/kernel/zaptel-base.c zaptel-1.4.11/kernel/zaptel-base.c
--- zaptel-1.4.11.org/kernel/zaptel-base.c	2008-05-11 03:57:08.000000000 +0200
+++ zaptel-1.4.11/kernel/zaptel-base.c	2008-07-16 22:06:17.194479486 +0200
@@ -136,6 +136,7 @@
 EXPORT_SYMBOL(zt_qevent_lock);
 EXPORT_SYMBOL(zt_hooksig);
 EXPORT_SYMBOL(zt_alarm_notify);
+EXPORT_SYMBOL(zt_alarm_notify_no_master_change);
 EXPORT_SYMBOL(zt_set_dynamic_ioctl);
 EXPORT_SYMBOL(zt_ec_chunk);
 EXPORT_SYMBOL(zt_ec_span);
@@ -609,6 +610,10 @@
 		len += sprintf(page + len, "\tTiming slips: %d\n", spans[span]->timingslips);
 	len += sprintf(page + len, "\n");
 
+	if (spans[span]->proc_read) {
+		len += spans[span]->proc_read(spans[span], page + len);
+	}
+
 
         for (x=1;x<ZT_MAX_CHANNELS;x++) {	
 		if (chans[x]) {
@@ -3191,6 +3196,30 @@
 	}
 }
 
+void zt_alarm_notify_no_master_change(struct zt_span *span)
+{
+	int j;
+	int x;
+
+	span->alarms &= ~ZT_ALARM_LOOPBACK;
+	/* Determine maint status */
+	if (span->maintstat || span->mainttimer)
+		span->alarms |= ZT_ALARM_LOOPBACK;
+	/* DON'T CHANGE THIS AGAIN. THIS WAS DONE FOR A REASON.
+ 	   The expression (a != b) does *NOT* do the same thing
+	   as ((!a) != (!b)) */
+	/* if change in general state */
+	if ((!span->alarms) != (!span->lastalarms)) {
+		if (span->alarms)
+			j = ZT_EVENT_ALARM;
+		else
+			j = ZT_EVENT_NOALARM;
+		span->lastalarms = span->alarms;
+		for (x=0;x < span->channels;x++)
+			zt_qevent_lock(&span->chans[x], j);
+	}
+}
+
 #define VALID_SPAN(j) do { \
 	if ((j >= ZT_MAX_SPANS) || (j < 1)) \
 		return -EINVAL; \
@@ -5744,11 +5773,40 @@
 					*(txb++) = fasthdlc_tx_run_nocheck(&ms->txhdlc);
 				}
 				bytes -= left;
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+			} else if (ms->flags & ZT_FLAG_BRIDCHAN) {
+			    /*
+			     * Let's get this right, we want to transmit complete frames only.
+			     * The card driver will do the dirty HDLC work for us.
+			     * txb (transmit buffer) is supposed to be big enough to store one frame
+			     * we will make this as big as the D fifo (1KB or 2KB)
+			     */
+
+			    /* there are 'left' bytes in the user buffer left to transmit */
+			    left = ms->writen[ms->outwritebuf] - ms->writeidx[ms->outwritebuf] - 2;
+			    if (left > ms->maxbytes2transmit) {
+				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], ms->maxbytes2transmit);
+				ms->writeidx[ms->outwritebuf] += ms->maxbytes2transmit;
+				txb += ms->maxbytes2transmit;
+				ms->bytes2transmit = ms->maxbytes2transmit;
+				ms->eoftx = 0;
+			    } else {
+				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], left);
+				ms->writeidx[ms->outwritebuf] += left + 2;
+				txb += left + 2;
+				ms->bytes2transmit = left;
+				ms->eoftx = 1;
+			    }
+			    bytes = 0;
+#endif
 			} else {
 				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], left);
 				ms->writeidx[ms->outwritebuf]+=left;
 				txb += left;
 				bytes -= left;
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+				ms->bytes2transmit=ZT_CHUNKSIZE;
+#endif
 			}
 			/* Check buffer status */
 			if (ms->writeidx[ms->outwritebuf] >= ms->writen[ms->outwritebuf]) {
@@ -5805,6 +5863,17 @@
 				/* Transmit a flag if this is an HDLC channel */
 				if (ms->flags & ZT_FLAG_HDLC)
 					fasthdlc_tx_frame_nocheck(&ms->txhdlc);
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+				if(ms->flags & ZT_FLAG_BRIDCHAN) { 
+			//	    if (ms->bytes2transmit > 0) {
+					// txb += 2;
+					// ms->bytes2transmit -= 2;
+					bytes=0;
+					ms->eoftx = 1;
+//					printk(KERN_CRIT "zaptel EOF(%d) bytes2transmit %d\n",ms->eoftx,ms->bytes2transmit);
+			//	    }
+				}
+#endif
 #ifdef CONFIG_ZAPATA_NET
 				if (ms->flags & ZT_FLAG_NETDEV)
 					netif_wake_queue(ztchan_to_dev(ms));
@@ -5865,6 +5934,12 @@
 				memset(txb, 0xFF, bytes);
 			}
 			bytes = 0;
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+		} else if(ms->flags & ZT_FLAG_BRIDCHAN) { 
+		    ms->bytes2transmit = 0;
+		    ms->eoftx = 0;
+		    bytes = 0;
+#endif
 		} else {
 			memset(txb, ZT_LIN2X(0, ms), bytes);	/* Lastly we use silence on telephony channels */
 			bytes = 0;
@@ -6683,6 +6758,14 @@
 	int res;
 	int left, x;
 
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)	
+	if (ms->flags & ZT_FLAG_BRIDCHAN) {
+	    bytes = ms->bytes2receive;
+	    if (bytes < 1) return;
+//	    printk(KERN_CRIT "bytes2receive %d\n",ms->bytes2receive);
+	}
+#endif
+
 	while(bytes) {
 #if defined(CONFIG_ZAPATA_NET)  || defined(CONFIG_ZAPATA_PPP)
 		skb = NULL;
@@ -6740,6 +6823,19 @@
 						}
 					}
 				}
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+			} else if (ms->flags & ZT_FLAG_BRIDCHAN) {
+			    memcpy(buf + ms->readidx[ms->inreadbuf], rxb, left);
+			    rxb += left;
+			    ms->readidx[ms->inreadbuf] += left;
+			    bytes -= left;
+			    if (ms->eofrx == 1) {
+				eof=1;
+			    }
+//			    printk(KERN_CRIT "receiving %d bytes\n",ms->bytes2receive);
+			    ms->bytes2receive = 0;
+			    ms->eofrx = 0;
+#endif
 			} else {
 				/* Not HDLC */
 				memcpy(buf + ms->readidx[ms->inreadbuf], rxb, left);
diff -urN zaptel-1.4.11.org/kernel/zaptel-base.c.orig zaptel-1.4.11/kernel/zaptel-base.c.orig
--- zaptel-1.4.11.org/kernel/zaptel-base.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaptel-base.c.orig	2008-07-16 22:06:17.201145996 +0200
@@ -0,0 +1,7801 @@
+/*
+ * Zapata Telephony Interface Driver
+ *
+ * Written by Mark Spencer <markster@digium.com>
+ * Based on previous works, designs, and architectures conceived and
+ * written by Jim Dixon <jim@lambdatel.com>.
+ * 
+ * Special thanks to Steve Underwood <steve@coppice.org>
+ * for substantial contributions to signal processing functions 
+ * in zaptel and the zapata library.
+ *
+ * Yury Bokhoncovich <byg@cf1.ru>
+ * Adaptation for 2.4.20+ kernels (HDLC API was changed)
+ * The work has been performed as a part of our move
+ * from Cisco 3620 to IBM x305 here in F1 Group
+ *
+ * Copyright (C) 2001 Jim Dixon / Zapata Telephony.
+ * Copyright (C) 2001 -2006 Digium, Inc.
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ */
+
+
+#include "zconfig.h"
+#include "../version.h"
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/ctype.h>
+#include <linux/kmod.h>
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif /* CONFIG_DEVFS_FS */
+#ifdef CONFIG_ZAPATA_NET
+#include <linux/netdevice.h>
+#endif /* CONFIG_ZAPATA_NET */
+#include <linux/ppp_defs.h>
+#ifdef CONFIG_ZAPATA_PPP
+#include <linux/netdevice.h>
+#include <linux/if.h>
+#include <linux/if_ppp.h>
+#endif
+#include <asm/atomic.h>
+
+#ifndef CONFIG_OLD_HDLC_API
+#define NEW_HDLC_INTERFACE
+#endif
+
+#define __ECHO_STATE_MUTE			(1 << 8)
+#define ECHO_STATE_IDLE				(0)
+#define ECHO_STATE_PRETRAINING		(1 | (__ECHO_STATE_MUTE))
+#define ECHO_STATE_STARTTRAINING	(2 | (__ECHO_STATE_MUTE))
+#define ECHO_STATE_AWAITINGECHO		(3 | (__ECHO_STATE_MUTE))
+#define ECHO_STATE_TRAINING			(4 | (__ECHO_STATE_MUTE))
+#define ECHO_STATE_ACTIVE			(5)
+
+/* #define BUF_MUNGE */
+
+/* Grab fasthdlc with tables */
+#define FAST_HDLC_NEED_TABLES
+#include "fasthdlc.h"
+
+#include "zaptel.h"
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+/* Get helper arithmetic */
+#include "arith.h"
+#if defined(CONFIG_ZAPTEL_MMX) || defined(ECHO_CAN_FP)
+#include <asm/i387.h>
+#endif
+
+#define hdlc_to_ztchan(h) (((struct zt_hdlc *)(h))->chan)
+#define dev_to_ztchan(h) (((struct zt_hdlc *)(dev_to_hdlc(h)->priv))->chan)
+#ifdef LINUX26
+#define ztchan_to_dev(h) ((h)->hdlcnetdev->netdev)
+#else
+#define ztchan_to_dev(h) (&((h)->hdlcnetdev->netdev.netdev))
+#endif
+
+/* macro-oni for determining a unit (channel) number */
+#define	UNIT(file) MINOR(file->f_dentry->d_inode->i_rdev)
+
+/* names of tx level settings */
+static char *zt_txlevelnames[] = {
+"0 db (CSU)/0-133 feet (DSX-1)",
+"133-266 feet (DSX-1)",
+"266-399 feet (DSX-1)",
+"399-533 feet (DSX-1)",
+"533-655 feet (DSX-1)",
+"-7.5db (CSU)",
+"-15db (CSU)",
+"-22.5db (CSU)"
+} ;
+
+EXPORT_SYMBOL(zt_transcode_fops);
+EXPORT_SYMBOL(zt_init_tone_state);
+EXPORT_SYMBOL(zt_mf_tone);
+EXPORT_SYMBOL(zt_register);
+EXPORT_SYMBOL(zt_unregister);
+EXPORT_SYMBOL(__zt_mulaw);
+EXPORT_SYMBOL(__zt_alaw);
+#ifdef CONFIG_CALC_XLAW
+EXPORT_SYMBOL(__zt_lineartoulaw);
+EXPORT_SYMBOL(__zt_lineartoalaw);
+#else
+EXPORT_SYMBOL(__zt_lin2mu);
+EXPORT_SYMBOL(__zt_lin2a);
+#endif
+EXPORT_SYMBOL(zt_lboname);
+EXPORT_SYMBOL(zt_transmit);
+EXPORT_SYMBOL(zt_receive);
+EXPORT_SYMBOL(zt_rbsbits);
+EXPORT_SYMBOL(zt_qevent_nolock);
+EXPORT_SYMBOL(zt_qevent_lock);
+EXPORT_SYMBOL(zt_hooksig);
+EXPORT_SYMBOL(zt_alarm_notify);
+EXPORT_SYMBOL(zt_set_dynamic_ioctl);
+EXPORT_SYMBOL(zt_ec_chunk);
+EXPORT_SYMBOL(zt_ec_span);
+EXPORT_SYMBOL(zt_hdlc_abort);
+EXPORT_SYMBOL(zt_hdlc_finish);
+EXPORT_SYMBOL(zt_hdlc_getbuf);
+EXPORT_SYMBOL(zt_hdlc_putbuf);
+EXPORT_SYMBOL(zt_alarm_channel);
+EXPORT_SYMBOL(zt_register_chardev);
+EXPORT_SYMBOL(zt_unregister_chardev);
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_entries[ZT_MAX_SPANS]; 
+#endif
+
+/* Here are a couple important little additions for devfs */
+#ifdef CONFIG_DEVFS_FS
+static devfs_handle_t zaptel_devfs_dir;
+static devfs_handle_t channel;
+static devfs_handle_t pseudo;
+static devfs_handle_t ctl;
+static devfs_handle_t timer;
+#endif
+
+/* udev necessary data structures.  Yeah! */
+#ifdef CONFIG_ZAP_UDEV
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+#define CLASS_DEV_CREATE(class, devt, device, name) \
+        class_device_create(class, NULL, devt, device, name)
+#else
+#define CLASS_DEV_CREATE(class, devt, device, name) \
+        class_device_create(class, devt, device, name)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
+static struct class *zap_class = NULL;
+#else
+static struct class_simple *zap_class = NULL;
+#define class_create class_simple_create
+#define class_destroy class_simple_destroy
+#define class_device_create class_simple_device_add
+#define class_device_destroy(a, b) class_simple_device_remove(b)
+#endif
+
+#endif /* CONFIG_ZAP_UDEV */
+
+
+/* There is a table like this in the PPP driver, too */
+
+static int deftaps = 64;
+
+#if !defined(LINUX26)
+static 
+__u16 fcstab[256] =
+{
+	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
+	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
+	0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
+	0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
+	0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
+	0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
+	0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
+	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
+	0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
+	0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
+	0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
+	0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
+	0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
+	0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
+	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
+	0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
+	0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
+	0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
+	0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
+	0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
+	0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
+	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
+	0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
+	0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
+	0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
+	0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
+	0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
+	0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
+	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
+	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
+	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
+	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
+};
+#endif
+
+static int debug;
+
+/* states for transmit signalling */
+typedef enum {ZT_TXSTATE_ONHOOK,ZT_TXSTATE_OFFHOOK,ZT_TXSTATE_START,
+	ZT_TXSTATE_PREWINK,ZT_TXSTATE_WINK,ZT_TXSTATE_PREFLASH,
+	ZT_TXSTATE_FLASH,ZT_TXSTATE_DEBOUNCE,ZT_TXSTATE_AFTERSTART,
+	ZT_TXSTATE_RINGON,ZT_TXSTATE_RINGOFF,ZT_TXSTATE_KEWL,
+	ZT_TXSTATE_AFTERKEWL,ZT_TXSTATE_PULSEBREAK,ZT_TXSTATE_PULSEMAKE,
+	ZT_TXSTATE_PULSEAFTER
+	} ZT_TXSTATE_t;
+
+typedef short sumtype[ZT_MAX_CHUNKSIZE];
+
+static sumtype sums[(ZT_MAX_CONF + 1) * 3];
+
+/* Translate conference aliases into actual conferences 
+   and vice-versa */
+static short confalias[ZT_MAX_CONF + 1];
+static short confrev[ZT_MAX_CONF + 1];
+
+static sumtype *conf_sums_next;
+static sumtype *conf_sums;
+static sumtype *conf_sums_prev;
+
+static struct zt_span *master;
+static struct file_operations zt_fops;
+struct file_operations *zt_transcode_fops = NULL;
+
+static struct
+{
+	int	src;	/* source conf number */
+	int	dst;	/* dst conf number */
+} conf_links[ZT_MAX_CONF + 1];
+
+
+/* There are three sets of conference sum accumulators. One for the current
+sample chunk (conf_sums), one for the next sample chunk (conf_sums_next), and
+one for the previous sample chunk (conf_sums_prev). The following routine 
+(rotate_sums) "rotates" the pointers to these accululator arrays as part
+of the events of sample chink processing as follows:
+
+The following sequence is designed to be looked at from the reference point
+of the receive routine of the master span.
+
+1. All (real span) receive chunks are processed (with putbuf). The last one
+to be processed is the master span. The data received is loaded into the
+accumulators for the next chunk (conf_sums_next), to be in alignment with
+current data after rotate_sums() is called (which immediately follows).
+Keep in mind that putbuf is *also* a transmit routine for the pseudo parts
+of channels that are in the REALANDPSEUDO conference mode. These channels
+are processed from data in the current sample chunk (conf_sums), being
+that this is a "transmit" function (for the pseudo part).
+
+2. rotate_sums() is called.
+
+3. All pseudo channel receive chunks are processed. This data is loaded into
+the current sample chunk accumulators (conf_sums).
+
+4. All conference links are processed (being that all receive data for this
+chunk has already been processed by now).
+
+5. All pseudo channel transmit chunks are processed. This data is loaded from
+the current sample chunk accumulators (conf_sums).
+
+6. All (real span) transmit chunks are processed (with getbuf).  This data is
+loaded from the current sample chunk accumulators (conf_sums). Keep in mind
+that getbuf is *also* a receive routine for the pseudo part of channels that
+are in the REALANDPSEUDO conference mode. These samples are loaded into
+the next sample chunk accumulators (conf_sums_next) to be processed as part
+of the next sample chunk's data (next time around the world).
+
+*/
+
+#define DIGIT_MODE_DTMF 	0
+#define DIGIT_MODE_MFR1		1
+#define DIGIT_MODE_PULSE	2
+#define DIGIT_MODE_MFR2_FWD	3
+#define DIGIT_MODE_MFR2_REV	4
+
+#include "digits.h"
+
+static struct zt_dialparams global_dialparams = {
+	.dtmf_tonelen = DEFAULT_DTMF_LENGTH,
+	.mfv1_tonelen = DEFAULT_MFR1_LENGTH,
+	.mfr2_tonelen = DEFAULT_MFR2_LENGTH,
+};
+
+static int zt_chan_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data, int unit);
+
+#if defined(CONFIG_ZAPTEL_MMX) || defined(ECHO_CAN_FP)
+/* XXX kernel_fpu_begin() is NOT exported properly (in 2.4), so we have to make
+       a local version.  Somebody fix this! XXX */
+
+#ifndef LINUX26
+static inline void __save_init_fpu( struct task_struct *tsk )
+{
+	if ( cpu_has_fxsr ) {
+		asm volatile( "fxsave %0 ; fnclex"
+			      : "=m" (tsk->thread.i387.fxsave) );
+	} else {
+		asm volatile( "fnsave %0 ; fwait"
+			      : "=m" (tsk->thread.i387.fsave) );
+	}
+	tsk->flags &= ~PF_USEDFPU;
+}
+
+static inline void zt_kernel_fpu_begin(void)
+{
+	struct task_struct *tsk = current;
+	if (tsk->flags & PF_USEDFPU) {
+		__save_init_fpu(tsk);
+		return;
+	}
+	clts();
+}
+#else
+#define zt_kernel_fpu_begin kernel_fpu_begin
+#endif /* LINUX26 */
+#endif	
+
+static struct zt_timer {
+	int ms;			/* Countdown */
+	int pos;		/* Position */
+	int ping;		/* Whether we've been ping'd */
+	int tripped;	/* Whether we're tripped */
+	struct zt_timer *next;	/* Linked list */
+	wait_queue_head_t sel;
+} *zaptimers = NULL;
+
+#ifdef DEFINE_SPINLOCK
+static DEFINE_SPINLOCK(zaptimerlock);
+static DEFINE_SPINLOCK(bigzaplock);
+#else
+static spinlock_t zaptimerlock = SPIN_LOCK_UNLOCKED;
+static spinlock_t bigzaplock = SPIN_LOCK_UNLOCKED;
+#endif
+
+struct zt_zone {
+	atomic_t refcount;
+	char name[40];	/* Informational, only */
+	int ringcadence[ZT_MAX_CADENCE];
+	struct zt_tone *tones[ZT_TONE_MAX]; 
+	/* Each of these is a circular list
+	   of zt_tones to generate what we
+	   want.  Use NULL if the tone is
+	   unavailable */
+	struct zt_tone dtmf[16];		/* DTMF tones for this zone, with desired length */
+	struct zt_tone dtmf_continuous[16];	/* DTMF tones for this zone, continuous play */
+	struct zt_tone mfr1[15];		/* MFR1 tones for this zone, with desired length */
+	struct zt_tone mfr2_fwd[15];		/* MFR2 FWD tones for this zone, with desired length */
+	struct zt_tone mfr2_rev[15];		/* MFR2 REV tones for this zone, with desired length */
+	struct zt_tone mfr2_fwd_continuous[16];	/* MFR2 FWD tones for this zone, continuous play */
+	struct zt_tone mfr2_rev_continuous[16];	/* MFR2 REV tones for this zone, continuous play */
+};
+
+static struct zt_span *spans[ZT_MAX_SPANS];
+static struct zt_chan *chans[ZT_MAX_CHANNELS]; 
+
+static int maxspans = 0;
+static int maxchans = 0;
+static int maxconfs = 0;
+static int maxlinks = 0;
+
+static int default_zone = -1;
+
+short __zt_mulaw[256];
+short __zt_alaw[256];
+
+#ifndef CONFIG_CALC_XLAW
+u_char __zt_lin2mu[16384];
+
+u_char __zt_lin2a[16384];
+#endif
+
+static u_char defgain[256];
+
+#ifdef DEFINE_RWLOCK
+static DEFINE_RWLOCK(zone_lock);
+static DEFINE_RWLOCK(chan_lock);
+#else
+static rwlock_t zone_lock = RW_LOCK_UNLOCKED;
+static rwlock_t chan_lock = RW_LOCK_UNLOCKED;
+#endif
+
+static struct zt_zone *tone_zones[ZT_TONE_ZONE_MAX];
+
+#define NUM_SIGS	10	
+
+
+/* Echo cancellation */
+#if defined(ECHO_CAN_HPEC)
+#include "hpec/hpec_zaptel.h"
+#elif defined(ECHO_CAN_STEVE)
+#include "sec.h"
+#elif defined(ECHO_CAN_STEVE2)
+#include "sec-2.h"
+#elif defined(ECHO_CAN_KB1)
+#include "kb1ec.h"
+#elif defined(ECHO_CAN_MG2)
+#include "mg2ec.h"
+#elif defined(ECHO_CAN_JP1)
+#include "jpah.h"
+#endif
+
+static inline void rotate_sums(void)
+{
+	/* Rotate where we sum and so forth */
+	static int pos = 0;
+	conf_sums_prev = sums + (ZT_MAX_CONF + 1) * pos;
+	conf_sums = sums + (ZT_MAX_CONF + 1) * ((pos + 1) % 3);
+	conf_sums_next = sums + (ZT_MAX_CONF + 1) * ((pos + 2) % 3);
+	pos = (pos + 1) % 3;
+	memset(conf_sums_next, 0, maxconfs * sizeof(sumtype));
+}
+
+  /* return quiescent (idle) signalling states, for the various signalling types */
+static int zt_q_sig(struct zt_chan *chan)
+{
+int	x;
+
+static unsigned int in_sig[NUM_SIGS][2] = {
+	{ ZT_SIG_NONE, 0},
+	{ ZT_SIG_EM, 0 | (ZT_ABIT << 8)},
+	{ ZT_SIG_FXSLS,ZT_BBIT | (ZT_BBIT << 8)},
+	{ ZT_SIG_FXSGS,ZT_ABIT | ZT_BBIT | ((ZT_ABIT | ZT_BBIT) << 8)},
+	{ ZT_SIG_FXSKS,ZT_BBIT | ZT_BBIT | ((ZT_ABIT | ZT_BBIT) << 8)},
+	{ ZT_SIG_FXOLS,0 | (ZT_ABIT << 8)},
+	{ ZT_SIG_FXOGS,ZT_BBIT | ((ZT_ABIT | ZT_BBIT) << 8)},
+	{ ZT_SIG_FXOKS,0 | (ZT_ABIT << 8)},
+	{ ZT_SIG_SF, 0},
+	{ ZT_SIG_EM_E1, ZT_DBIT | ((ZT_ABIT | ZT_DBIT) << 8) },
+	} ;
+
+	/* must have span to begin with */
+	if (!chan->span) return(-1);
+	  /* if RBS does not apply, return error */
+	if (!(chan->span->flags & ZT_FLAG_RBS) || 
+		!chan->span->rbsbits) return(-1);
+	if (chan->sig == ZT_SIG_CAS)
+		return chan->idlebits;
+	for (x=0;x<NUM_SIGS;x++) {
+		if (in_sig[x][0] == chan->sig) return(in_sig[x][1]);
+	}	return(-1); /* not found -- error */
+}
+
+#ifdef CONFIG_PROC_FS
+static char *sigstr(int sig)
+{
+	switch (sig) {
+		case ZT_SIG_FXSLS:
+			return "FXSLS";
+		case ZT_SIG_FXSKS:
+			return "FXSKS";
+		case ZT_SIG_FXSGS:
+			return "FXSGS";
+		case ZT_SIG_FXOLS:
+			return "FXOLS";
+		case ZT_SIG_FXOKS:
+			return "FXOKS";
+		case ZT_SIG_FXOGS:
+			return "FXOGS";
+		case ZT_SIG_EM:
+			return "E&M";
+		case ZT_SIG_EM_E1:
+			return "E&M-E1";
+		case ZT_SIG_CLEAR:
+			return "Clear";
+		case ZT_SIG_HDLCRAW:
+			return "HDLCRAW";
+		case ZT_SIG_HDLCFCS:
+			return "HDLCFCS";
+		case ZT_SIG_HDLCNET:
+			return "HDLCNET";
+		case ZT_SIG_HARDHDLC:
+			return "Hardware-assisted HDLC";
+		case ZT_SIG_MTP2:
+			return "MTP2";
+		case ZT_SIG_SLAVE:
+			return "Slave";
+		case ZT_SIG_CAS:
+			return "CAS";
+		case ZT_SIG_DACS:
+			return "DACS";
+		case ZT_SIG_DACS_RBS:
+			return "DACS+RBS";
+		case ZT_SIG_SF:
+			return "SF (ToneOnly)";
+		case ZT_SIG_NONE:
+		default:
+			return "Unconfigured";
+	}
+
+}
+
+static inline int fill_alarm_string(char *buf, int count, int alarms)
+{
+	int	len = 0;
+
+	if (alarms > 0) {
+		if (alarms & ZT_ALARM_BLUE)
+			len += snprintf(buf + len, count - len, "BLUE ");
+		if (alarms & ZT_ALARM_YELLOW)
+			len += snprintf(buf + len, count - len, "YELLOW ");
+		if (alarms & ZT_ALARM_RED)
+			len += snprintf(buf + len, count - len, "RED ");
+		if (alarms & ZT_ALARM_LOOPBACK)
+			len += snprintf(buf + len, count - len, "LOOP ");
+		if (alarms & ZT_ALARM_RECOVER)
+			len += snprintf(buf + len, count - len, "RECOVERING ");
+		if (alarms & ZT_ALARM_NOTOPEN)
+			len += snprintf(buf + len, count - len, "NOTOPEN ");
+	}
+	if(len > 0) {
+		len--;
+		buf[len] = '\0';	/* strip last space */
+	}
+	return len;
+}
+
+static int zaptel_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int x, len = 0;
+	long span;
+
+	/* In Linux 2.6, this MUST NOT EXECEED 1024 bytes in one read! */
+
+	span = (long)data;
+
+	if (!span)
+		return 0;
+
+	if (spans[span]->name) 
+		len += sprintf(page + len, "Span %ld: %s ", span, spans[span]->name);
+	if (spans[span]->desc)
+		len += sprintf(page + len, "\"%s\"", spans[span]->desc);
+	else
+		len += sprintf(page + len, "\"\"");
+
+	if(spans[span] == master)
+		len += sprintf(page + len, " (MASTER)");
+
+	if (spans[span]->lineconfig) {
+		/* framing first */
+		if (spans[span]->lineconfig & ZT_CONFIG_B8ZS)
+			len += sprintf(page + len, " B8ZS/");
+		else if (spans[span]->lineconfig & ZT_CONFIG_AMI)
+			len += sprintf(page + len, " AMI/");
+		else if (spans[span]->lineconfig & ZT_CONFIG_HDB3)
+			len += sprintf(page + len, " HDB3/");
+		/* then coding */
+		if (spans[span]->lineconfig & ZT_CONFIG_ESF)
+			len += sprintf(page + len, "ESF");
+		else if (spans[span]->lineconfig & ZT_CONFIG_D4)
+			len += sprintf(page + len, "D4");
+		else if (spans[span]->lineconfig & ZT_CONFIG_CCS)
+			len += sprintf(page + len, "CCS");
+		/* E1's can enable CRC checking */
+		if (spans[span]->lineconfig & ZT_CONFIG_CRC4)
+			len += sprintf(page + len, "/CRC4");
+	}
+
+	len += sprintf(page + len, " ");
+
+	/* list alarms */
+	len += fill_alarm_string(page + len, count - len, spans[span]->alarms);
+	if (spans[span]->syncsrc && (spans[span]->syncsrc == spans[span]->spanno))
+		len += sprintf(page + len, "ClockSource ");
+	len += sprintf(page + len, "\n");
+	if (spans[span]->bpvcount)
+		len += sprintf(page + len, "\tBPV count: %d\n", spans[span]->bpvcount);
+	if (spans[span]->crc4count)
+		len += sprintf(page + len, "\tCRC4 error count: %d\n", spans[span]->crc4count);
+	if (spans[span]->ebitcount)
+		len += sprintf(page + len, "\tE-bit error count: %d\n", spans[span]->ebitcount);
+	if (spans[span]->fascount)
+		len += sprintf(page + len, "\tFAS error count: %d\n", spans[span]->fascount);
+	if (spans[span]->irqmisses)
+		len += sprintf(page + len, "\tIRQ misses: %d\n", spans[span]->irqmisses);
+	if (spans[span]->timingslips)
+		len += sprintf(page + len, "\tTiming slips: %d\n", spans[span]->timingslips);
+	len += sprintf(page + len, "\n");
+
+
+        for (x=1;x<ZT_MAX_CHANNELS;x++) {	
+		if (chans[x]) {
+			if (chans[x]->span && (chans[x]->span->spanno == span)) {
+				if (chans[x]->name)
+					len += sprintf(page + len, "\t%4d %s ", x, chans[x]->name);
+				if (chans[x]->sig) {
+					if (chans[x]->sig == ZT_SIG_SLAVE)
+						len += sprintf(page + len, "%s ", sigstr(chans[x]->master->sig));
+					else {
+						len += sprintf(page + len, "%s ", sigstr(chans[x]->sig));
+						if (chans[x]->nextslave && chans[x]->master->channo == x)
+							len += sprintf(page + len, "Master ");
+					}
+				}
+				if ((chans[x]->flags & ZT_FLAG_OPEN)) {
+					len += sprintf(page + len, "(In use) ");
+				}
+#ifdef	OPTIMIZE_CHANMUTE
+				if ((chans[x]->chanmute)) {
+					len += sprintf(page + len, "(no pcm) ");
+				}
+#endif
+				len += fill_alarm_string(page + len, count - len, chans[x]->chan_alarms);
+				len += sprintf(page + len, "\n");
+			}
+			if (len <= off) { /* If everything printed so far is before beginning of request */
+				off -= len;
+				len = 0;
+			}
+			if (len > off+count) /* stop if we've already generated enough */
+				break;
+		}
+	}
+	if (len <= off) { /* If everything printed so far is before beginning of request */
+		off -= len;
+		len = 0;
+	}
+	*start = page + off;
+	len -= off;     /* un-count any remaining offset */
+	if (len > count) len = count;   /* don't return bytes not asked for */
+	return len;
+}
+#endif
+
+static int zt_first_empty_alias(void)
+{
+	/* Find the first conference which has no alias pointing to it */
+	int x;
+	for (x=1;x<ZT_MAX_CONF;x++) {
+		if (!confrev[x])
+			return x;
+	}
+	return -1;
+}
+
+static void recalc_maxconfs(void)
+{
+	int x;
+	for (x=ZT_MAX_CONF-1;x>0;x--) {
+		if (confrev[x]) {
+			maxconfs = x+1;
+			return;
+		}
+	}
+	maxconfs = 0;
+}
+
+static void recalc_maxlinks(void)
+{
+	int x;
+	for (x=ZT_MAX_CONF-1;x>0;x--) {
+		if (conf_links[x].src || conf_links[x].dst) {
+			maxlinks = x+1;
+			return;
+		}
+	}
+	maxlinks = 0;
+}
+
+static int zt_first_empty_conference(void)
+{
+	/* Find the first conference which has no alias */
+	int x;
+	for (x=ZT_MAX_CONF-1;x>0;x--) {
+		if (!confalias[x])
+			return x;
+	}
+	return -1;
+}
+
+static int zt_get_conf_alias(int x)
+{
+	int a;
+	if (confalias[x]) {
+		return confalias[x];
+	}
+
+	/* Allocate an alias */
+	a = zt_first_empty_alias();
+	confalias[x] = a;
+	confrev[a] = x;
+
+	/* Highest conference may have changed */
+	recalc_maxconfs();
+	return a;
+}
+
+static void zt_check_conf(int x)
+{
+	int y;
+
+	/* return if no valid conf number */
+	if (x <= 0) return;
+	/* Return if there is no alias */
+	if (!confalias[x])
+		return;
+	for (y=0;y<maxchans;y++) {
+		if (chans[y] && (chans[y]->confna == x) &&
+			((chans[y]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONF ||
+			(chans[y]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFANN ||
+			(chans[y]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFMON ||
+			(chans[y]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFANNMON ||
+			(chans[y]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_REALANDPSEUDO))
+			return;
+	}
+	/* If we get here, nobody is in the conference anymore.  Clear it out
+	   both forward and reverse */
+	confrev[confalias[x]] = 0;
+	confalias[x] = 0;
+
+	/* Highest conference may have changed */
+	recalc_maxconfs();
+}
+
+/* enqueue an event on a channel */
+static void __qevent(struct zt_chan *chan, int event)
+{
+
+	  /* if full, ignore */
+	if ((chan->eventoutidx == 0) && (chan->eventinidx == (ZT_MAX_EVENTSIZE - 1))) 
+		return;
+	  /* if full, ignore */
+	if (chan->eventinidx == (chan->eventoutidx - 1)) return;
+	  /* save the event */
+	chan->eventbuf[chan->eventinidx++] = event;
+	  /* wrap the index, if necessary */
+	if (chan->eventinidx >= ZT_MAX_EVENTSIZE) chan->eventinidx = 0;
+	  /* wake em all up */
+	if (chan->iomask & ZT_IOMUX_SIGEVENT) wake_up_interruptible(&chan->eventbufq);
+	wake_up_interruptible(&chan->readbufq);
+	wake_up_interruptible(&chan->writebufq);
+	wake_up_interruptible(&chan->sel);
+	return;
+}
+
+void zt_qevent_nolock(struct zt_chan *chan, int event)
+{
+	__qevent(chan, event);
+}
+
+void zt_qevent_lock(struct zt_chan *chan, int event)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&chan->lock, flags);
+	__qevent(chan, event);
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+/* sleep in user space until woken up. Equivilant of tsleep() in BSD */
+static int schluffen(wait_queue_head_t *q)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	add_wait_queue(q, &wait);
+	current->state = TASK_INTERRUPTIBLE;
+	if (!signal_pending(current)) schedule();
+	current->state = TASK_RUNNING;
+	remove_wait_queue(q, &wait);
+	if (signal_pending(current)) {
+		return -ERESTARTSYS;
+	}
+	return(0);
+}
+
+static inline void calc_fcs(struct zt_chan *ss, int inwritebuf)
+{
+	int x;
+	unsigned int fcs=PPP_INITFCS;
+	unsigned char *data = ss->writebuf[inwritebuf];
+	int len = ss->writen[inwritebuf];
+	/* Not enough space to do FCS calculation */
+	if (len < 2)
+		return;
+	for (x=0;x<len-2;x++)
+		fcs = PPP_FCS(fcs, data[x]);
+	fcs ^= 0xffff;
+	/* Send out the FCS */
+	data[len-2] = (fcs & 0xff);
+	data[len-1] = (fcs >> 8) & 0xff;
+}
+
+static int zt_reallocbufs(struct zt_chan *ss, int j, int numbufs)
+{
+	unsigned char *newbuf, *oldbuf;
+	unsigned long flags;
+	int x;
+	/* Check numbufs */
+	if (numbufs < 2)
+		numbufs = 2;
+	if (numbufs > ZT_MAX_NUM_BUFS)
+		numbufs = ZT_MAX_NUM_BUFS;
+	/* We need to allocate our buffers now */
+	if (j) {
+		newbuf = kmalloc(j * 2 * numbufs, GFP_KERNEL);
+		if (!newbuf) 
+			return (-ENOMEM);
+		memset(newbuf, 0, j * 2 * numbufs);
+	} else
+		newbuf = NULL;
+	  /* Now that we've allocated our new buffer, we can safely
+	     move things around... */
+	spin_lock_irqsave(&ss->lock, flags);
+	ss->blocksize = j; /* set the blocksize */
+	oldbuf = ss->readbuf[0]; /* Keep track of the old buffer */
+	ss->readbuf[0] = NULL;
+	if (newbuf) {
+		for (x=0;x<numbufs;x++) {
+			ss->readbuf[x] = newbuf + x * j;
+			ss->writebuf[x] = newbuf + (numbufs + x) * j;
+		}
+	} else {
+		for (x=0;x<numbufs;x++) {
+			ss->readbuf[x] = NULL;
+			ss->writebuf[x] = NULL;
+		}
+	}
+	/* Mark all buffers as empty */
+	for (x=0;x<numbufs;x++) 
+		ss->writen[x] = 
+		ss->writeidx[x]=
+		ss->readn[x]=
+		ss->readidx[x] = 0;
+	
+	/* Keep track of where our data goes (if it goes
+	   anywhere at all) */
+	if (newbuf) {
+		ss->inreadbuf = 0;
+		ss->inwritebuf = 0;
+	} else {
+		ss->inreadbuf = -1;
+		ss->inwritebuf = -1;
+	}
+	ss->outreadbuf = -1;
+	ss->outwritebuf = -1;
+	ss->numbufs = numbufs;
+	if (ss->txbufpolicy == ZT_POLICY_WHEN_FULL)
+		ss->txdisable = 1;
+	else
+		ss->txdisable = 0;
+
+	if (ss->rxbufpolicy == ZT_POLICY_WHEN_FULL)
+		ss->rxdisable = 1;
+	else
+		ss->rxdisable = 0;
+
+	spin_unlock_irqrestore(&ss->lock, flags);
+	if (oldbuf)
+		kfree(oldbuf);
+	return 0;
+}
+
+static int zt_hangup(struct zt_chan *chan);
+static void zt_set_law(struct zt_chan *chan, int law);
+
+/* Pull a ZT_CHUNKSIZE piece off the queue.  Returns
+   0 on success or -1 on failure.  If failed, provides
+   silence */
+static int __buf_pull(struct confq *q, u_char *data, struct zt_chan *c, char *label)
+{
+	int oldoutbuf = q->outbuf;
+	/* Ain't nuffin to read */
+	if (q->outbuf < 0) {
+		if (data)
+			memset(data, ZT_LIN2X(0,c), ZT_CHUNKSIZE);
+		return -1;
+	}
+	if (data)
+		memcpy(data, q->buf[q->outbuf], ZT_CHUNKSIZE);
+	q->outbuf = (q->outbuf + 1) % ZT_CB_SIZE;
+
+	/* Won't be nuffin next time */
+	if (q->outbuf == q->inbuf) {
+		q->outbuf = -1;
+	}
+
+	/* If they thought there was no space then
+	   there is now where we just read */
+	if (q->inbuf < 0) 
+		q->inbuf = oldoutbuf;
+	return 0;
+}
+
+/* Returns a place to put stuff, or NULL if there is
+   no room */
+
+static u_char *__buf_pushpeek(struct confq *q)
+{
+	if (q->inbuf < 0)
+		return NULL;
+	return q->buf[q->inbuf];
+}
+
+static u_char *__buf_peek(struct confq *q)
+{
+	if (q->outbuf < 0)
+		return NULL;
+	return q->buf[q->outbuf];
+}
+
+#ifdef BUF_MUNGE
+static u_char *__buf_cpush(struct confq *q)
+{
+	int pos;
+	/* If we have no space, return where the
+	   last space that we *did* have was */
+	if (q->inbuf > -1)
+		return NULL;
+	pos = q->outbuf - 1;
+	if (pos < 0)
+		pos += ZT_CB_SIZE;
+	return q->buf[pos];
+}
+
+static void __buf_munge(struct zt_chan *chan, u_char *old, u_char *new)
+{
+	/* Run a weighted average of the old and new, in order to
+	   mask a missing sample */
+	int x;
+	int val;
+	for (x=0;x<ZT_CHUNKSIZE;x++) {
+		val = x * ZT_XLAW(new[x], chan) + (ZT_CHUNKSIZE - x - 1) * ZT_XLAW(old[x], chan);
+		val = val / (ZT_CHUNKSIZE - 1);
+		old[x] = ZT_LIN2X(val, chan);
+	}
+}
+#endif
+/* Push something onto the queue, or assume what
+   is there is valid if data is NULL */
+static int __buf_push(struct confq *q, u_char *data, char *label)
+{
+	int oldinbuf = q->inbuf;
+	if (q->inbuf < 0) {
+		return -1;
+	}
+	if (data)
+		/* Copy in the data */
+		memcpy(q->buf[q->inbuf], data, ZT_CHUNKSIZE);
+
+	/* Advance the inbuf pointer */
+	q->inbuf = (q->inbuf + 1) % ZT_CB_SIZE;
+
+	if (q->inbuf == q->outbuf) {
+		/* No space anymore... */	
+		q->inbuf = -1;
+	}
+	/* If they don't think data is ready, let
+	   them know it is now */
+	if (q->outbuf < 0) {
+		q->outbuf = oldinbuf;
+	}
+	return 0;
+}
+
+static void reset_conf(struct zt_chan *chan)
+{
+	int x;
+	/* Empty out buffers and reset to initialization */
+	for (x=0;x<ZT_CB_SIZE;x++)
+		chan->confin.buf[x] = chan->confin.buffer + ZT_CHUNKSIZE * x;
+	chan->confin.inbuf = 0;
+	chan->confin.outbuf = -1;
+
+	for (x=0;x<ZT_CB_SIZE;x++)
+		chan->confout.buf[x] = chan->confout.buffer + ZT_CHUNKSIZE * x;
+	chan->confout.inbuf = 0;
+	chan->confout.outbuf = -1;
+}
+
+
+static inline int hw_echocancel_off(struct zt_chan *chan)
+{
+	struct zt_echocanparams ecp;
+	
+	int ret = -ENODEV;
+	if (chan->span) {
+		if (chan->span->echocan) {
+			ret = chan->span->echocan(chan, 0);
+		} else if (chan->span->echocan_with_params) {
+			memset(&ecp, 0, sizeof(ecp));  /* Sets tap length to 0 */
+			ret = chan->span->echocan_with_params(chan, &ecp, NULL);
+		}
+	}
+	return ret;
+}
+
+static void close_channel(struct zt_chan *chan)
+{
+	unsigned long flags;
+	void *rxgain = NULL;
+	struct echo_can_state *ec = NULL;
+	int oldconf;
+	short *readchunkpreec;
+#ifdef CONFIG_ZAPATA_PPP
+	struct ppp_channel *ppp;
+#endif
+
+	/* XXX Buffers should be send out before reallocation!!! XXX */
+	if (!(chan->flags & ZT_FLAG_NOSTDTXRX))
+		zt_reallocbufs(chan, 0, 0); 
+	spin_lock_irqsave(&chan->lock, flags);
+#ifdef CONFIG_ZAPATA_PPP
+	ppp = chan->ppp;
+	chan->ppp = NULL;
+#endif
+	ec = chan->ec;
+	chan->ec = NULL;
+	readchunkpreec = chan->readchunkpreec;
+	chan->readchunkpreec = NULL;
+	chan->curtone = NULL;
+	if (chan->curzone)
+		atomic_dec(&chan->curzone->refcount);
+	chan->curzone = NULL;
+	chan->cadencepos = 0;
+	chan->pdialcount = 0;
+	zt_hangup(chan); 
+	chan->itimerset = chan->itimer = 0;
+	chan->pulsecount = 0;
+	chan->pulsetimer = 0;
+	chan->ringdebtimer = 0;
+	init_waitqueue_head(&chan->sel);
+	init_waitqueue_head(&chan->readbufq);
+	init_waitqueue_head(&chan->writebufq);
+	init_waitqueue_head(&chan->eventbufq);
+	init_waitqueue_head(&chan->txstateq);
+	chan->txdialbuf[0] = '\0';
+	chan->digitmode = DIGIT_MODE_DTMF;
+	chan->dialing = 0;
+	chan->afterdialingtimer = 0;
+	  /* initialize IO MUX mask */
+	chan->iomask = 0;
+	/* save old conf number, if any */
+	oldconf = chan->confna;
+	  /* initialize conference variables */
+	chan->_confn = 0;
+	if ((chan->sig & __ZT_SIG_DACS) != __ZT_SIG_DACS) {
+		chan->confna = 0;
+		chan->confmode = 0;
+	}
+	chan->confmute = 0;
+	/* release conference resource, if any to release */
+	if (oldconf) zt_check_conf(oldconf);
+	chan->gotgs = 0;
+	reset_conf(chan);
+	
+	if (chan->gainalloc && chan->rxgain)
+		rxgain = chan->rxgain;
+
+	chan->rxgain = defgain;
+	chan->txgain = defgain;
+	chan->gainalloc = 0;
+	chan->eventinidx = chan->eventoutidx = 0;
+	chan->flags &= ~(ZT_FLAG_LOOPED | ZT_FLAG_LINEAR | ZT_FLAG_PPP | ZT_FLAG_SIGFREEZE);
+
+	zt_set_law(chan,0);
+
+	memset(chan->conflast, 0, sizeof(chan->conflast));
+	memset(chan->conflast1, 0, sizeof(chan->conflast1));
+	memset(chan->conflast2, 0, sizeof(chan->conflast2));
+
+	if (chan->span && chan->span->dacs && oldconf)
+		chan->span->dacs(chan, NULL);
+
+	spin_unlock_irqrestore(&chan->lock, flags);
+
+	hw_echocancel_off(chan);
+
+	if (rxgain)
+		kfree(rxgain);
+	if (ec)
+		echo_can_free(ec);
+	if (readchunkpreec)
+		kfree(readchunkpreec);
+
+#ifdef CONFIG_ZAPATA_PPP
+	if (ppp) {
+		tasklet_kill(&chan->ppp_calls);
+		skb_queue_purge(&chan->ppp_rq);
+		ppp_unregister_channel(ppp);
+		kfree(ppp);
+	}
+#endif
+
+}
+
+static int free_tone_zone(int num)
+{
+	struct zt_zone *z;
+
+	if ((num >= ZT_TONE_ZONE_MAX) || (num < 0))
+		return -EINVAL;
+
+	write_lock(&zone_lock);
+	z = tone_zones[num];
+	tone_zones[num] = NULL;
+	write_unlock(&zone_lock);
+	if (!z)
+		return 0;
+
+	if (atomic_read(&z->refcount)) {
+		/* channels are still using this zone so put it back */
+		write_lock(&zone_lock);
+		tone_zones[num] = z;
+		write_unlock(&zone_lock);
+
+		return -EBUSY;
+	} else {
+		kfree(z);
+
+		return 0;
+	}
+}
+
+static int zt_register_tone_zone(int num, struct zt_zone *zone)
+{
+	int res = 0;
+
+	if ((num >= ZT_TONE_ZONE_MAX) || (num < 0))
+		return -EINVAL;
+
+	write_lock(&zone_lock);
+	if (tone_zones[num]) {
+		res = -EINVAL;
+	} else {
+		res = 0;
+		tone_zones[num] = zone;
+	}
+	write_unlock(&zone_lock);
+
+	if (!res)
+		printk(KERN_INFO "Registered tone zone %d (%s)\n", num, zone->name);
+
+	return res;
+}
+
+static int start_tone(struct zt_chan *chan, int tone)
+{
+	int res = -EINVAL;
+
+	/* Stop the current tone, no matter what */
+	chan->tonep = 0;
+	chan->curtone = NULL;
+	chan->pdialcount = 0;
+	chan->txdialbuf[0] = '\0';
+	chan->dialing = 0;
+
+	if (tone == -1) {
+		/* Just stop the current tone */
+		res = 0;
+	} else if (!chan->curzone) {
+		static int __warnonce = 1;
+		if (__warnonce) {
+			__warnonce = 0;
+			/* The tonezones are loaded by ztcfg based on /etc/zaptel.conf. */
+			printk(KERN_WARNING "zaptel: Cannot start tones until tone zone is loaded.\n");
+		}
+		/* Note that no tone zone exists at the moment */
+		res = -ENODATA;
+	} else if ((tone >= 0 && tone <= ZT_TONE_MAX)) {
+		/* Have a tone zone */
+		if (chan->curzone->tones[tone]) {
+			chan->curtone = chan->curzone->tones[tone];
+			res = 0;
+		} else { /* Indicate that zone is loaded but no such tone exists */
+			res = -ENOSYS;
+		}
+	} else if (chan->digitmode == DIGIT_MODE_DTMF) {
+		if ((tone >= ZT_TONE_DTMF_BASE) && (tone <= ZT_TONE_DTMF_MAX)) {
+			chan->dialing = 1;
+			res = 0;
+			tone -= ZT_TONE_DTMF_BASE;
+			if (chan->curzone) {
+				/* Have a tone zone */
+				if (chan->curzone->dtmf_continuous[tone].tonesamples) {
+					chan->curtone = &chan->curzone->dtmf_continuous[tone];
+					res = 0;
+				} else {
+					/* Indicate that zone is loaded but no such tone exists */
+					res = -ENOSYS;
+				}
+			} else {
+				/* Note that no tone zone exists at the moment */
+				res = -ENODATA;
+			}
+		} else {
+			res = -EINVAL;
+		}
+	} else if (chan->digitmode == DIGIT_MODE_MFR2_FWD) {
+		if ((tone >= ZT_TONE_MFR2_FWD_BASE) && (tone <= ZT_TONE_MFR2_FWD_MAX)) {
+			res = 0;
+			tone -= ZT_TONE_MFR2_FWD_BASE;
+			if (chan->curzone) {
+				/* Have a tone zone */
+				if (chan->curzone->mfr2_fwd_continuous[tone].tonesamples) {
+					chan->curtone = &chan->curzone->mfr2_fwd_continuous[tone];
+					res = 0;
+				} else {
+					/* Indicate that zone is loaded but no such tone exists */
+					res = -ENOSYS;
+				}
+			} else {
+				/* Note that no tone zone exists at the moment */
+				res = -ENODATA;
+			}
+		} else {
+			res = -EINVAL;
+		}
+	} else if (chan->digitmode == DIGIT_MODE_MFR2_REV) {
+		if ((tone >= ZT_TONE_MFR2_REV_BASE) && (tone <= ZT_TONE_MFR2_REV_MAX)) {
+			res = 0;
+			tone -= ZT_TONE_MFR2_REV_BASE;
+			if (chan->curzone) {
+				/* Have a tone zone */
+				if (chan->curzone->mfr2_rev_continuous[tone].tonesamples) {
+					chan->curtone = &chan->curzone->mfr2_rev_continuous[tone];
+					res = 0;
+				} else {
+					/* Indicate that zone is loaded but no such tone exists */
+					res = -ENOSYS;
+				}
+			} else {
+				/* Note that no tone zone exists at the moment */
+				res = -ENODATA;
+			}
+		} else {
+			res = -EINVAL;
+		}
+	} else {
+		chan->dialing = 0;
+		res = -EINVAL;
+	}
+
+	if (chan->curtone)
+		zt_init_tone_state(&chan->ts, chan->curtone);
+	
+	return res;
+}
+
+static int set_tone_zone(struct zt_chan *chan, int zone)
+{
+	int res = 0;
+	struct zt_zone *z;
+	unsigned long flags;
+
+	/* Do not call with the channel locked. */
+
+	if (zone == -1)
+		zone = default_zone;
+
+	if ((zone >= ZT_TONE_ZONE_MAX) || (zone < 0))
+		return -EINVAL;
+
+	read_lock(&zone_lock);
+
+	if ((z = tone_zones[zone])) {
+		spin_lock_irqsave(&chan->lock, flags);
+		if (chan->curzone)
+			atomic_dec(&chan->curzone->refcount);
+
+		atomic_inc(&z->refcount);
+		chan->curzone = z;
+		chan->tonezone = zone;
+		memcpy(chan->ringcadence, z->ringcadence, sizeof(chan->ringcadence));
+		spin_unlock_irqrestore(&chan->lock, flags);
+	} else {
+		res = -ENODATA;
+	}
+
+	read_unlock(&zone_lock);
+
+	return res;
+}
+
+static void zt_set_law(struct zt_chan *chan, int law)
+{
+	if (!law) {
+		if (chan->deflaw)
+			law = chan->deflaw;
+		else
+			if (chan->span) law = chan->span->deflaw;
+			else law = ZT_LAW_MULAW;
+	}
+	if (law == ZT_LAW_ALAW) {
+		chan->xlaw = __zt_alaw;
+#ifdef CONFIG_CALC_XLAW
+		chan->lineartoxlaw = __zt_lineartoalaw;
+#else
+		chan->lin2x = __zt_lin2a;
+#endif
+	} else {
+		chan->xlaw = __zt_mulaw;
+#ifdef CONFIG_CALC_XLAW
+		chan->lineartoxlaw = __zt_lineartoulaw;
+#else
+		chan->lin2x = __zt_lin2mu;
+#endif
+	}
+}
+
+#ifdef CONFIG_DEVFS_FS
+static devfs_handle_t register_devfs_channel(struct zt_chan *chan, devfs_handle_t dir)
+{
+	char path[100];
+	char link[100];
+	char buf[50];
+	char tmp[100];
+	int link_offset = 0;
+	int tmp_offset = 0;
+	int path_offset = 0;
+	int err = 0;
+	devfs_handle_t chan_dev;
+	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+	unsigned int flags = DEVFS_FL_AUTO_OWNER;
+
+	sprintf(path, "%d", chan->chanpos);
+	chan_dev = devfs_register(dir, path, flags, ZT_MAJOR, chan->channo, mode, &zt_fops, NULL);
+	if (!chan_dev) {
+		printk("zaptel: Something really bad happened.  Unable to register devfs entry\n");
+		return NULL;
+	}
+
+	/* Set up the path of the destination of the link */
+	link_offset = devfs_generate_path(chan_dev, link, sizeof(link) - 1);
+	/* Now we need to strip off the leading "zap/".  If we don't, then we build a broken symlink */
+	path_offset = devfs_generate_path(zaptel_devfs_dir, path, sizeof(path) - 1); /* We'll just "borrow" path for a second */
+	path_offset = strlen(path+path_offset);
+	link_offset += path_offset; /* Taking out the "zap" */
+	link_offset++; /* Add one more place for the '/'.  The path generated does not contain the '/' we need to strip */
+	
+	/* Set up the path of the file/link itself */
+	tmp_offset = devfs_generate_path(zaptel_devfs_dir, tmp, sizeof(tmp) - 1);
+	sprintf(buf, "/%d", chan->channo);
+	zap_copy_string(path, tmp+tmp_offset, sizeof(path));
+	strncat(path, buf, sizeof(path) - 1);
+
+	err = devfs_mk_symlink(NULL, path, DEVFS_FL_DEFAULT, link+link_offset, &chan->fhandle_symlink, NULL);
+	if (err != 0) {
+		printk("Problem with making devfs symlink: %d\n", err);
+	}
+
+	return chan_dev;
+}
+#endif /* CONFIG_DEVFS_FS */
+
+static int zt_chan_reg(struct zt_chan *chan)
+{
+	int x;
+	int res=0;
+	unsigned long flags;
+	
+	write_lock_irqsave(&chan_lock, flags);
+	for (x=1;x<ZT_MAX_CHANNELS;x++) {
+		if (!chans[x]) {
+			spin_lock_init(&chan->lock);
+			chans[x] = chan;
+			if (maxchans < x + 1)
+				maxchans = x + 1;
+			chan->channo = x;
+			if (!chan->master)
+				chan->master = chan;
+			if (!chan->readchunk)
+				chan->readchunk = chan->sreadchunk;
+			if (!chan->writechunk)
+				chan->writechunk = chan->swritechunk;
+			zt_set_law(chan, 0);
+			close_channel(chan); 
+			/* set this AFTER running close_channel() so that
+				HDLC channels wont cause hangage */
+			chan->flags |= ZT_FLAG_REGISTERED;
+			res = 0;
+			break;
+		}
+	}
+	write_unlock_irqrestore(&chan_lock, flags);	
+	if (x >= ZT_MAX_CHANNELS)
+		printk(KERN_ERR "No more channels available\n");
+	return res;
+}
+
+char *zt_lboname(int x)
+{
+	if ((x < 0) || ( x > 7))
+		return "Unknown";
+	return zt_txlevelnames[x];
+}
+
+#if defined(CONFIG_ZAPATA_NET) || defined(CONFIG_ZAPATA_PPP)
+#endif
+
+#ifdef CONFIG_ZAPATA_NET
+#ifdef NEW_HDLC_INTERFACE
+static int zt_net_open(struct net_device *dev)
+{
+#ifdef LINUX26
+	int res = hdlc_open(dev);
+	struct zt_chan *ms = dev_to_ztchan(dev);
+#else
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	struct zt_chan *ms = hdlc_to_ztchan(hdlc);
+	int res = hdlc_open(hdlc);
+#endif	
+	                                                                                                                             
+/*	if (!dev->hard_start_xmit) return res; is this really necessary? --byg */
+	if (res) /* this is necessary to avoid kernel panic when UNSPEC link encap, proven --byg */
+		return res;
+#else
+static int zt_net_open(hdlc_device *hdlc)
+{
+	struct zt_chan *ms = hdlc_to_ztchan(hdlc);
+	int res;
+#endif
+	if (!ms) {
+		printk("zt_net_open: nothing??\n");
+		return -EINVAL;
+	}
+	if (ms->flags & ZT_FLAG_OPEN) {
+		printk("%s is already open!\n", ms->name);
+		return -EBUSY;
+	}
+	if (!(ms->flags & ZT_FLAG_NETDEV)) {
+		printk("%s is not a net device!\n", ms->name);
+		return -EINVAL;
+	}
+	ms->txbufpolicy = ZT_POLICY_IMMEDIATE;
+	ms->rxbufpolicy = ZT_POLICY_IMMEDIATE;
+
+	res = zt_reallocbufs(ms, ZT_DEFAULT_MTU_MRU, ZT_DEFAULT_NUM_BUFS);
+	if (res) 
+		return res;
+
+	fasthdlc_init(&ms->rxhdlc);
+	fasthdlc_init(&ms->txhdlc);
+	ms->infcs = PPP_INITFCS;
+
+	netif_start_queue(ztchan_to_dev(ms));
+
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#endif	
+#ifdef CONFIG_ZAPATA_DEBUG
+	printk("ZAPNET: Opened channel %d name %s\n", ms->channo, ms->name);
+#endif
+	return 0;
+}
+
+#ifdef LINUX26
+static int zt_register_hdlc_device(struct net_device *dev, const char *dev_name)
+{
+	int result;
+
+	if (dev_name && *dev_name) {
+		if ((result = dev_alloc_name(dev, dev_name)) < 0)
+			return result;
+	}
+	result = register_netdev(dev);
+	if (result != 0)
+		return -EIO;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,14)
+	if (netif_carrier_ok(dev))
+		netif_carrier_off(dev); /* no carrier until DCD goes up */
+#endif
+	return 0;
+}
+#endif
+
+#ifdef NEW_HDLC_INTERFACE
+static int zt_net_stop(struct net_device *dev)
+{
+#ifdef LINUX26
+    hdlc_device *h = dev_to_hdlc(dev);
+    struct zt_hdlc *hdlc = h->priv;
+#else
+    hdlc_device *hdlc = dev_to_hdlc(dev);
+#endif
+
+#else
+static void zt_net_close(hdlc_device *hdlc)
+{
+#endif
+	struct zt_chan *ms = hdlc_to_ztchan(hdlc);
+	if (!ms) {
+#ifdef NEW_HDLC_INTERFACE
+		printk("zt_net_stop: nothing??\n");
+		return 0;
+#else
+		printk("zt_net_close: nothing??\n");
+		return;
+#endif
+	}
+	if (!(ms->flags & ZT_FLAG_NETDEV)) {
+#ifdef NEW_HDLC_INTERFACE
+		printk("zt_net_stop: %s is not a net device!\n", ms->name);
+		return 0;
+#else
+		printk("zt_net_close: %s is not a net device!\n", ms->name);
+		return;
+#endif
+	}
+	/* Not much to do here.  Just deallocate the buffers */
+        netif_stop_queue(ztchan_to_dev(ms));
+	zt_reallocbufs(ms, 0, 0);
+#ifdef LINUX26
+	hdlc_close(dev);
+#else
+#ifndef CONFIG_OLD_HDLC_API
+	hdlc_close(hdlc);
+#endif
+#endif	
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#endif	
+#ifdef NEW_HDLC_INTERFACE
+	return 0;
+#else
+	return;
+#endif
+}
+
+#ifdef NEW_HDLC_INTERFACE
+/* kernel 2.4.20+ has introduced attach function, dunno what to do,
+ just copy sources from dscc4 to be sure and ready for further mastering,
+ NOOP right now (i.e. really a stub)  --byg */
+#ifdef LINUX26
+static int zt_net_attach(struct net_device *dev, unsigned short encoding,
+        unsigned short parity)
+#else		
+static int zt_net_attach(hdlc_device *hdlc, unsigned short encoding,
+        unsigned short parity)
+#endif
+{
+/*        struct net_device *dev = hdlc_to_dev(hdlc);
+        struct dscc4_dev_priv *dpriv = dscc4_priv(dev);
+
+        if (encoding != ENCODING_NRZ &&
+            encoding != ENCODING_NRZI &&
+            encoding != ENCODING_FM_MARK &&
+            encoding != ENCODING_FM_SPACE &&
+            encoding != ENCODING_MANCHESTER)
+                return -EINVAL;
+
+        if (parity != PARITY_NONE &&
+            parity != PARITY_CRC16_PR0_CCITT &&
+            parity != PARITY_CRC16_PR1_CCITT &&
+            parity != PARITY_CRC32_PR0_CCITT &&
+            parity != PARITY_CRC32_PR1_CCITT)
+                return -EINVAL;
+
+        dpriv->encoding = encoding;
+        dpriv->parity = parity;*/
+        return 0;
+}
+#endif
+																								 
+static struct zt_hdlc *zt_hdlc_alloc(void)
+{
+	struct zt_hdlc *tmp;
+	tmp = kmalloc(sizeof(struct zt_hdlc), GFP_KERNEL);
+	if (tmp) {
+		memset(tmp, 0, sizeof(struct zt_hdlc));
+	}
+	return tmp;
+}
+
+#ifdef NEW_HDLC_INTERFACE
+static int zt_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	/* FIXME: this construction seems to be not very optimal for me but I could find nothing better at the moment (Friday, 10PM :( )  --byg */
+/*	struct zt_chan *ss = hdlc_to_ztchan(list_entry(dev, struct zt_hdlc, netdev.netdev));*/
+#ifdef LINUX26
+	struct zt_chan *ss = dev_to_ztchan(dev);
+	struct net_device_stats *stats = hdlc_stats(dev);
+#else
+	struct zt_chan *ss = (list_entry(dev, struct zt_hdlc, netdev.netdev)->chan);
+	struct net_device_stats *stats = &ss->hdlcnetdev->netdev.stats;
+#endif	
+
+#else
+static int zt_xmit(hdlc_device *hdlc, struct sk_buff *skb)
+{
+	struct zt_chan *ss = hdlc_to_ztchan(hdlc);
+	struct net_device *dev = &ss->hdlcnetdev->netdev.netdev;
+	struct net_device_stats *stats = &ss->hdlcnetdev->netdev.stats;
+#endif
+	int retval = 1;
+	int x,oldbuf;
+	unsigned int fcs;
+	unsigned char *data;
+	unsigned long flags;
+	/* See if we have any buffers */
+	spin_lock_irqsave(&ss->lock, flags);
+	if (skb->len > ss->blocksize - 2) {
+		printk(KERN_ERR "zt_xmit(%s): skb is too large (%d > %d)\n", dev->name, skb->len, ss->blocksize -2);
+		stats->tx_dropped++;
+		retval = 0;
+	} else if (ss->inwritebuf >= 0) {
+		/* We have a place to put this packet */
+		/* XXX We should keep the SKB and avoid the memcpy XXX */
+		data = ss->writebuf[ss->inwritebuf];
+		memcpy(data, skb->data, skb->len);
+		ss->writen[ss->inwritebuf] = skb->len;
+		ss->writeidx[ss->inwritebuf] = 0;
+		/* Calculate the FCS */
+		fcs = PPP_INITFCS;
+		for (x=0;x<skb->len;x++)
+			fcs = PPP_FCS(fcs, data[x]);
+		/* Invert it */
+		fcs ^= 0xffff;
+		/* Send it out LSB first */
+		data[ss->writen[ss->inwritebuf]++] = (fcs & 0xff);
+		data[ss->writen[ss->inwritebuf]++] = (fcs >> 8) & 0xff;
+		/* Advance to next window */
+		oldbuf = ss->inwritebuf;
+		ss->inwritebuf = (ss->inwritebuf + 1) % ss->numbufs;
+
+		if (ss->inwritebuf == ss->outwritebuf) {
+			/* Whoops, no more space.  */
+		    ss->inwritebuf = -1;
+
+		    netif_stop_queue(ztchan_to_dev(ss));
+		}
+		if (ss->outwritebuf < 0) {
+			/* Let the interrupt handler know there's
+			   some space for us */
+			ss->outwritebuf = oldbuf;
+		}
+		dev->trans_start = jiffies;
+		stats->tx_packets++;
+		stats->tx_bytes += ss->writen[oldbuf];
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("Buffered %d bytes to go out in buffer %d\n", ss->writen[oldbuf], oldbuf);
+		for (x=0;x<ss->writen[oldbuf];x++)
+		     printk("%02x ", ss->writebuf[oldbuf][x]);
+		printk("\n");
+#endif
+		retval = 0;
+		/* Free the SKB */
+		dev_kfree_skb_any(skb);
+	}
+	spin_unlock_irqrestore(&ss->lock, flags);
+	return retval;
+}
+
+#ifdef NEW_HDLC_INTERFACE
+static int zt_net_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	return hdlc_ioctl(dev, ifr, cmd);
+}
+#else
+static int zt_net_ioctl(hdlc_device *hdlc, struct ifreq *ifr, int cmd)
+{
+	return -EIO;
+}
+#endif
+
+#endif
+
+#ifdef CONFIG_ZAPATA_PPP
+
+static int zt_ppp_xmit(struct ppp_channel *ppp, struct sk_buff *skb)
+{
+
+	/* 
+	 * If we can't handle the packet right now, return 0.  If we
+	 * we handle or drop it, return 1.  Always free if we return
+	 * 1 and never if we return 0
+         */
+	struct zt_chan *ss = ppp->private;
+	int x,oldbuf;
+	unsigned int fcs;
+	unsigned char *data;
+	long flags;
+	int retval = 0;
+
+	/* See if we have any buffers */
+	spin_lock_irqsave(&ss->lock, flags);
+	if (!(ss->flags & ZT_FLAG_OPEN)) {
+		printk("Can't transmit on closed channel\n");
+		retval = 1;
+	} else if (skb->len > ss->blocksize - 4) {
+		printk(KERN_ERR "zt_ppp_xmit(%s): skb is too large (%d > %d)\n", ss->name, skb->len, ss->blocksize -2);
+		retval = 1;
+	} else if (ss->inwritebuf >= 0) {
+		/* We have a place to put this packet */
+		/* XXX We should keep the SKB and avoid the memcpy XXX */
+		data = ss->writebuf[ss->inwritebuf];
+		/* Start with header of two bytes */
+		/* Add "ALL STATIONS" and "UNNUMBERED" */
+		data[0] = 0xff;
+		data[1] = 0x03;
+		ss->writen[ss->inwritebuf] = 2;
+
+		/* Copy real data and increment amount written */
+		memcpy(data + 2, skb->data, skb->len);
+
+		ss->writen[ss->inwritebuf] += skb->len;
+
+		/* Re-set index back to zero */
+		ss->writeidx[ss->inwritebuf] = 0;
+
+		/* Calculate the FCS */
+		fcs = PPP_INITFCS;
+		for (x=0;x<skb->len + 2;x++)
+			fcs = PPP_FCS(fcs, data[x]);
+		/* Invert it */
+		fcs ^= 0xffff;
+
+		/* Point past the real data now */
+		data += (skb->len + 2);
+
+		/* Send FCS out LSB first */
+		data[0] = (fcs & 0xff);
+		data[1] = (fcs >> 8) & 0xff;
+
+		/* Account for FCS length */
+		ss->writen[ss->inwritebuf]+=2;
+
+		/* Advance to next window */
+		oldbuf = ss->inwritebuf;
+		ss->inwritebuf = (ss->inwritebuf + 1) % ss->numbufs;
+
+		if (ss->inwritebuf == ss->outwritebuf) {
+			/* Whoops, no more space.  */
+			ss->inwritebuf = -1;
+		}
+		if (ss->outwritebuf < 0) {
+			/* Let the interrupt handler know there's
+			   some space for us */
+			ss->outwritebuf = oldbuf;
+		}
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("Buffered %d bytes (skblen = %d) to go out in buffer %d\n", ss->writen[oldbuf], skb->len, oldbuf);
+		for (x=0;x<ss->writen[oldbuf];x++)
+		     printk("%02x ", ss->writebuf[oldbuf][x]);
+		printk("\n");
+#endif
+		retval = 1;
+	}
+	spin_unlock_irqrestore(&ss->lock, flags);
+	if (retval) {
+		/* Get rid of the SKB if we're returning non-zero */
+		/* N.B. this is called in process or BH context so
+		   dev_kfree_skb is OK. */
+		dev_kfree_skb(skb);
+	}
+	return retval;
+}
+
+static int zt_ppp_ioctl(struct ppp_channel *ppp, unsigned int cmd, unsigned long flags)
+{
+	return -EIO;
+}
+
+static struct ppp_channel_ops ztppp_ops =
+{
+	start_xmit: zt_ppp_xmit,
+	ioctl: zt_ppp_ioctl,
+};
+
+#endif
+
+static void zt_chan_unreg(struct zt_chan *chan)
+{
+	int x;
+	unsigned long flags;
+#ifdef CONFIG_ZAPATA_NET
+	if (chan->flags & ZT_FLAG_NETDEV) {
+#ifdef LINUX26
+		unregister_hdlc_device(chan->hdlcnetdev->netdev);
+		free_netdev(chan->hdlcnetdev->netdev);
+#else
+		unregister_hdlc_device(&chan->hdlcnetdev->netdev);
+#endif
+		kfree(chan->hdlcnetdev);
+		chan->hdlcnetdev = NULL;
+	}
+#endif
+	write_lock_irqsave(&chan_lock, flags);
+	if (chan->flags & ZT_FLAG_REGISTERED) {
+		chans[chan->channo] = NULL;
+		chan->flags &= ~ZT_FLAG_REGISTERED;
+	}
+#ifdef CONFIG_ZAPATA_PPP
+	if (chan->ppp) {
+		printk("HUH???  PPP still attached??\n");
+	}
+#endif
+	maxchans = 0;
+	for (x=1;x<ZT_MAX_CHANNELS;x++) 
+		if (chans[x]) {
+			maxchans = x + 1;
+			/* Remove anyone pointing to us as master
+			   and make them their own thing */
+			if (chans[x]->master == chan) {
+				chans[x]->master = chans[x];
+			}
+			if ((chans[x]->confna == chan->channo) &&
+				((chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORTX ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORBOTH ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_RX_PREECHO ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_TX_PREECHO ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORBOTH_PREECHO ||
+				(chans[x]->confmode & ZT_CONF_MODE_MASK) == ZT_CONF_DIGITALMON)) {
+				/* Take them out of conference with us */
+				/* release conference resource if any */
+				if (chans[x]->confna) {
+					zt_check_conf(chans[x]->confna);
+					if (chans[x]->span && chans[x]->span->dacs)
+						chans[x]->span->dacs(chans[x], NULL);
+				}
+				chans[x]->confna = 0;
+				chans[x]->_confn = 0;
+				chans[x]->confmode = 0;
+			}
+		}
+	chan->channo = -1;
+	write_unlock_irqrestore(&chan_lock, flags);
+}
+
+static ssize_t zt_chan_read(struct file *file, char *usrbuf, size_t count, int unit)
+{
+	struct zt_chan *chan = chans[unit];
+	int amnt;
+	int res, rv;
+	int oldbuf,x;
+	unsigned long flags;
+	/* Make sure count never exceeds 65k, and make sure it's unsigned */
+	count &= 0xffff;
+	if (!chan) 
+		return -EINVAL;
+	if (count < 1)
+		return -EINVAL;
+	for(;;) {
+		spin_lock_irqsave(&chan->lock, flags);
+		if (chan->eventinidx != chan->eventoutidx) {
+			spin_unlock_irqrestore(&chan->lock, flags);
+			return -ELAST /* - chan->eventbuf[chan->eventoutidx]*/;
+		}
+		res = chan->outreadbuf;
+		if (chan->rxdisable)
+			res = -1;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		if (res >= 0) break;
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		rv = schluffen(&chan->readbufq);
+		if (rv) return (rv);
+	}
+	amnt = count;
+/* added */
+#if 0
+	if ((unit == 24) || (unit == 48) || (unit == 16) || (unit == 47)) { 
+		int myamnt = amnt;
+		int x;
+		if (amnt > chan->readn[res])
+			myamnt = chan->readn[res];
+		printk("zt_chan_read(unit: %d, inwritebuf: %d, outwritebuf: %d amnt: %d\n", 
+			unit, chan->inwritebuf, chan->outwritebuf, myamnt);
+		printk("\t("); for (x = 0; x < myamnt; x++) printk((x ? " %02x" : "%02x"), (unsigned char)usrbuf[x]);
+		printk(")\n");
+	}
+#endif
+/* end addition */
+	if (chan->flags & ZT_FLAG_LINEAR) {
+		if (amnt > (chan->readn[res] << 1))
+			amnt = chan->readn[res] << 1;
+		if (amnt) {
+			/* There seems to be a max stack size, so we have
+			   to do this in smaller pieces */
+			short lindata[128];
+			int left = amnt >> 1; /* amnt is in bytes */
+			int pos = 0;
+			int pass;
+			while(left) {
+				pass = left;
+				if (pass > 128)
+					pass = 128;
+				for (x=0;x<pass;x++)
+					lindata[x] = ZT_XLAW(chan->readbuf[res][x + pos], chan);
+				if (copy_to_user(usrbuf + (pos << 1), lindata, pass << 1))
+					return -EFAULT;
+				left -= pass;
+				pos += pass;
+			}
+		}
+	} else {
+		if (amnt > chan->readn[res])
+			amnt = chan->readn[res];
+		if (amnt) {
+			if (copy_to_user(usrbuf, chan->readbuf[res], amnt))
+				return -EFAULT;
+		}
+	}
+	spin_lock_irqsave(&chan->lock, flags);
+	chan->readidx[res] = 0;
+	chan->readn[res] = 0;
+	oldbuf = res;
+	chan->outreadbuf = (res + 1) % chan->numbufs;
+	if (chan->outreadbuf == chan->inreadbuf) {
+		/* Out of stuff */
+		chan->outreadbuf = -1;
+		if (chan->rxbufpolicy == ZT_POLICY_WHEN_FULL)
+			chan->rxdisable = 1;
+	}
+	if (chan->inreadbuf < 0) {
+		/* Notify interrupt handler that we have some space now */
+		chan->inreadbuf = oldbuf;
+	}
+	spin_unlock_irqrestore(&chan->lock, flags);
+	
+	return amnt;
+}
+
+static ssize_t zt_chan_write(struct file *file, const char *usrbuf, size_t count, int unit)
+{
+	unsigned long flags;
+	struct zt_chan *chan = chans[unit];
+	int res, amnt, oldbuf, rv,x;
+	/* Make sure count never exceeds 65k, and make sure it's unsigned */
+	count &= 0xffff;
+	if (!chan) 
+		return -EINVAL;
+	if (count < 1)
+		return -EINVAL;
+	for(;;) {
+		spin_lock_irqsave(&chan->lock, flags);
+		if ((chan->curtone || chan->pdialcount) && !(chan->flags & ZT_FLAG_PSEUDO)) {
+			chan->curtone = NULL;
+			chan->tonep = 0;
+			chan->dialing = 0;
+			chan->txdialbuf[0] = '\0';
+			chan->pdialcount = 0;
+		}
+		if (chan->eventinidx != chan->eventoutidx) {
+			spin_unlock_irqrestore(&chan->lock, flags);
+			return -ELAST;
+		}
+		res = chan->inwritebuf;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		if (res >= 0) 
+			break;
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		/* Wait for something to be available */
+		rv = schluffen(&chan->writebufq);
+		if (rv)
+			return rv;
+	}
+
+	amnt = count;
+	if (chan->flags & ZT_FLAG_LINEAR) {
+		if (amnt > (chan->blocksize << 1))
+			amnt = chan->blocksize << 1;
+	} else {
+		if (amnt > chan->blocksize)
+			amnt = chan->blocksize;
+	}
+
+#ifdef CONFIG_ZAPATA_DEBUG
+	printk("zt_chan_write(unit: %d, res: %d, outwritebuf: %d amnt: %d\n",
+		unit, chan->res, chan->outwritebuf, amnt);
+#endif
+#if 0
+ 	if ((unit == 24) || (unit == 48) || (unit == 16) || (unit == 47)) { 
+ 		int x;
+ 		printk("zt_chan_write/in(unit: %d, res: %d, outwritebuf: %d amnt: %d, txdisable: %d)\n",
+ 			unit, res, chan->outwritebuf, amnt, chan->txdisable);
+ 		printk("\t("); for (x = 0; x < amnt; x++) printk((x ? " %02x" : "%02x"), (unsigned char)usrbuf[x]);
+ 		printk(")\n");
+ 	}
+#endif
+
+	if (amnt) {
+		if (chan->flags & ZT_FLAG_LINEAR) {
+			/* There seems to be a max stack size, so we have
+			   to do this in smaller pieces */
+			short lindata[128];
+			int left = amnt >> 1; /* amnt is in bytes */
+			int pos = 0;
+			int pass;
+			while(left) {
+				pass = left;
+				if (pass > 128)
+					pass = 128;
+				if (copy_from_user(lindata, usrbuf + (pos << 1), pass << 1))
+					return -EFAULT;
+				left -= pass;
+				for (x=0;x<pass;x++)
+					chan->writebuf[res][x + pos] = ZT_LIN2X(lindata[x], chan);
+				pos += pass;
+			}
+			chan->writen[res] = amnt >> 1;
+		} else {
+			if (copy_from_user(chan->writebuf[res], usrbuf, amnt))
+				return -EFAULT;
+			chan->writen[res] = amnt;
+		}
+		chan->writeidx[res] = 0;
+		if (chan->flags & ZT_FLAG_FCS)
+			calc_fcs(chan, res);
+		oldbuf = res;
+		spin_lock_irqsave(&chan->lock, flags);
+		chan->inwritebuf = (res + 1) % chan->numbufs;
+		if (chan->inwritebuf == chan->outwritebuf) {
+			/* Don't stomp on the transmitter, just wait for them to 
+			   wake us up */
+			chan->inwritebuf = -1;
+			/* Make sure the transmitter is transmitting in case of POLICY_WHEN_FULL */
+			chan->txdisable = 0;
+		}
+		if (chan->outwritebuf < 0) {
+			/* Okay, the interrupt handler has been waiting for us.  Give them a buffer */
+			chan->outwritebuf = oldbuf;
+		}
+		spin_unlock_irqrestore(&chan->lock, flags);
+
+		if (chan->flags & ZT_FLAG_NOSTDTXRX && chan->span->hdlc_hard_xmit)
+			chan->span->hdlc_hard_xmit(chan);
+	}
+	return amnt;
+}
+
+static int zt_ctl_open(struct inode *inode, struct file *file)
+{
+	/* Nothing to do, really */
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#endif
+	return 0;
+}
+
+static int zt_chan_open(struct inode *inode, struct file *file)
+{
+	/* Nothing to do here for now either */
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#endif
+	return 0;
+}
+
+static int zt_ctl_release(struct inode *inode, struct file *file)
+{
+	/* Nothing to do */
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#endif
+	return 0;
+}
+
+static int zt_chan_release(struct inode *inode, struct file *file)
+{
+	/* Nothing to do for now */
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#endif
+	return 0;
+}
+
+static void set_txtone(struct zt_chan *ss,int fac, int init_v2, int init_v3)
+{
+	if (fac == 0)
+	{
+		ss->v2_1 = 0;
+		ss->v3_1 = 0;
+		return;
+	}
+	ss->txtone = fac;
+	ss->v1_1 = 0;
+	ss->v2_1 = init_v2;
+	ss->v3_1 = init_v3;
+	return;
+}
+
+static void zt_rbs_sethook(struct zt_chan *chan, int txsig, int txstate, int timeout)
+{
+static int outs[NUM_SIGS][5] = {
+/* We set the idle case of the ZT_SIG_NONE to this pattern to make idle E1 CAS
+channels happy. Should not matter with T1, since on an un-configured channel, 
+who cares what the sig bits are as long as they are stable */
+	{ ZT_SIG_NONE, 		ZT_ABIT | ZT_CBIT | ZT_DBIT, 0, 0, 0 },  /* no signalling */
+	{ ZT_SIG_EM, 		0, ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT,
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 0 },  /* E and M */
+	{ ZT_SIG_FXSLS, 	ZT_BBIT | ZT_DBIT, 
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT,
+			ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 0 }, /* FXS Loopstart */
+	{ ZT_SIG_FXSGS, 	ZT_BBIT | ZT_DBIT, 
+#ifdef CONFIG_CAC_GROUNDSTART
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 0, 0 }, /* FXS Groundstart (CAC-style) */
+#else
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, ZT_ABIT | ZT_CBIT, 0 }, /* FXS Groundstart (normal) */
+#endif
+	{ ZT_SIG_FXSKS,		ZT_BBIT | ZT_DBIT, 
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT,
+			ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 0 }, /* FXS Kewlstart */
+	{ ZT_SIG_FXOLS,		ZT_BBIT | ZT_DBIT, ZT_BBIT | ZT_DBIT, 0, 0 }, /* FXO Loopstart */
+	{ ZT_SIG_FXOGS,		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT,
+		 ZT_BBIT | ZT_DBIT, 0, 0 }, /* FXO Groundstart */
+	{ ZT_SIG_FXOKS,		ZT_BBIT | ZT_DBIT, ZT_BBIT | ZT_DBIT, 0, 
+		ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT }, /* FXO Kewlstart */
+	{ ZT_SIG_SF,	ZT_BBIT | ZT_CBIT | ZT_DBIT, 
+			ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 
+			ZT_ABIT | ZT_BBIT | ZT_CBIT | ZT_DBIT, 
+			ZT_BBIT | ZT_CBIT | ZT_DBIT },  /* no signalling */
+	{ ZT_SIG_EM_E1, 	ZT_DBIT, ZT_ABIT | ZT_BBIT | ZT_DBIT,
+		ZT_ABIT | ZT_BBIT | ZT_DBIT, ZT_DBIT },  /* E and M  E1 */
+	} ;
+	int x;
+
+	/* if no span, return doing nothing */
+	if (!chan->span) return;
+	if (!chan->span->flags & ZT_FLAG_RBS) {
+		printk("zt_rbs: Tried to set RBS hook state on non-RBS channel %s\n", chan->name);
+		return;
+	}
+	if ((txsig > 3) || (txsig < 0)) {
+		printk("zt_rbs: Tried to set RBS hook state %d (> 3) on  channel %s\n", txsig, chan->name);
+		return;
+	}
+	if (!chan->span->rbsbits && !chan->span->hooksig) {
+		printk("zt_rbs: Tried to set RBS hook state %d on channel %s while span %s lacks rbsbits or hooksig function\n",
+			txsig, chan->name, chan->span->name);
+		return;
+	}
+	/* Don't do anything for RBS */
+	if (chan->sig == ZT_SIG_DACS_RBS)
+		return;
+	chan->txstate = txstate;
+	
+	/* if tone signalling */
+	if (chan->sig == ZT_SIG_SF)
+	{
+		chan->txhooksig = txsig;
+		if (chan->txtone) /* if set to make tone for tx */
+		{
+			if ((txsig && !(chan->toneflags & ZT_REVERSE_TXTONE)) ||
+			 ((!txsig) && (chan->toneflags & ZT_REVERSE_TXTONE))) 
+			{
+				set_txtone(chan,chan->txtone,chan->tx_v2,chan->tx_v3);
+			}
+			else
+			{
+				set_txtone(chan,0,0,0);
+			}
+		}
+		chan->otimer = timeout * ZT_CHUNKSIZE;			/* Otimer is timer in samples */
+		return;
+	}
+	if (chan->span->hooksig) {
+		if (chan->txhooksig != txsig) {
+			chan->txhooksig = txsig;
+			chan->span->hooksig(chan, txsig);
+		}
+		chan->otimer = timeout * ZT_CHUNKSIZE;			/* Otimer is timer in samples */
+		return;
+	} else {
+		for (x=0;x<NUM_SIGS;x++) {
+			if (outs[x][0] == chan->sig) {
+#ifdef CONFIG_ZAPATA_DEBUG
+				printk("Setting bits to %d for channel %s state %d in %d signalling\n", outs[x][txsig + 1], chan->name, txsig, chan->sig);
+#endif
+				chan->txhooksig = txsig;
+				chan->txsig = outs[x][txsig+1];
+				chan->span->rbsbits(chan, chan->txsig);
+				chan->otimer = timeout * ZT_CHUNKSIZE;	/* Otimer is timer in samples */
+				return;
+			}
+		}
+	}
+	printk("zt_rbs: Don't know RBS signalling type %d on channel %s\n", chan->sig, chan->name);
+}
+
+static int zt_cas_setbits(struct zt_chan *chan, int bits)
+{
+	/* if no span, return as error */
+	if (!chan->span) return -1;
+	if (chan->span->rbsbits) {
+		chan->txsig = bits;
+		chan->span->rbsbits(chan, bits);
+	} else {
+		printk("Huh?  CAS setbits, but no RBS bits function\n");
+	}
+	return 0;
+}
+
+static int zt_hangup(struct zt_chan *chan)
+{
+	int x,res=0;
+
+	/* Can't hangup pseudo channels */
+	if (!chan->span)
+		return 0;
+	/* Can't hang up a clear channel */
+	if (chan->flags & (ZT_FLAG_CLEAR | ZT_FLAG_NOSTDTXRX))
+		return -EINVAL;
+
+	chan->kewlonhook = 0;
+
+
+	if ((chan->sig == ZT_SIG_FXSLS) || (chan->sig == ZT_SIG_FXSKS) ||
+		(chan->sig == ZT_SIG_FXSGS)) chan->ringdebtimer = RING_DEBOUNCE_TIME;
+
+	if (chan->span->flags & ZT_FLAG_RBS) {
+		if (chan->sig == ZT_SIG_CAS) {
+			zt_cas_setbits(chan, chan->idlebits);
+		} else if ((chan->sig == ZT_SIG_FXOKS) && (chan->txstate != ZT_TXSTATE_ONHOOK)
+			/* if other party is already on-hook we shouldn't do any battery drop */
+			&& !((chan->rxhooksig == ZT_RXSIG_ONHOOK) && (chan->itimer <= 0))) {
+			/* Do RBS signalling on the channel's behalf */
+			zt_rbs_sethook(chan, ZT_TXSIG_KEWL, ZT_TXSTATE_KEWL, ZT_KEWLTIME);
+		} else
+			zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_ONHOOK, 0);
+	} else {
+		/* Let the driver hang up the line if it wants to  */
+		if (chan->span->sethook) {
+			if (chan->txhooksig != ZT_ONHOOK) {
+				chan->txhooksig = ZT_ONHOOK;
+				res = chan->span->sethook(chan, ZT_ONHOOK);
+			} else
+				res = 0;
+		}
+	}
+	/* if not registered yet, just return here */
+	if (!(chan->flags & ZT_FLAG_REGISTERED)) return res;
+	/* Mark all buffers as empty */
+	for (x = 0;x < chan->numbufs;x++) {
+		chan->writen[x] = 
+		chan->writeidx[x]=
+		chan->readn[x]=
+		chan->readidx[x] = 0;
+	}	
+	if (chan->readbuf[0]) {
+		chan->inreadbuf = 0;
+		chan->inwritebuf = 0;
+	} else {
+		chan->inreadbuf = -1;
+		chan->inwritebuf = -1;
+	}
+	chan->outreadbuf = -1;
+	chan->outwritebuf = -1;
+	chan->dialing = 0;
+	chan->afterdialingtimer = 0;
+	chan->curtone = NULL;
+	chan->pdialcount = 0;
+	chan->cadencepos = 0;
+	chan->txdialbuf[0] = 0;
+	return res;
+}
+
+static int initialize_channel(struct zt_chan *chan)
+{
+	int res;
+	unsigned long flags;
+	void *rxgain=NULL;
+	struct echo_can_state *ec=NULL;
+	if ((res = zt_reallocbufs(chan, ZT_DEFAULT_BLOCKSIZE, ZT_DEFAULT_NUM_BUFS)))
+		return res;
+
+	spin_lock_irqsave(&chan->lock, flags);
+
+	chan->rxbufpolicy = ZT_POLICY_IMMEDIATE;
+	chan->txbufpolicy = ZT_POLICY_IMMEDIATE;
+
+	/* Free up the echo canceller if there is one */
+	ec = chan->ec;
+	chan->ec = NULL;
+	chan->echocancel = 0;
+	chan->echostate = ECHO_STATE_IDLE;
+	chan->echolastupdate = 0;
+	chan->echotimer = 0;
+
+	chan->txdisable = 0;
+	chan->rxdisable = 0;
+
+	chan->digitmode = DIGIT_MODE_DTMF;
+	chan->dialing = 0;
+	chan->afterdialingtimer = 0;
+
+	chan->cadencepos = 0;
+	chan->firstcadencepos = 0; /* By default loop back to first cadence position */
+
+	/* HDLC & FCS stuff */
+	fasthdlc_init(&chan->rxhdlc);
+	fasthdlc_init(&chan->txhdlc);
+	chan->infcs = PPP_INITFCS;
+	
+	/* Timings for RBS */
+	chan->prewinktime = ZT_DEFAULT_PREWINKTIME;
+	chan->preflashtime = ZT_DEFAULT_PREFLASHTIME;
+	chan->winktime = ZT_DEFAULT_WINKTIME;
+	chan->flashtime = ZT_DEFAULT_FLASHTIME;
+	
+	if (chan->sig & __ZT_SIG_FXO)
+		chan->starttime = ZT_DEFAULT_RINGTIME;
+	else
+		chan->starttime = ZT_DEFAULT_STARTTIME;
+	chan->rxwinktime = ZT_DEFAULT_RXWINKTIME;
+	chan->rxflashtime = ZT_DEFAULT_RXFLASHTIME;
+	chan->debouncetime = ZT_DEFAULT_DEBOUNCETIME;
+	chan->pulsemaketime = ZT_DEFAULT_PULSEMAKETIME;
+	chan->pulsebreaktime = ZT_DEFAULT_PULSEBREAKTIME;
+	chan->pulseaftertime = ZT_DEFAULT_PULSEAFTERTIME;
+	
+	/* Initialize RBS timers */
+	chan->itimerset = chan->itimer = chan->otimer = 0;
+	chan->ringdebtimer = 0;		
+
+	init_waitqueue_head(&chan->sel);
+	init_waitqueue_head(&chan->readbufq);
+	init_waitqueue_head(&chan->writebufq);
+	init_waitqueue_head(&chan->eventbufq);
+	init_waitqueue_head(&chan->txstateq);
+
+	/* Reset conferences */
+	reset_conf(chan);
+	
+	/* I/O Mask, etc */
+	chan->iomask = 0;
+	/* release conference resource if any */
+	if (chan->confna) zt_check_conf(chan->confna);
+	if ((chan->sig & __ZT_SIG_DACS) != __ZT_SIG_DACS) {
+		chan->confna = 0;
+		chan->confmode = 0;
+		if (chan->span && chan->span->dacs)
+			chan->span->dacs(chan, NULL);
+	}
+	chan->_confn = 0;
+	memset(chan->conflast, 0, sizeof(chan->conflast));
+	memset(chan->conflast1, 0, sizeof(chan->conflast1));
+	memset(chan->conflast2, 0, sizeof(chan->conflast2));
+	chan->confmute = 0;
+	chan->gotgs = 0;
+	chan->curtone = NULL;
+	chan->tonep = 0;
+	chan->pdialcount = 0;
+	if (chan->gainalloc && chan->rxgain)
+		rxgain = chan->rxgain;
+	chan->rxgain = defgain;
+	chan->txgain = defgain;
+	chan->gainalloc = 0;
+	chan->eventinidx = chan->eventoutidx = 0;
+	zt_set_law(chan,0);
+	zt_hangup(chan);
+
+	/* Make sure that the audio flag is cleared on a clear channel */
+	if ((chan->sig & ZT_SIG_CLEAR) || (chan->sig & ZT_SIG_HARDHDLC))
+		chan->flags &= ~ZT_FLAG_AUDIO;
+
+	if ((chan->sig == ZT_SIG_CLEAR) || (chan->sig == ZT_SIG_HARDHDLC))
+		chan->flags &= ~(ZT_FLAG_PPP | ZT_FLAG_FCS | ZT_FLAG_HDLC);
+
+	chan->flags &= ~ZT_FLAG_LINEAR;
+	if (chan->curzone) {
+		/* Take cadence from tone zone */
+		memcpy(chan->ringcadence, chan->curzone->ringcadence, sizeof(chan->ringcadence));
+	} else {
+		/* Do a default */
+		memset(chan->ringcadence, 0, sizeof(chan->ringcadence));
+		chan->ringcadence[0] = chan->starttime;
+		chan->ringcadence[1] = ZT_RINGOFFTIME;
+	}
+
+	spin_unlock_irqrestore(&chan->lock, flags);
+	set_tone_zone(chan, -1);
+
+	hw_echocancel_off(chan);
+
+	if (rxgain)
+		kfree(rxgain);
+	if (ec)
+		echo_can_free(ec);
+	return 0;
+}
+
+static int zt_timing_open(struct inode *inode, struct file *file)
+{
+	struct zt_timer *t;
+	unsigned long flags;
+	t = kmalloc(sizeof(struct zt_timer), GFP_KERNEL);
+	if (!t)
+		return -ENOMEM;
+	/* Allocate a new timer */
+	memset(t, 0, sizeof(struct zt_timer));
+	init_waitqueue_head(&t->sel);
+	file->private_data = t;
+#ifndef LINUX26
+	MOD_INC_USE_COUNT;
+#endif
+	spin_lock_irqsave(&zaptimerlock, flags);
+	t->next = zaptimers;
+	zaptimers = t;
+	spin_unlock_irqrestore(&zaptimerlock, flags);
+	return 0;
+}
+
+static int zt_timer_release(struct inode *inode, struct file *file)
+{
+	struct zt_timer *t, *cur, *prev;
+	unsigned long flags;
+	t = file->private_data;
+	if (t) {
+		spin_lock_irqsave(&zaptimerlock, flags);
+		prev = NULL;
+		cur = zaptimers;
+		while(cur) {
+			if (t == cur)
+				break;
+			prev = cur;
+			cur = cur->next;
+		}
+		if (cur) {
+			if (prev)
+				prev->next = cur->next;
+			else
+				zaptimers = cur->next;
+		}
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		if (!cur) {
+			printk("Zap Timer: Not on list??\n");
+			return 0;
+		}
+		kfree(t);
+#ifndef LINUX26
+		MOD_DEC_USE_COUNT;
+#endif		
+	}
+	return 0;
+}
+
+static int zt_specchan_open(struct inode *inode, struct file *file, int unit, int inc)
+{
+	int res = 0;
+
+	if (chans[unit] && chans[unit]->sig) {
+		/* Make sure we're not already open, a net device, or a slave device */
+		if (chans[unit]->flags & ZT_FLAG_NETDEV)
+			res = -EBUSY;
+		else if (chans[unit]->master != chans[unit])
+			res = -EBUSY;
+		else if ((chans[unit]->sig & __ZT_SIG_DACS) == __ZT_SIG_DACS)
+			res = -EBUSY;
+		else if (!test_and_set_bit(ZT_FLAGBIT_OPEN, &chans[unit]->flags)) {
+			unsigned long flags;
+			res = initialize_channel(chans[unit]);
+			if (res) {
+				/* Reallocbufs must have failed */
+				clear_bit(ZT_FLAGBIT_OPEN, &chans[unit]->flags);
+				return res;
+			}
+			spin_lock_irqsave(&chans[unit]->lock, flags);
+			if (chans[unit]->flags & ZT_FLAG_PSEUDO) 
+				chans[unit]->flags |= ZT_FLAG_AUDIO;
+			if (chans[unit]->span && chans[unit]->span->open) {
+				res = chans[unit]->span->open(chans[unit]);
+			}
+			if (!res) {
+				chans[unit]->file = file;
+#ifndef LINUX26
+				if (inc)
+					MOD_INC_USE_COUNT;
+#endif					
+				spin_unlock_irqrestore(&chans[unit]->lock, flags);
+			} else {
+				spin_unlock_irqrestore(&chans[unit]->lock, flags);
+				close_channel(chans[unit]);
+				clear_bit(ZT_FLAGBIT_OPEN, &chans[unit]->flags);
+			}
+		} else
+			res = -EBUSY;
+	} else
+		res = -ENXIO;
+	return res;
+}
+
+static int zt_specchan_release(struct inode *node, struct file *file, int unit)
+{
+	int res=0;
+	unsigned long flags;
+
+	if (chans[unit]) {
+		/* Chan lock protects contents against potentially non atomic accesses.
+		 * So if the pointer setting is not atomic, we should protect */
+		spin_lock_irqsave(&chans[unit]->lock, flags);
+		chans[unit]->file = NULL;
+		spin_unlock_irqrestore(&chans[unit]->lock, flags);
+		close_channel(chans[unit]);
+		if (chans[unit]->span && chans[unit]->span->close)
+			res = chans[unit]->span->close(chans[unit]);
+		clear_bit(ZT_FLAGBIT_OPEN, &chans[unit]->flags);
+	} else
+		res = -ENXIO;
+#ifndef LINUX26
+	MOD_DEC_USE_COUNT;
+#endif
+	return res;
+}
+
+static struct zt_chan *zt_alloc_pseudo(void)
+{
+	struct zt_chan *pseudo;
+	unsigned long flags;
+	/* Don't allow /dev/zap/pseudo to open if there are no spans */
+	if (maxspans < 1)
+		return NULL;
+	pseudo = kmalloc(sizeof(struct zt_chan), GFP_KERNEL);
+	if (!pseudo)
+		return NULL;
+	memset(pseudo, 0, sizeof(struct zt_chan));
+	pseudo->sig = ZT_SIG_CLEAR;
+	pseudo->sigcap = ZT_SIG_CLEAR;
+	pseudo->flags = ZT_FLAG_PSEUDO | ZT_FLAG_AUDIO;
+	spin_lock_irqsave(&bigzaplock, flags);
+	if (zt_chan_reg(pseudo)) {
+		kfree(pseudo);
+		pseudo = NULL;
+	} else
+		sprintf(pseudo->name, "Pseudo/%d", pseudo->channo);
+	spin_unlock_irqrestore(&bigzaplock, flags);
+	return pseudo;	
+}
+
+static void zt_free_pseudo(struct zt_chan *pseudo)
+{
+	unsigned long flags;
+	if (pseudo) {
+		spin_lock_irqsave(&bigzaplock, flags);
+		zt_chan_unreg(pseudo);
+		spin_unlock_irqrestore(&bigzaplock, flags);
+		kfree(pseudo);
+	}
+}
+
+static int zt_open(struct inode *inode, struct file *file)
+{
+	int unit = UNIT(file);
+	int ret = -ENXIO;
+	struct zt_chan *chan;
+	/* Minor 0: Special "control" descriptor */
+	if (!unit) 
+		return zt_ctl_open(inode, file);
+	if (unit == 250) {
+		if (!zt_transcode_fops)
+			request_module("zttranscode");
+		if (zt_transcode_fops && zt_transcode_fops->open) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (zt_transcode_fops->owner) {
+				__MOD_INC_USE_COUNT (zt_transcode_fops->owner);
+#else
+			if (try_module_get(zt_transcode_fops->owner)) {
+#endif
+				ret = zt_transcode_fops->open(inode, file);
+				if (ret)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+					__MOD_DEC_USE_COUNT (zt_transcode_fops->owner);
+#else
+					module_put(zt_transcode_fops->owner);
+#endif
+			}
+			return ret;
+		}
+		return -ENXIO;
+	}
+	if (unit == 253) {
+		if (maxspans) {
+			return zt_timing_open(inode, file);
+		} else {
+			return -ENXIO;
+		}
+	}
+	if (unit == 254)
+		return zt_chan_open(inode, file);
+	if (unit == 255) {
+		if (maxspans) {
+			chan = zt_alloc_pseudo();
+			if (chan) {
+				file->private_data = chan;
+				return zt_specchan_open(inode, file, chan->channo, 1);
+			} else {
+				return -ENXIO;
+			}
+		} else
+			return -ENXIO;
+	}
+	return zt_specchan_open(inode, file, unit, 1);
+}
+
+#if 0
+static int zt_open(struct inode *inode, struct file *file)
+{
+	int res;
+	unsigned long flags;
+	spin_lock_irqsave(&bigzaplock, flags);
+	res = __zt_open(inode, file);
+	spin_unlock_irqrestore(&bigzaplock, flags);
+	return res;
+}
+#endif
+
+static ssize_t zt_read(struct file *file, char *usrbuf, size_t count, loff_t *ppos)
+{
+	int unit = UNIT(file);
+	struct zt_chan *chan;
+
+	/* Can't read from control */
+	if (!unit) {
+		return -EINVAL;
+	}
+	
+	if (unit == 253) 
+		return -EINVAL;
+	
+	if (unit == 254) {
+		chan = file->private_data;
+		if (!chan)
+			return -EINVAL;
+		return zt_chan_read(file, usrbuf, count, chan->channo);
+	}
+	
+	if (unit == 255) {
+		chan = file->private_data;
+		if (!chan) {
+			printk("No pseudo channel structure to read?\n");
+			return -EINVAL;
+		}
+		return zt_chan_read(file, usrbuf, count, chan->channo);
+	}
+	if (count < 0)
+		return -EINVAL;
+
+	return zt_chan_read(file, usrbuf, count, unit);
+}
+
+static ssize_t zt_write(struct file *file, const char *usrbuf, size_t count, loff_t *ppos)
+{
+	int unit = UNIT(file);
+	struct zt_chan *chan;
+	/* Can't read from control */
+	if (!unit)
+		return -EINVAL;
+	if (count < 0)
+		return -EINVAL;
+	if (unit == 253)
+		return -EINVAL;
+	if (unit == 254) {
+		chan = file->private_data;
+		if (!chan)
+			return -EINVAL;
+		return zt_chan_write(file, usrbuf, count, chan->channo);
+	}
+	if (unit == 255) {
+		chan = file->private_data;
+		if (!chan) {
+			printk("No pseudo channel structure to read?\n");
+			return -EINVAL;
+		}
+		return zt_chan_write(file, usrbuf, count, chan->channo);
+	}
+	return zt_chan_write(file, usrbuf, count, unit);
+	
+}
+
+static int zt_set_default_zone(int defzone)
+{
+	if ((defzone < 0) || (defzone >= ZT_TONE_ZONE_MAX))
+		return -EINVAL;
+	write_lock(&zone_lock);
+	if (!tone_zones[defzone]) {
+		write_unlock(&zone_lock);
+		return -EINVAL;
+	}
+	if ((default_zone != -1) && tone_zones[default_zone])
+		atomic_dec(&tone_zones[default_zone]->refcount);
+	atomic_inc(&tone_zones[defzone]->refcount);
+	default_zone = defzone;
+	write_unlock(&zone_lock);
+	return 0;
+}
+
+/* No bigger than 32k for everything per tone zone */
+#define MAX_SIZE 32768
+/* No more than 128 subtones */
+#define MAX_TONES 128
+
+/* The tones to be loaded can (will) be a mix of regular tones,
+   DTMF tones and MF tones. We need to load DTMF and MF tones
+   a bit differently than regular tones because their storage
+   format is much simpler (an array structure field of the zone
+   structure, rather an array of pointers).
+*/
+static int ioctl_load_zone(unsigned long data)
+{
+	struct zt_tone *samples[MAX_TONES] = { NULL, };
+	short next[MAX_TONES] = { 0, };
+	struct zt_tone_def_header th;
+	struct zt_tone_def td;
+	struct zt_zone *z;
+	struct zt_tone *t;
+	void *slab, *ptr;
+	int x;
+	size_t space;
+	size_t size;
+	int res;
+	
+	if (copy_from_user(&th, (struct zt_tone_def_header *) data, sizeof(th)))
+		return -EFAULT;
+
+	data += sizeof(th);
+
+	if ((th.count < 0) || (th.count > MAX_TONES)) {
+		printk("Too many tones included\n");
+		return -EINVAL;
+	}
+
+	space = size = sizeof(*z) + th.count * sizeof(*t);
+
+	if (size > MAX_SIZE)
+		return -E2BIG;
+
+	if (!(z = ptr = slab = kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+
+	memset(slab, 0, size);
+
+	ptr += sizeof(*z);
+	space -= sizeof(*z);
+
+	zap_copy_string(z->name, th.name, sizeof(z->name));
+
+	for (x = 0; x < ZT_MAX_CADENCE; x++)
+		z->ringcadence[x] = th.ringcadence[x];
+
+	atomic_set(&z->refcount, 0);
+
+	for (x = 0; x < th.count; x++) {
+		enum {
+			REGULAR_TONE,
+			DTMF_TONE,
+			MFR1_TONE,
+			MFR2_FWD_TONE,
+			MFR2_REV_TONE,
+		} tone_type;
+
+		if (space < sizeof(*t)) {
+			kfree(slab);
+			printk("Insufficient tone zone space\n");
+			return -EINVAL;
+		}
+
+		if (copy_from_user(&td, (struct zt_tone_def *) data, sizeof(td))) {
+			kfree(slab);
+			return -EFAULT;
+		}
+
+		data += sizeof(td);
+
+		if ((td.tone >= 0) && (td.tone < ZT_TONE_MAX)) {
+			tone_type = REGULAR_TONE;
+
+			t = samples[x] = ptr;
+
+			space -= sizeof(*t);
+			ptr += sizeof(*t);
+
+			/* Remember which sample is next */
+			next[x] = td.next;
+			
+			/* Make sure the "next" one is sane */
+			if ((next[x] >= th.count) || (next[x] < 0)) {
+				printk("Invalid 'next' pointer: %d\n", next[x]);
+				kfree(slab);
+				return -EINVAL;
+			}
+		} else if ((td.tone >= ZT_TONE_DTMF_BASE) &&
+			   (td.tone <= ZT_TONE_DTMF_MAX)) {
+			tone_type = DTMF_TONE;
+			td.tone -= ZT_TONE_DTMF_BASE;
+			t = &z->dtmf[td.tone];
+		} else if ((td.tone >= ZT_TONE_MFR1_BASE) &&
+			   (td.tone <= ZT_TONE_MFR1_MAX)) {
+			tone_type = MFR1_TONE;
+			td.tone -= ZT_TONE_MFR1_BASE;
+			t = &z->mfr1[td.tone];
+		} else if ((td.tone >= ZT_TONE_MFR2_FWD_BASE) &&
+			   (td.tone <= ZT_TONE_MFR2_FWD_MAX)) {
+			tone_type = MFR2_FWD_TONE;
+			td.tone -= ZT_TONE_MFR2_FWD_BASE;
+			t = &z->mfr2_fwd[td.tone];
+		} else if ((td.tone >= ZT_TONE_MFR2_REV_BASE) &&
+			   (td.tone <= ZT_TONE_MFR2_REV_MAX)) {
+			tone_type = MFR2_REV_TONE;
+			td.tone -= ZT_TONE_MFR2_REV_BASE;
+			t = &z->mfr2_rev[td.tone];
+		} else {
+			printk("Invalid tone (%d) defined\n", td.tone);
+			kfree(slab);
+			return -EINVAL;
+		}
+
+		t->fac1 = td.fac1;
+		t->init_v2_1 = td.init_v2_1;
+		t->init_v3_1 = td.init_v3_1;
+		t->fac2 = td.fac2;
+		t->init_v2_2 = td.init_v2_2;
+		t->init_v3_2 = td.init_v3_2;
+		t->modulate = td.modulate;
+
+		switch (tone_type) {
+		case REGULAR_TONE:
+			t->tonesamples = td.samples;
+			if (!z->tones[td.tone])
+				z->tones[td.tone] = t;
+			break;
+		case DTMF_TONE:
+			t->tonesamples = global_dialparams.dtmf_tonelen;
+			t->next = &dtmf_silence;
+			z->dtmf_continuous[td.tone] = *t;
+			z->dtmf_continuous[td.tone].next = &z->dtmf_continuous[td.tone];
+			break;
+		case MFR1_TONE:
+			switch (td.tone + ZT_TONE_MFR1_BASE) {
+			case ZT_TONE_MFR1_KP:
+			case ZT_TONE_MFR1_ST:
+			case ZT_TONE_MFR1_STP:
+			case ZT_TONE_MFR1_ST2P:
+			case ZT_TONE_MFR1_ST3P:
+				/* signaling control tones are always 100ms */
+				t->tonesamples = 100 * ZT_CHUNKSIZE;
+				break;
+			default:
+				t->tonesamples = global_dialparams.mfv1_tonelen;
+				break;
+			}
+			t->next = &mfr1_silence;
+			break;
+		case MFR2_FWD_TONE:
+			t->tonesamples = global_dialparams.mfr2_tonelen;
+			t->next = &dtmf_silence;
+			z->mfr2_fwd_continuous[td.tone] = *t;
+			z->mfr2_fwd_continuous[td.tone].next = &z->mfr2_fwd_continuous[td.tone];
+			break;
+		case MFR2_REV_TONE:
+			t->tonesamples = global_dialparams.mfr2_tonelen;
+			t->next = &dtmf_silence;
+			z->mfr2_rev_continuous[td.tone] = *t;
+			z->mfr2_rev_continuous[td.tone].next = &z->mfr2_rev_continuous[td.tone];
+			break;
+		}
+	}
+
+	for (x = 0; x < th.count; x++) {
+		if (samples[x])
+			samples[x]->next = samples[next[x]];
+	}
+
+	if ((res = zt_register_tone_zone(th.zone, z))) {
+		kfree(slab);
+	} else {
+		if ( -1 == default_zone ) {
+			zt_set_default_zone(th.zone);
+		}
+	}
+
+	return res;
+}
+
+void zt_init_tone_state(struct zt_tone_state *ts, struct zt_tone *zt)
+{
+	ts->v1_1 = 0;
+	ts->v2_1 = zt->init_v2_1;
+	ts->v3_1 = zt->init_v3_1;
+	ts->v1_2 = 0;
+	ts->v2_2 = zt->init_v2_2;
+	ts->v3_2 = zt->init_v3_2;
+	ts->modulate = zt->modulate;
+}
+
+struct zt_tone *zt_mf_tone(const struct zt_chan *chan, char digit, int digitmode)
+{
+	unsigned int tone_index;
+
+	if (!chan->curzone) {
+		static int __warnonce = 1;
+		if (__warnonce) {
+			__warnonce = 0;
+			/* The tonezones are loaded by ztcfg based on /etc/zaptel.conf. */
+			printk(KERN_WARNING "zaptel: Cannot get dtmf tone until tone zone is loaded.\n");
+		}
+		return NULL;
+	}
+
+	switch (digitmode) {
+	case DIGIT_MODE_DTMF:
+		switch (digit) {
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			tone_index = ZT_TONE_DTMF_0 + (digit - '0');
+			break;
+		case '*':
+			tone_index = ZT_TONE_DTMF_s;
+			break;
+		case '#':
+			tone_index = ZT_TONE_DTMF_p;
+			break;
+		case 'A':
+		case 'B':
+		case 'C':
+		case 'D':
+			tone_index = ZT_TONE_DTMF_A + (digit - 'A');
+		case 'W':
+			return &tone_pause;
+		default:
+			return NULL;
+		}
+		return &chan->curzone->dtmf[tone_index - ZT_TONE_DTMF_BASE];
+	case DIGIT_MODE_MFR1:
+		switch (digit) {
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			tone_index = ZT_TONE_MFR1_0 + (digit - '0');
+			break;
+		case '*':
+			tone_index = ZT_TONE_MFR1_KP;
+			break;
+		case '#':
+			tone_index = ZT_TONE_MFR1_ST;
+			break;
+		case 'A':
+			tone_index = ZT_TONE_MFR1_STP;
+			break;
+		case 'B':
+			tone_index = ZT_TONE_MFR1_ST2P;
+			break;
+		case 'C':
+			tone_index = ZT_TONE_MFR1_ST3P;
+			break;
+		case 'W':
+			return &tone_pause;
+		default:
+			return NULL;
+		}
+		return &chan->curzone->mfr1[tone_index - ZT_TONE_MFR1_BASE];
+	case DIGIT_MODE_MFR2_FWD:
+		switch (digit) {
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			tone_index = ZT_TONE_MFR2_FWD_1 + (digit - '1');
+			break;
+		case 'A':
+		case 'B':
+		case 'C':
+		case 'D':
+		case 'E':
+		case 'F':
+			tone_index = ZT_TONE_MFR2_FWD_10 + (digit - 'A');
+			break;
+		case 'W':
+			return &tone_pause;
+		default:
+			return NULL;
+		}
+		return &chan->curzone->mfr2_fwd[tone_index - ZT_TONE_MFR2_FWD_BASE];
+	case DIGIT_MODE_MFR2_REV:
+		switch (digit) {
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			tone_index = ZT_TONE_MFR2_REV_1 + (digit - '1');
+			break;
+		case 'A':
+		case 'B':
+		case 'C':
+		case 'D':
+		case 'E':
+		case 'F':
+			tone_index = ZT_TONE_MFR2_REV_10 + (digit - 'A');
+			break;
+		case 'W':
+			return &tone_pause;
+		default:
+			return NULL;
+		}
+		return &chan->curzone->mfr2_rev[tone_index - ZT_TONE_MFR2_REV_BASE];
+	default:
+		return NULL;
+	}
+}
+
+static void __do_dtmf(struct zt_chan *chan)
+{
+	char c;
+
+	/* Called with chan->lock held */
+	while ((c = chan->txdialbuf[0])) {
+		memmove(chan->txdialbuf, chan->txdialbuf + 1, sizeof(chan->txdialbuf) - 1);
+		switch (c) {
+		case 'T':
+			chan->digitmode = DIGIT_MODE_DTMF;
+			chan->tonep = 0;
+			break;
+		case 'M':
+			chan->digitmode = DIGIT_MODE_MFR1;
+			chan->tonep = 0;
+			break;
+		case 'O':
+			chan->digitmode = DIGIT_MODE_MFR2_FWD;
+			chan->tonep = 0;
+			break;
+		case 'R':
+			chan->digitmode = DIGIT_MODE_MFR2_REV;
+			chan->tonep = 0;
+			break;
+		case 'P':
+			chan->digitmode = DIGIT_MODE_PULSE;
+			chan->tonep = 0;
+			break;
+		default:
+			if ((c != 'W') && (chan->digitmode == DIGIT_MODE_PULSE)) {
+				if ((c >= '0') && (c <= '9') && (chan->txhooksig == ZT_TXSIG_OFFHOOK)) {
+					chan->pdialcount = (c == '0') ? 10 : c - '0';
+					zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_PULSEBREAK,
+						       chan->pulsebreaktime);
+					return;
+				}
+			} else {
+				chan->curtone = zt_mf_tone(chan, c, chan->digitmode);
+				chan->tonep = 0;
+				if (chan->curtone) {
+					zt_init_tone_state(&chan->ts, chan->curtone);
+					return;
+				}
+			}
+		}
+	}
+
+	/* Notify userspace process if there is nothing left */
+	chan->dialing = 0;
+	__qevent(chan, ZT_EVENT_DIALCOMPLETE);
+}
+
+static int zt_release(struct inode *inode, struct file *file)
+{
+	int unit = UNIT(file);
+	int res;
+	struct zt_chan *chan;
+
+	if (!unit) 
+		return zt_ctl_release(inode, file);
+	if (unit == 253) {
+		return zt_timer_release(inode, file);
+	}
+	if (unit == 250) {
+		res = zt_transcode_fops->release(inode, file);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (zt_transcode_fops->owner)
+			__MOD_DEC_USE_COUNT (zt_transcode_fops->owner);
+#else
+		module_put(zt_transcode_fops->owner);
+#endif
+		return res;
+	}
+	if (unit == 254) {
+		chan = file->private_data;
+		if (!chan)
+			return zt_chan_release(inode, file);
+		else
+			return zt_specchan_release(inode, file, chan->channo);
+	}
+	if (unit == 255) {
+		chan = file->private_data;
+		if (chan) {
+			res = zt_specchan_release(inode, file, chan->channo);
+			zt_free_pseudo(chan);
+		} else {
+			printk("Pseudo release and no private data??\n");
+			res = 0;
+		}
+		return res;
+	}
+	return zt_specchan_release(inode, file, unit);
+}
+
+#if 0
+static int zt_release(struct inode *inode, struct file *file)
+{
+	/* Lock the big zap lock when handling a release */
+	unsigned long flags;
+	int res;
+	spin_lock_irqsave(&bigzaplock, flags);
+	res = __zt_release(inode, file);
+	spin_unlock_irqrestore(&bigzaplock, flags);
+	return res;
+}
+#endif
+
+
+void zt_alarm_channel(struct zt_chan *chan, int alarms)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->lock, flags);
+	if (chan->chan_alarms != alarms) {
+		chan->chan_alarms = alarms;
+		zt_qevent_nolock(chan, alarms ? ZT_EVENT_ALARM : ZT_EVENT_NOALARM);
+	}
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+void zt_alarm_notify(struct zt_span *span)
+{
+	int x;
+
+	span->alarms &= ~ZT_ALARM_LOOPBACK;
+	/* Determine maint status */
+	if (span->maintstat || span->mainttimer)
+		span->alarms |= ZT_ALARM_LOOPBACK;
+	/* DON'T CHANGE THIS AGAIN. THIS WAS DONE FOR A REASON.
+ 	   The expression (a != b) does *NOT* do the same thing
+	   as ((!a) != (!b)) */
+	/* if change in general state */
+	if ((!span->alarms) != (!span->lastalarms)) {
+		span->lastalarms = span->alarms;
+		for (x = 0; x < span->channels; x++)
+			zt_alarm_channel(&span->chans[x], span->alarms);
+		/* Switch to other master if current master in alarm */
+		for (x=1; x<maxspans; x++) {
+			if (spans[x] && !spans[x]->alarms && (spans[x]->flags & ZT_FLAG_RUNNING)) {
+				if(master != spans[x])
+					printk("Zaptel: Master changed to %s\n", spans[x]->name);
+				master = spans[x];
+				break;
+			}
+		}
+	}
+}
+
+#define VALID_SPAN(j) do { \
+	if ((j >= ZT_MAX_SPANS) || (j < 1)) \
+		return -EINVAL; \
+	if (!spans[j]) \
+		return -ENXIO; \
+} while(0)
+
+#define CHECK_VALID_SPAN(j) do { \
+	/* Start a given span */ \
+	if (get_user(j, (int *)data)) \
+		return -EFAULT; \
+	VALID_SPAN(j); \
+} while(0)
+
+#define VALID_CHANNEL(j) do { \
+	if ((j >= ZT_MAX_CHANNELS) || (j < 1)) \
+		return -EINVAL; \
+	if (!chans[j]) \
+		return -ENXIO; \
+} while(0)
+
+static int zt_timer_ioctl(struct inode *node, struct file *file, unsigned int cmd, unsigned long data, struct zt_timer *timer)
+{
+	int j;
+	unsigned long flags;
+	switch(cmd) {
+	case ZT_TIMERCONFIG:
+		get_user(j, (int *)data);
+		if (j < 0)
+			j = 0;
+		spin_lock_irqsave(&zaptimerlock, flags);
+		timer->ms = timer->pos = j;
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		break;
+	case ZT_TIMERACK:
+		get_user(j, (int *)data);
+		spin_lock_irqsave(&zaptimerlock, flags);
+		if ((j < 1) || (j > timer->tripped))
+			j = timer->tripped;
+		timer->tripped -= j;
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		break;
+	case ZT_GETEVENT:  /* Get event on queue */
+		j = ZT_EVENT_NONE;
+		spin_lock_irqsave(&zaptimerlock, flags);
+		  /* set up for no event */
+		if (timer->tripped)
+			j = ZT_EVENT_TIMER_EXPIRED;
+		if (timer->ping)
+			j = ZT_EVENT_TIMER_PING;
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		put_user(j,(int *)data);
+		break;
+	case ZT_TIMERPING:
+		spin_lock_irqsave(&zaptimerlock, flags);
+		timer->ping = 1;
+		wake_up_interruptible(&timer->sel);
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		break;
+	case ZT_TIMERPONG:
+		spin_lock_irqsave(&zaptimerlock, flags);
+		timer->ping = 0;
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
+static int zt_common_ioctl(struct inode *node, struct file *file, unsigned int cmd, unsigned long data, int unit)
+{
+	union {
+		struct zt_gains gain;
+		struct zt_spaninfo spaninfo;
+		struct zt_params param;
+	} stack;
+	struct zt_chan *chan;
+	unsigned long flags;
+	unsigned char *txgain, *rxgain;
+	struct zt_chan *mychan;
+	int i,j;
+	int return_master = 0;
+	size_t size_to_copy;
+
+	switch(cmd) {
+		/* get channel parameters */
+	case ZT_GET_PARAMS_V1:
+	case ZT_GET_PARAMS:
+		size_to_copy = (cmd == ZT_GET_PARAMS_V1) ? sizeof(struct zt_params_v1) :
+			       sizeof(struct zt_params);
+		if (copy_from_user(&stack.param, (struct zt_params *) data, size_to_copy))
+			return -EFAULT;
+
+		/* check to see if the caller wants to receive our master channel number */
+		if (stack.param.channo & ZT_GET_PARAMS_RETURN_MASTER) {
+			return_master = 1;
+			stack.param.channo &= ~ZT_GET_PARAMS_RETURN_MASTER;
+		}
+
+		/* Pick the right channo's */
+		if (!stack.param.channo || unit) {
+			stack.param.channo = unit;
+		}
+		/* Check validity of channel */
+		VALID_CHANNEL(stack.param.channo);
+		chan = chans[stack.param.channo];
+
+		/* point to relevant structure */
+		stack.param.sigtype = chan->sig;  /* get signalling type */
+		/* return non-zero if rx not in idle state */
+		if (chan->span) {
+			j = zt_q_sig(chan); 
+			if (j >= 0) { /* if returned with success */
+				stack.param.rxisoffhook = ((chan->rxsig & (j >> 8)) != (j & 0xff));
+			} else {
+				stack.param.rxisoffhook = ((chan->rxhooksig != ZT_RXSIG_ONHOOK) &&
+					(chan->rxhooksig != ZT_RXSIG_INITIAL));
+			}
+		} else if ((chan->txstate == ZT_TXSTATE_KEWL) || (chan->txstate == ZT_TXSTATE_AFTERKEWL))
+			stack.param.rxisoffhook = 1;
+		else
+			stack.param.rxisoffhook = 0;
+		if (chan->span && chan->span->rbsbits && !(chan->sig & ZT_SIG_CLEAR)) {
+			stack.param.rxbits = chan->rxsig;
+			stack.param.txbits = chan->txsig;
+			stack.param.idlebits = chan->idlebits;
+		} else {
+			stack.param.rxbits = -1;
+			stack.param.txbits = -1;
+			stack.param.idlebits = 0;
+		}
+		if (chan->span && (chan->span->rbsbits || chan->span->hooksig) && 
+			!(chan->sig & ZT_SIG_CLEAR)) {
+			stack.param.rxhooksig = chan->rxhooksig;
+			stack.param.txhooksig = chan->txhooksig;
+		} else {
+			stack.param.rxhooksig = -1;
+			stack.param.txhooksig = -1;
+		}
+		stack.param.prewinktime = chan->prewinktime; 
+		stack.param.preflashtime = chan->preflashtime;		
+		stack.param.winktime = chan->winktime;
+		stack.param.flashtime = chan->flashtime;
+		stack.param.starttime = chan->starttime;
+		stack.param.rxwinktime = chan->rxwinktime;
+		stack.param.rxflashtime = chan->rxflashtime;
+		stack.param.debouncetime = chan->debouncetime;
+		stack.param.channo = chan->channo;
+		stack.param.chan_alarms = chan->chan_alarms;
+
+		/* if requested, put the master channel number in the top 16 bits of the result */
+		if (return_master)
+			stack.param.channo |= chan->master->channo << 16;
+
+		stack.param.pulsemaketime = chan->pulsemaketime;
+		stack.param.pulsebreaktime = chan->pulsebreaktime;
+		stack.param.pulseaftertime = chan->pulseaftertime;
+		if (chan->span) stack.param.spanno = chan->span->spanno;
+			else stack.param.spanno = 0;
+		zap_copy_string(stack.param.name, chan->name, sizeof(stack.param.name));
+		stack.param.chanpos = chan->chanpos;
+		stack.param.sigcap = chan->sigcap;
+		/* Return current law */
+		if (chan->xlaw == __zt_alaw)
+			stack.param.curlaw = ZT_LAW_ALAW;
+		else
+			stack.param.curlaw = ZT_LAW_MULAW;
+
+		if (copy_to_user((struct zt_params *) data, &stack.param, size_to_copy))
+			return -EFAULT;
+
+		break;
+		/* set channel parameters */
+	case ZT_SET_PARAMS_V1:
+	case ZT_SET_PARAMS:
+		/* The difference between zt_params and zt_params_v1 is just the 
+		 * last field, which is read-only anyway. Thus we just read the
+		 * size of the older struct.
+		 */
+		if (copy_from_user(&stack.param, (struct zt_params *) data, sizeof(struct zt_params_v1)))
+			return -EFAULT;
+
+		stack.param.chan_alarms = 0; /* be explicit about the above */
+
+		/* Pick the right channo's */
+		if (!stack.param.channo || unit) {
+			stack.param.channo = unit;
+		}
+		/* Check validity of channel */
+		VALID_CHANNEL(stack.param.channo);
+		chan = chans[stack.param.channo];
+		  /* point to relevant structure */
+		/* NOTE: sigtype is *not* included in this */
+		  /* get timing stack.paramters */
+		chan->prewinktime = stack.param.prewinktime;
+		chan->preflashtime = stack.param.preflashtime;
+		chan->winktime = stack.param.winktime;
+		chan->flashtime = stack.param.flashtime;
+		chan->starttime = stack.param.starttime;
+		/* Update ringtime if not using a tone zone */
+		if (!chan->curzone)
+			chan->ringcadence[0] = chan->starttime;
+		chan->rxwinktime = stack.param.rxwinktime;
+		chan->rxflashtime = stack.param.rxflashtime;
+		chan->debouncetime = stack.param.debouncetime;
+		chan->pulsemaketime = stack.param.pulsemaketime;
+		chan->pulsebreaktime = stack.param.pulsebreaktime;
+		chan->pulseaftertime = stack.param.pulseaftertime;
+		break;
+	case ZT_GETGAINS:  /* get gain stuff */
+		if (copy_from_user(&stack.gain,(struct zt_gains *) data,sizeof(stack.gain)))
+			return -EFAULT;
+		i = stack.gain.chan;  /* get channel no */
+		   /* if zero, use current channel no */
+		if (!i) i = unit;
+		  /* make sure channel number makes sense */
+		if ((i < 0) || (i > ZT_MAX_CHANNELS) || !chans[i]) return(-EINVAL);
+		
+		if (!(chans[i]->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		stack.gain.chan = i; /* put the span # in here */
+		for (j=0;j<256;j++)  {
+			stack.gain.txgain[j] = chans[i]->txgain[j];
+			stack.gain.rxgain[j] = chans[i]->rxgain[j];
+		}
+		if (copy_to_user((struct zt_gains *) data,&stack.gain,sizeof(stack.gain)))
+			return -EFAULT;
+		break;
+	case ZT_SETGAINS:  /* set gain stuff */
+		if (copy_from_user(&stack.gain,(struct zt_gains *) data,sizeof(stack.gain)))
+			return -EFAULT;
+		i = stack.gain.chan;  /* get channel no */
+		   /* if zero, use current channel no */
+		if (!i) i = unit;
+		  /* make sure channel number makes sense */
+		if ((i < 0) || (i > ZT_MAX_CHANNELS) || !chans[i]) return(-EINVAL);
+		if (!(chans[i]->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+
+		rxgain = kmalloc(512, GFP_KERNEL);
+		if (!rxgain)
+			return -ENOMEM;
+
+		stack.gain.chan = i; /* put the span # in here */
+		txgain = rxgain + 256;
+
+		for (j=0;j<256;j++) {
+			rxgain[j] = stack.gain.rxgain[j];
+			txgain[j] = stack.gain.txgain[j];
+		}
+
+		if (!memcmp(rxgain, defgain, 256) && 
+		    !memcmp(txgain, defgain, 256)) {
+			if (rxgain)
+				kfree(rxgain);
+			spin_lock_irqsave(&chans[i]->lock, flags);
+			if (chans[i]->gainalloc)
+				kfree(chans[i]->rxgain);
+			chans[i]->gainalloc = 0;
+			chans[i]->rxgain = defgain;
+			chans[i]->txgain = defgain;
+			spin_unlock_irqrestore(&chans[i]->lock, flags);
+		} else {
+			/* This is a custom gain setting */
+			spin_lock_irqsave(&chans[i]->lock, flags);
+			if (chans[i]->gainalloc)
+				kfree(chans[i]->rxgain);
+			chans[i]->gainalloc = 1;
+			chans[i]->rxgain = rxgain;
+			chans[i]->txgain = txgain;
+			spin_unlock_irqrestore(&chans[i]->lock, flags);
+		}
+		if (copy_to_user((struct zt_gains *) data,&stack.gain,sizeof(stack.gain)))
+			return -EFAULT;
+		break;
+	case ZT_SPANSTAT_V1:
+	case ZT_SPANSTAT_V2:
+	case ZT_SPANSTAT:
+		size_to_copy = (cmd == ZT_SPANSTAT_V1) ? sizeof(struct zt_spaninfo_v1) :
+			       (cmd == ZT_SPANSTAT_V2) ? sizeof(struct zt_spaninfo_v2) :
+			       sizeof(struct zt_spaninfo);
+		if (copy_from_user(&stack.spaninfo, (struct zt_spaninfo *) data, size_to_copy))
+			return -EFAULT;
+		i = stack.spaninfo.spanno; /* get specified span number */
+		if ((i < 0) || (i >= maxspans)) return(-EINVAL);  /* if bad span no */
+		if (i == 0) {
+			/* if to figure it out for this chan */
+			if (!chans[unit])
+				return -EINVAL;
+			i = chans[unit]->span->spanno;
+		}
+		if (!spans[i])
+			return -EINVAL;
+		stack.spaninfo.spanno = i; /* put the span # in here */
+		stack.spaninfo.totalspans = 0;
+		if (maxspans) stack.spaninfo.totalspans = maxspans - 1; /* put total number of spans here */
+		zap_copy_string(stack.spaninfo.desc, spans[i]->desc, sizeof(stack.spaninfo.desc));
+		zap_copy_string(stack.spaninfo.name, spans[i]->name, sizeof(stack.spaninfo.name));
+		stack.spaninfo.alarms = spans[i]->alarms;		/* get alarm status */
+		stack.spaninfo.bpvcount = spans[i]->bpvcount;	/* get BPV count */
+		stack.spaninfo.rxlevel = spans[i]->rxlevel;	/* get rx level */
+		stack.spaninfo.txlevel = spans[i]->txlevel;	/* get tx level */
+		stack.spaninfo.crc4count = spans[i]->crc4count;	/* get CRC4 error count */
+		stack.spaninfo.ebitcount = spans[i]->ebitcount;	/* get E-bit error count */
+		stack.spaninfo.fascount = spans[i]->fascount;	/* get FAS error count */
+		stack.spaninfo.irqmisses = spans[i]->irqmisses;	/* get IRQ miss count */
+		stack.spaninfo.syncsrc = spans[i]->syncsrc;	/* get active sync source */
+		stack.spaninfo.totalchans = spans[i]->channels;
+		stack.spaninfo.numchans = 0;
+		for (j = 0; j < spans[i]->channels; j++) {
+			if (spans[i]->chans[j].sig)
+				stack.spaninfo.numchans++;
+		}
+		/* version 2 fields */
+		stack.spaninfo.lbo = spans[i]->lbo;
+		stack.spaninfo.lineconfig = spans[i]->lineconfig;
+		/* version 3 fields */
+		stack.spaninfo.irq = spans[i]->irq;
+		stack.spaninfo.linecompat = spans[i]->linecompat;
+		zap_copy_string(stack.spaninfo.lboname, zt_lboname(spans[i]->lbo), sizeof(stack.spaninfo.lboname));
+		if (spans[i]->manufacturer)
+			zap_copy_string(stack.spaninfo.manufacturer, spans[i]->manufacturer,
+				sizeof(stack.spaninfo.manufacturer));
+		if (spans[i]->devicetype)
+			zap_copy_string(stack.spaninfo.devicetype, spans[i]->devicetype, sizeof(stack.spaninfo.devicetype));
+		zap_copy_string(stack.spaninfo.location, spans[i]->location, sizeof(stack.spaninfo.location));
+		if (spans[i]->spantype)
+			zap_copy_string(stack.spaninfo.spantype, spans[i]->spantype, sizeof(stack.spaninfo.spantype));
+		
+		if (copy_to_user((struct zt_spaninfo *) data, &stack.spaninfo, size_to_copy))
+			return -EFAULT;
+		break;
+	case ZT_CHANDIAG:
+		get_user(j, (int *)data); /* get channel number from user */
+		/* make sure its a valid channel number */
+		if ((j < 1) || (j >= maxchans))
+			return -EINVAL;
+		/* if channel not mapped, not there */
+		if (!chans[j]) 
+			return -EINVAL;
+
+		if (!(mychan = kmalloc(sizeof(*mychan), GFP_KERNEL)))
+			return -ENOMEM;
+
+		/* lock channel */
+		spin_lock_irqsave(&chans[j]->lock, flags);
+		/* make static copy of channel */
+		memcpy(mychan, chans[j], sizeof(*mychan));
+		/* release it. */
+		spin_unlock_irqrestore(&chans[j]->lock, flags);
+
+		printk(KERN_INFO "Dump of Zaptel Channel %d (%s,%d,%d):\n\n",j,
+			mychan->name,mychan->channo,mychan->chanpos);
+		printk(KERN_INFO "flags: %x hex, writechunk: %08lx, readchunk: %08lx\n",
+			(unsigned int) mychan->flags, (long) mychan->writechunk, (long) mychan->readchunk);
+		printk(KERN_INFO "rxgain: %08lx, txgain: %08lx, gainalloc: %d\n",
+			(long) mychan->rxgain, (long)mychan->txgain, mychan->gainalloc);
+		printk(KERN_INFO "span: %08lx, sig: %x hex, sigcap: %x hex\n",
+			(long)mychan->span, mychan->sig, mychan->sigcap);
+		printk(KERN_INFO "inreadbuf: %d, outreadbuf: %d, inwritebuf: %d, outwritebuf: %d\n",
+			mychan->inreadbuf, mychan->outreadbuf, mychan->inwritebuf, mychan->outwritebuf);
+		printk(KERN_INFO "blocksize: %d, numbufs: %d, txbufpolicy: %d, txbufpolicy: %d\n",
+			mychan->blocksize, mychan->numbufs, mychan->txbufpolicy, mychan->rxbufpolicy);
+		printk(KERN_INFO "txdisable: %d, rxdisable: %d, iomask: %d\n",
+			mychan->txdisable, mychan->rxdisable, mychan->iomask);
+		printk(KERN_INFO "curzone: %08lx, tonezone: %d, curtone: %08lx, tonep: %d\n",
+			(long) mychan->curzone, mychan->tonezone, (long) mychan->curtone, mychan->tonep);
+		printk(KERN_INFO "digitmode: %d, txdialbuf: %s, dialing: %d, aftdialtimer: %d, cadpos. %d\n",
+			mychan->digitmode, mychan->txdialbuf, mychan->dialing,
+				mychan->afterdialingtimer, mychan->cadencepos);
+		printk(KERN_INFO "confna: %d, confn: %d, confmode: %d, confmute: %d\n",
+			mychan->confna, mychan->_confn, mychan->confmode, mychan->confmute);
+		printk(KERN_INFO "ec: %08lx, echocancel: %d, deflaw: %d, xlaw: %08lx\n",
+			(long) mychan->ec, mychan->echocancel, mychan->deflaw, (long) mychan->xlaw);
+		printk(KERN_INFO "echostate: %02x, echotimer: %d, echolastupdate: %d\n",
+			(int) mychan->echostate, mychan->echotimer, mychan->echolastupdate);
+		printk(KERN_INFO "itimer: %d, otimer: %d, ringdebtimer: %d\n\n",
+			mychan->itimer, mychan->otimer, mychan->ringdebtimer);
+#if 0
+		if (mychan->ec) {
+			int x;
+			/* Dump the echo canceller parameters */
+			for (x=0;x<mychan->ec->taps;x++) {
+				printk(KERN_INFO "tap %d: %d\n", x, mychan->ec->fir_taps[x]);
+			}
+		}
+#endif
+		kfree(mychan);
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
+static int (*zt_dynamic_ioctl)(unsigned int cmd, unsigned long data);
+
+void zt_set_dynamic_ioctl(int (*func)(unsigned int cmd, unsigned long data)) 
+{
+	zt_dynamic_ioctl = func;
+}
+
+static void recalc_slaves(struct zt_chan *chan)
+{
+	int x;
+	struct zt_chan *last = chan;
+
+	/* Makes no sense if you don't have a span */
+	if (!chan->span)
+		return;
+
+#ifdef CONFIG_ZAPATA_DEBUG
+	printk("Recalculating slaves on %s\n", chan->name);
+#endif
+
+	/* Link all slaves appropriately */
+	for (x=chan->chanpos;x<chan->span->channels;x++)
+		if (chan->span->chans[x].master == chan) {
+#ifdef CONFIG_ZAPATA_DEBUG
+			printk("Channel %s, slave to %s, last is %s, its next will be %d\n", 
+			       chan->span->chans[x].name, chan->name, last->name, x);
+#endif
+			last->nextslave = x;
+			last = &chan->span->chans[x];
+		}
+	/* Terminate list */
+	last->nextslave = 0;
+#ifdef CONFIG_ZAPATA_DEBUG
+	printk("Done Recalculating slaves on %s (last is %s)\n", chan->name, last->name);
+#endif
+}
+
+static int zt_ctl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data)
+{
+	/* I/O CTL's for control interface */
+	int i,j;
+	int sigcap;
+	int res = 0;
+	int x,y;
+	struct zt_chan *newmaster;
+	unsigned long flags;
+	int rv;
+	switch(cmd) {
+	case ZT_INDIRECT:
+	{
+		struct zt_indirect_data ind;
+
+		if (copy_from_user(&ind, (struct zt_indirect_data *)data, sizeof(ind)))
+			return -EFAULT;
+		VALID_CHANNEL(ind.chan);
+		return zt_chan_ioctl(inode, file, ind.op, (unsigned long) ind.data, ind.chan);
+	}
+	case ZT_SPANCONFIG:
+	{
+		struct zt_lineconfig lc;
+
+		if (copy_from_user(&lc, (struct zt_lineconfig *)data, sizeof(lc)))
+			return -EFAULT;
+		VALID_SPAN(lc.span);
+		if ((lc.lineconfig & 0x07f0 & spans[lc.span]->linecompat) != (lc.lineconfig & 0x07f0))
+			return -EINVAL;
+		if (spans[lc.span]->spanconfig) {
+			spans[lc.span]->lineconfig = lc.lineconfig;
+			spans[lc.span]->lbo = lc.lbo;
+			spans[lc.span]->txlevel = lc.lbo;
+			spans[lc.span]->rxlevel = 0;
+
+			return spans[lc.span]->spanconfig(spans[lc.span], &lc);
+		}
+		return 0;
+	}
+	case ZT_STARTUP:
+		CHECK_VALID_SPAN(j);
+		if (spans[j]->flags & ZT_FLAG_RUNNING)
+			return 0;
+		if (spans[j]->startup)
+			res = spans[j]->startup(spans[j]);
+		if (!res) {
+			/* Mark as running and hangup any channels */
+			spans[j]->flags |= ZT_FLAG_RUNNING;
+			for (x=0;x<spans[j]->channels;x++) {
+				y = zt_q_sig(&spans[j]->chans[x]) & 0xff;
+				if (y >= 0) spans[j]->chans[x].rxsig = (unsigned char)y;
+				spin_lock_irqsave(&spans[j]->chans[x].lock, flags);
+				zt_hangup(&spans[j]->chans[x]);
+				spin_unlock_irqrestore(&spans[j]->chans[x].lock, flags);
+				spans[j]->chans[x].rxhooksig = ZT_RXSIG_INITIAL;
+			}
+		}
+		return 0;
+	case ZT_SHUTDOWN:
+		CHECK_VALID_SPAN(j);
+		if (spans[j]->shutdown)
+			res =  spans[j]->shutdown(spans[j]);
+		spans[j]->flags &= ~ZT_FLAG_RUNNING;
+		return 0;
+	case ZT_CHANCONFIG:
+	{
+		struct zt_chanconfig ch;
+
+		if (copy_from_user(&ch, (struct zt_chanconfig *)data, sizeof(ch)))
+			return -EFAULT;
+		VALID_CHANNEL(ch.chan);
+		if (ch.sigtype == ZT_SIG_SLAVE) {
+			/* We have to use the master's sigtype */
+			if ((ch.master < 1) || (ch.master >= ZT_MAX_CHANNELS))
+				return -EINVAL;
+			if (!chans[ch.master])
+				return -EINVAL;
+			ch.sigtype = chans[ch.master]->sig;
+			newmaster = chans[ch.master];
+		} else if ((ch.sigtype & __ZT_SIG_DACS) == __ZT_SIG_DACS) {
+			newmaster = chans[ch.chan];
+			if ((ch.idlebits < 1) || (ch.idlebits >= ZT_MAX_CHANNELS))
+				return -EINVAL;
+			if (!chans[ch.idlebits])
+				return -EINVAL;
+		} else {
+			newmaster = chans[ch.chan];
+		}
+		spin_lock_irqsave(&chans[ch.chan]->lock, flags);
+#ifdef CONFIG_ZAPATA_NET
+		if (chans[ch.chan]->flags & ZT_FLAG_NETDEV) {
+			if (ztchan_to_dev(chans[ch.chan])->flags & IFF_UP) {
+				spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+				printk(KERN_WARNING "Can't switch HDLC net mode on channel %s, since current interface is up\n", chans[ch.chan]->name);
+				return -EBUSY;
+			}
+#ifdef LINUX26
+			spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+			unregister_hdlc_device(chans[ch.chan]->hdlcnetdev->netdev);
+			spin_lock_irqsave(&chans[ch.chan]->lock, flags);
+			free_netdev(chans[ch.chan]->hdlcnetdev->netdev);
+#else
+			unregister_hdlc_device(&chans[ch.chan]->hdlcnetdev->netdev);
+#endif				
+			kfree(chans[ch.chan]->hdlcnetdev);
+			chans[ch.chan]->hdlcnetdev = NULL;
+			chans[ch.chan]->flags &= ~ZT_FLAG_NETDEV;
+		}
+#else
+		if (ch.sigtype == ZT_SIG_HDLCNET) {
+				spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+				printk(KERN_WARNING "Zaptel networking not supported by this build.\n");
+				return -ENOSYS;
+		}
+#endif			
+		sigcap = chans[ch.chan]->sigcap;
+		/* If they support clear channel, then they support the HDLC and such through
+		   us.  */
+		if (sigcap & ZT_SIG_CLEAR) 
+			sigcap |= (ZT_SIG_HDLCRAW | ZT_SIG_HDLCFCS | ZT_SIG_HDLCNET | ZT_SIG_DACS);
+		
+		if ((sigcap & ch.sigtype) != ch.sigtype)
+			res =  -EINVAL;	
+		
+		if (!res && chans[ch.chan]->span->chanconfig)
+			res = chans[ch.chan]->span->chanconfig(chans[ch.chan], ch.sigtype);
+		if (chans[ch.chan]->master) {
+			/* Clear the master channel */
+			recalc_slaves(chans[ch.chan]->master);
+			chans[ch.chan]->nextslave = 0;
+		}
+		if (!res) {
+			chans[ch.chan]->sig = ch.sigtype;
+			if (chans[ch.chan]->sig == ZT_SIG_CAS)
+				chans[ch.chan]->idlebits = ch.idlebits;
+			else
+				chans[ch.chan]->idlebits = 0;
+			if ((ch.sigtype & ZT_SIG_CLEAR) == ZT_SIG_CLEAR) {
+				/* Set clear channel flag if appropriate */
+				chans[ch.chan]->flags &= ~ZT_FLAG_AUDIO;
+				chans[ch.chan]->flags |= ZT_FLAG_CLEAR;
+			} else {
+				/* Set audio flag and not clear channel otherwise */
+				chans[ch.chan]->flags |= ZT_FLAG_AUDIO;
+				chans[ch.chan]->flags &= ~ZT_FLAG_CLEAR;
+			}
+			if ((ch.sigtype & ZT_SIG_HDLCRAW) == ZT_SIG_HDLCRAW) {
+				/* Set the HDLC flag */
+				chans[ch.chan]->flags |= ZT_FLAG_HDLC;
+			} else {
+				/* Clear the HDLC flag */
+				chans[ch.chan]->flags &= ~ZT_FLAG_HDLC;
+			}
+			if ((ch.sigtype & ZT_SIG_HDLCFCS) == ZT_SIG_HDLCFCS) {
+				/* Set FCS to be calculated if appropriate */
+				chans[ch.chan]->flags |= ZT_FLAG_FCS;
+			} else {
+				/* Clear FCS flag */
+				chans[ch.chan]->flags &= ~ZT_FLAG_FCS;
+			}
+			if ((ch.sigtype & __ZT_SIG_DACS) == __ZT_SIG_DACS) {
+				/* Setup conference properly */
+				chans[ch.chan]->confmode = ZT_CONF_DIGITALMON;
+				chans[ch.chan]->confna = ch.idlebits;
+				if (chans[ch.chan]->span && 
+				    chans[ch.chan]->span->dacs && 
+					chans[ch.idlebits] && 
+					chans[ch.chan]->span && 
+					(chans[ch.chan]->span->dacs == chans[ch.idlebits]->span->dacs)) 
+					chans[ch.chan]->span->dacs(chans[ch.chan], chans[ch.idlebits]);
+			} else if (chans[ch.chan]->span && chans[ch.chan]->span->dacs)
+				chans[ch.chan]->span->dacs(chans[ch.chan], NULL);
+			chans[ch.chan]->master = newmaster;
+			/* Note new slave if we are not our own master */
+			if (newmaster != chans[ch.chan]) {
+				recalc_slaves(chans[ch.chan]->master);
+			}
+			if ((ch.sigtype & ZT_SIG_HARDHDLC) == ZT_SIG_HARDHDLC) {
+				chans[ch.chan]->flags &= ~ZT_FLAG_FCS;
+				chans[ch.chan]->flags &= ~ZT_FLAG_HDLC;
+				chans[ch.chan]->flags |= ZT_FLAG_NOSTDTXRX;
+			} else
+				chans[ch.chan]->flags &= ~ZT_FLAG_NOSTDTXRX;
+
+			if ((ch.sigtype & ZT_SIG_MTP2) == ZT_SIG_MTP2)
+				chans[ch.chan]->flags |= ZT_FLAG_MTP2;
+			else
+				chans[ch.chan]->flags &= ~ZT_FLAG_MTP2;
+		}
+#ifdef CONFIG_ZAPATA_NET
+		if (!res && 
+			(newmaster == chans[ch.chan]) && 
+		        (chans[ch.chan]->sig == ZT_SIG_HDLCNET)) {
+			chans[ch.chan]->hdlcnetdev = zt_hdlc_alloc();
+			if (chans[ch.chan]->hdlcnetdev) {
+/*				struct hdlc_device *hdlc = chans[ch.chan]->hdlcnetdev;
+				struct net_device *d = hdlc_to_dev(hdlc); mmm...get it right later --byg */
+#ifdef LINUX26
+				chans[ch.chan]->hdlcnetdev->netdev = alloc_hdlcdev(chans[ch.chan]->hdlcnetdev);
+				if (chans[ch.chan]->hdlcnetdev->netdev) {
+					chans[ch.chan]->hdlcnetdev->chan = chans[ch.chan];
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
+					SET_MODULE_OWNER(chans[ch.chan]->hdlcnetdev->netdev);
+#endif
+					chans[ch.chan]->hdlcnetdev->netdev->irq = chans[ch.chan]->span->irq;
+					chans[ch.chan]->hdlcnetdev->netdev->tx_queue_len = 50;
+					chans[ch.chan]->hdlcnetdev->netdev->do_ioctl = zt_net_ioctl;
+					chans[ch.chan]->hdlcnetdev->netdev->open = zt_net_open;
+					chans[ch.chan]->hdlcnetdev->netdev->stop = zt_net_stop;
+					dev_to_hdlc(chans[ch.chan]->hdlcnetdev->netdev)->attach = zt_net_attach;
+					dev_to_hdlc(chans[ch.chan]->hdlcnetdev->netdev)->xmit = zt_xmit;
+					spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+					/* Briefly restore interrupts while we register the device */
+					res = zt_register_hdlc_device(chans[ch.chan]->hdlcnetdev->netdev, ch.netdev_name);
+					spin_lock_irqsave(&chans[ch.chan]->lock, flags);
+				} else {
+					printk("Unable to allocate hdlc: *shrug*\n");
+					res = -1;
+				}
+#else /* LINUX26 */
+				chans[ch.chan]->hdlcnetdev->chan = chans[ch.chan];
+#ifndef HDLC_MAINTAINERS_ARE_MORE_STUPID_THAN_I_THOUGHT
+				chans[ch.chan]->hdlcnetdev->netdev.ioctl = zt_net_ioctl;
+#endif
+				chans[ch.chan]->hdlcnetdev->netdev.netdev.do_ioctl = zt_net_ioctl;
+#ifdef NEW_HDLC_INTERFACE
+				chans[ch.chan]->hdlcnetdev->netdev.netdev.open = zt_net_open;
+				chans[ch.chan]->hdlcnetdev->netdev.netdev.stop = zt_net_stop;
+				chans[ch.chan]->hdlcnetdev->netdev.xmit = zt_xmit;
+				chans[ch.chan]->hdlcnetdev->netdev.attach = zt_net_attach;
+#else
+				chans[ch.chan]->hdlcnetdev->netdev.open = zt_net_open;
+				chans[ch.chan]->hdlcnetdev->netdev.close = zt_net_close;
+				chans[ch.chan]->hdlcnetdev->netdev.set_mode = NULL;
+				chans[ch.chan]->hdlcnetdev->netdev.xmit = zt_xmit;
+#endif /* NEW_HDLC_INTERFACE */
+				chans[ch.chan]->hdlcnetdev->netdev.netdev.irq = chans[ch.chan]->span->irq;
+				chans[ch.chan]->hdlcnetdev->netdev.netdev.tx_queue_len = 50;
+				res = register_hdlc_device(&chans[ch.chan]->hdlcnetdev->netdev);
+#endif /* LINUX26 */
+				if (!res)
+					chans[ch.chan]->flags |= ZT_FLAG_NETDEV;
+			} else {
+				printk("Unable to allocate netdev: out of memory\n");
+				res = -1;
+			}
+		}
+#endif			
+		if ((chans[ch.chan]->sig == ZT_SIG_HDLCNET) && 
+		    (chans[ch.chan] == newmaster) &&
+		    !(chans[ch.chan]->flags & ZT_FLAG_NETDEV))
+			printk("Unable to register HDLC device for channel %s\n", chans[ch.chan]->name);
+		if (!res) {
+			/* Setup default law */
+			chans[ch.chan]->deflaw = ch.deflaw;
+			/* Copy back any modified settings */
+			spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+			if (copy_to_user((struct zt_chanconfig *)data, &ch, sizeof(ch)))
+				return -EFAULT;
+			spin_lock_irqsave(&chans[ch.chan]->lock, flags);
+			/* And hangup */
+			zt_hangup(chans[ch.chan]);
+			y = zt_q_sig(chans[ch.chan]) & 0xff;
+			if (y >= 0) chans[ch.chan]->rxsig = (unsigned char)y;
+			chans[ch.chan]->rxhooksig = ZT_RXSIG_INITIAL;
+		}
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("Configured channel %s, flags %04x, sig %04x\n", chans[ch.chan]->name, chans[ch.chan]->flags, chans[ch.chan]->sig);
+#endif			
+		spin_unlock_irqrestore(&chans[ch.chan]->lock, flags);
+		return res;
+	}
+	case ZT_SFCONFIG:
+	{
+		struct zt_sfconfig sf;
+
+		if (copy_from_user(&sf, (struct zt_chanconfig *)data, sizeof(sf)))
+			return -EFAULT;
+		VALID_CHANNEL(sf.chan);
+		if (chans[sf.chan]->sig != ZT_SIG_SF) return -EINVAL;
+		spin_lock_irqsave(&chans[sf.chan]->lock, flags);
+		chans[sf.chan]->rxp1 = sf.rxp1;
+		chans[sf.chan]->rxp2 = sf.rxp2;
+		chans[sf.chan]->rxp3 = sf.rxp3;
+		chans[sf.chan]->txtone = sf.txtone;
+		chans[sf.chan]->tx_v2 = sf.tx_v2;
+		chans[sf.chan]->tx_v3 = sf.tx_v3;
+		chans[sf.chan]->toneflags = sf.toneflag;
+		if (sf.txtone) /* if set to make tone for tx */
+		{
+			if ((chans[sf.chan]->txhooksig && !(sf.toneflag & ZT_REVERSE_TXTONE)) ||
+			 ((!chans[sf.chan]->txhooksig) && (sf.toneflag & ZT_REVERSE_TXTONE))) 
+			{
+				set_txtone(chans[sf.chan],sf.txtone,sf.tx_v2,sf.tx_v3);
+			}
+			else
+			{
+				set_txtone(chans[sf.chan],0,0,0);
+			}
+		}
+		spin_unlock_irqrestore(&chans[sf.chan]->lock, flags);
+		return res;
+	}
+	case ZT_DEFAULTZONE:
+		if (get_user(j,(int *)data))
+			return -EFAULT;
+		return zt_set_default_zone(j);
+	case ZT_LOADZONE:
+		return ioctl_load_zone(data);
+	case ZT_FREEZONE:
+		get_user(j, (int *) data);
+		return free_tone_zone(j);
+	case ZT_SET_DIALPARAMS:
+	{
+		struct zt_dialparams tdp;
+
+		if (copy_from_user(&tdp, (struct zt_dialparams *) data, sizeof(tdp)))
+			return -EFAULT;
+
+		if ((tdp.dtmf_tonelen <= 4000) || (tdp.dtmf_tonelen >= 10)) {
+			global_dialparams.dtmf_tonelen = tdp.dtmf_tonelen;
+		}
+		if ((tdp.mfv1_tonelen <= 4000) || (tdp.mfv1_tonelen >= 10)) {
+			global_dialparams.mfv1_tonelen = tdp.mfv1_tonelen;
+		}
+		if ((tdp.mfr2_tonelen <= 4000) || (tdp.mfr2_tonelen >= 10)) {
+			global_dialparams.mfr2_tonelen = tdp.mfr2_tonelen;
+		}
+
+		/* update the lengths in all currently loaded zones */
+		write_lock(&zone_lock);
+		for (j = 0; j < sizeof(tone_zones) / sizeof(tone_zones[0]); j++) {
+			struct zt_zone *z = tone_zones[j];
+
+			if (!z)
+				continue;
+
+			for (i = 0; i < sizeof(z->dtmf) / sizeof(z->dtmf[0]); i++) {
+				z->dtmf[i].tonesamples = global_dialparams.dtmf_tonelen * ZT_CHUNKSIZE;
+			}
+
+			/* for MFR1, we only adjust the length of the digits */
+			for (i = ZT_TONE_MFR1_0; i <= ZT_TONE_MFR1_9; i++) {
+				z->mfr1[i - ZT_TONE_MFR1_BASE].tonesamples = global_dialparams.mfv1_tonelen * ZT_CHUNKSIZE;
+			}
+
+			for (i = 0; i < sizeof(z->mfr2_fwd) / sizeof(z->mfr2_fwd[0]); i++) {
+				z->mfr2_fwd[i].tonesamples = global_dialparams.mfr2_tonelen * ZT_CHUNKSIZE;
+			}
+
+			for (i = 0; i < sizeof(z->mfr2_rev) / sizeof(z->mfr2_rev[0]); i++) {
+				z->mfr2_rev[i].tonesamples = global_dialparams.mfr2_tonelen * ZT_CHUNKSIZE;
+			}
+		}
+		write_unlock(&zone_lock);
+
+		dtmf_silence.tonesamples = global_dialparams.dtmf_tonelen * ZT_CHUNKSIZE;
+		mfr1_silence.tonesamples = global_dialparams.mfv1_tonelen * ZT_CHUNKSIZE;
+		mfr2_silence.tonesamples = global_dialparams.mfr2_tonelen * ZT_CHUNKSIZE;
+
+		break;
+	}
+	case ZT_GET_DIALPARAMS:
+	{
+		struct zt_dialparams tdp;
+
+		tdp = global_dialparams;
+		if (copy_to_user((struct zt_dialparams *) data, &tdp, sizeof(tdp)))
+			return -EFAULT;
+		break;
+	}
+	case ZT_GETVERSION:
+	{
+		struct zt_versioninfo vi;
+
+		memset(&vi, 0, sizeof(vi));
+		zap_copy_string(vi.version, ZAPTEL_VERSION, sizeof(vi.version));
+		echo_can_identify(vi.echo_canceller, sizeof(vi.echo_canceller) - 1);
+		if (copy_to_user((struct zt_versioninfo *) data, &vi, sizeof(vi)))
+			return -EFAULT;
+		break;
+	}
+	case ZT_MAINT:  /* do maintenance stuff */
+	{
+		struct zt_maintinfo maint;
+		  /* get struct from user */
+		if (copy_from_user(&maint,(struct zt_maintinfo *) data, sizeof(maint)))
+			return -EFAULT;
+		/* must be valid span number */
+		if ((maint.spanno < 1) || (maint.spanno > ZT_MAX_SPANS) || (!spans[maint.spanno]))
+			return -EINVAL;
+		if (!spans[maint.spanno]->maint)
+			return -ENOSYS;
+		spin_lock_irqsave(&spans[maint.spanno]->lock, flags);
+		  /* save current maint state */
+		i = spans[maint.spanno]->maintstat;
+		  /* set maint mode */
+		spans[maint.spanno]->maintstat = maint.command;
+		switch(maint.command) {
+		case ZT_MAINT_NONE:
+		case ZT_MAINT_LOCALLOOP:
+		case ZT_MAINT_REMOTELOOP:
+			/* if same, ignore it */
+			if (i == maint.command) break;
+			rv = spans[maint.spanno]->maint(spans[maint.spanno], maint.command);
+			spin_unlock_irqrestore(&spans[maint.spanno]->lock, flags);
+			if (rv) return rv;
+			spin_lock_irqsave(&spans[maint.spanno]->lock, flags);
+			break;
+		case ZT_MAINT_LOOPUP:
+		case ZT_MAINT_LOOPDOWN:
+			spans[maint.spanno]->mainttimer = ZT_LOOPCODE_TIME * ZT_CHUNKSIZE;
+			rv = spans[maint.spanno]->maint(spans[maint.spanno], maint.command);
+			spin_unlock_irqrestore(&spans[maint.spanno]->lock, flags);
+			if (rv) return rv;
+			rv = schluffen(&spans[maint.spanno]->maintq);
+			if (rv) return rv;
+			spin_lock_irqsave(&spans[maint.spanno]->lock, flags);
+			break;
+		default:
+			printk("zaptel: Unknown maintenance event: %d\n", maint.command);
+		}
+		zt_alarm_notify(spans[maint.spanno]);  /* process alarm-related events */
+		spin_unlock_irqrestore(&spans[maint.spanno]->lock, flags);
+		break;
+	}
+	case ZT_DYNAMIC_CREATE:
+	case ZT_DYNAMIC_DESTROY:
+		if (zt_dynamic_ioctl)
+			return zt_dynamic_ioctl(cmd, data);
+		else {
+			request_module("ztdynamic");
+			if (zt_dynamic_ioctl)
+				return zt_dynamic_ioctl(cmd, data);
+		}
+		return -ENOSYS;
+#if defined(ECHO_CAN_HPEC)
+	case ZT_EC_LICENSE_CHALLENGE:
+	case ZT_EC_LICENSE_RESPONSE:
+		return hpec_license_ioctl(cmd, data);
+#endif /* defined(ECHO_CAN_HPEC) */
+	default:
+		return zt_common_ioctl(inode, file, cmd, data, 0);
+	}
+	return 0;
+}
+
+static int ioctl_zt_dial(struct zt_chan *chan, unsigned long data)
+{
+	struct zt_dialoperation *tdo;
+	unsigned long flags;
+	char *s;
+	int rv;
+
+	tdo = kmalloc(sizeof(*tdo), GFP_KERNEL);
+
+	if (!tdo)
+		return -ENOMEM;
+
+	if (copy_from_user(tdo, (struct zt_dialoperation *)data, sizeof(*tdo)))
+		return -EFAULT;
+	rv = 0;
+	/* Force proper NULL termination and uppercase entry */
+	tdo->dialstr[ZT_MAX_DTMF_BUF - 1] = '\0';
+	for (s = tdo->dialstr; *s; s++)
+		*s = toupper(*s);
+	spin_lock_irqsave(&chan->lock, flags);
+	if (!chan->curzone) {
+		spin_unlock_irqrestore(&chan->lock, flags);
+		/* The tone zones are loaded by ztcfg from /etc/zaptel.conf */
+		printk(KERN_WARNING "zaptel: Cannot dial until a tone zone is loaded.\n");
+		return -ENODATA;
+	}
+	switch (tdo->op) {
+	case ZT_DIAL_OP_CANCEL:
+		chan->curtone = NULL;
+		chan->dialing = 0;
+		chan->txdialbuf[0] = '\0';
+		chan->tonep = 0;
+		chan->pdialcount = 0;
+		break;
+	case ZT_DIAL_OP_REPLACE:
+		strcpy(chan->txdialbuf, tdo->dialstr);
+		chan->dialing = 1;
+		__do_dtmf(chan);
+		break;
+	case ZT_DIAL_OP_APPEND:
+		if (strlen(tdo->dialstr) + strlen(chan->txdialbuf) >= (ZT_MAX_DTMF_BUF - 1)) {
+			rv = -EBUSY;
+			break;
+		}
+		zap_copy_string(chan->txdialbuf + strlen(chan->txdialbuf), tdo->dialstr, ZT_MAX_DTMF_BUF - strlen(chan->txdialbuf));
+		if (!chan->dialing) {
+			chan->dialing = 1;
+			__do_dtmf(chan);
+		}
+		break;
+	default:
+		rv = -EINVAL;
+	}
+	spin_unlock_irqrestore(&chan->lock, flags);
+	return rv;
+}
+
+static int zt_chanandpseudo_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data, int unit)
+{
+	struct zt_chan *chan = chans[unit];
+	union {
+		struct zt_bufferinfo bi;
+		struct zt_confinfo conf;
+		struct zt_ring_cadence cad;
+	} stack;
+	unsigned long flags, flagso;
+	int i, j, k, rv;
+	int ret, c;
+	
+	if (!chan)
+		return -EINVAL;
+	switch(cmd) {
+	case ZT_DIALING:
+		spin_lock_irqsave(&chan->lock, flags);
+		j = chan->dialing;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		if (copy_to_user((int *)data,&j,sizeof(int)))
+			return -EFAULT;
+		return 0;
+	case ZT_DIAL:
+		return ioctl_zt_dial(chan, data);
+	case ZT_GET_BUFINFO:
+		stack.bi.rxbufpolicy = chan->rxbufpolicy;
+		stack.bi.txbufpolicy = chan->txbufpolicy;
+		stack.bi.numbufs = chan->numbufs;
+		stack.bi.bufsize = chan->blocksize;
+		/* XXX FIXME! XXX */
+		stack.bi.readbufs = -1;
+		stack.bi.writebufs = -1;
+		if (copy_to_user((struct zt_bufferinfo *)data, &stack.bi, sizeof(stack.bi)))
+			return -EFAULT;
+		break;
+	case ZT_SET_BUFINFO:
+		if (copy_from_user(&stack.bi, (struct zt_bufferinfo *)data, sizeof(stack.bi)))
+			return -EFAULT;
+		if (stack.bi.bufsize > ZT_MAX_BLOCKSIZE)
+			return -EINVAL;
+		if (stack.bi.bufsize < 16)
+			return -EINVAL;
+		if (stack.bi.bufsize * stack.bi.numbufs > ZT_MAX_BUF_SPACE)
+			return -EINVAL;
+		chan->rxbufpolicy = stack.bi.rxbufpolicy & 0x1;
+		chan->txbufpolicy = stack.bi.txbufpolicy & 0x1;
+		if ((rv = zt_reallocbufs(chan,  stack.bi.bufsize, stack.bi.numbufs)))
+			return (rv);
+		break;
+	case ZT_GET_BLOCKSIZE:  /* get blocksize */
+		put_user(chan->blocksize,(int *)data); /* return block size */
+		break;
+	case ZT_SET_BLOCKSIZE:  /* set blocksize */
+		get_user(j,(int *)data);
+		  /* cannot be larger than max amount */
+		if (j > ZT_MAX_BLOCKSIZE) return(-EINVAL);
+		  /* cannot be less then 16 */
+		if (j < 16) return(-EINVAL);
+		  /* allocate a single kernel buffer which we then
+		     sub divide into four pieces */
+		if ((rv = zt_reallocbufs(chan, j, chan->numbufs)))
+			return (rv);
+		break;
+	case ZT_FLUSH:  /* flush input buffer, output buffer, and/or event queue */
+		get_user(i,(int *)data);  /* get param */
+		spin_lock_irqsave(&chan->lock, flags);
+		if (i & ZT_FLUSH_READ)  /* if for read (input) */
+		   {
+			  /* initialize read buffers and pointers */
+			chan->inreadbuf = 0;
+			chan->outreadbuf = -1;
+			for (j=0;j<chan->numbufs;j++) {
+				/* Do we need this? */
+				chan->readn[j] = 0;
+				chan->readidx[j] = 0;
+			}
+			wake_up_interruptible(&chan->readbufq);  /* wake_up_interruptible waiting on read */
+			wake_up_interruptible(&chan->sel); /* wake_up_interruptible waiting on select */
+		   }
+		if (i & ZT_FLUSH_WRITE) /* if for write (output) */
+		   {
+			  /* initialize write buffers and pointers */
+			chan->outwritebuf = -1;
+			chan->inwritebuf = 0;
+			for (j=0;j<chan->numbufs;j++) {
+				/* Do we need this? */
+				chan->writen[j] = 0;
+				chan->writeidx[j] = 0;
+			}
+			wake_up_interruptible(&chan->writebufq); /* wake_up_interruptible waiting on write */
+			wake_up_interruptible(&chan->sel);  /* wake_up_interruptible waiting on select */
+			   /* if IO MUX wait on write empty, well, this
+				certainly *did* empty the write */
+			if (chan->iomask & ZT_IOMUX_WRITEEMPTY)
+				wake_up_interruptible(&chan->eventbufq); /* wake_up_interruptible waiting on IOMUX */
+		   }
+		if (i & ZT_FLUSH_EVENT) /* if for events */
+		   {
+			   /* initialize the event pointers */
+			chan->eventinidx = chan->eventoutidx = 0;
+		   }
+		spin_unlock_irqrestore(&chan->lock, flags);
+		break;
+	case ZT_SYNC:  /* wait for no tx */
+		for(;;)  /* loop forever */
+		   {
+			spin_lock_irqsave(&chan->lock, flags);
+			  /* Know if there is a write pending */
+			i = (chan->outwritebuf > -1);
+			spin_unlock_irqrestore(&chan->lock, flags);
+			if (!i) break; /* skip if none */
+			rv = schluffen(&chan->writebufq);
+			if (rv) return(rv);
+		   }
+		break;
+	case ZT_IOMUX: /* wait for something to happen */
+		get_user(chan->iomask,(int*)data);  /* save mask */
+		if (!chan->iomask) return(-EINVAL);  /* cant wait for nothing */
+		for(;;)  /* loop forever */
+		   {
+			  /* has to have SOME mask */
+			ret = 0;  /* start with empty return value */
+			spin_lock_irqsave(&chan->lock, flags);
+			  /* if looking for read */
+			if (chan->iomask & ZT_IOMUX_READ)
+			   {
+				/* if read available */
+				if ((chan->outreadbuf > -1)  && !chan->rxdisable)
+					ret |= ZT_IOMUX_READ;
+			   }
+			  /* if looking for write avail */
+			if (chan->iomask & ZT_IOMUX_WRITE)
+			   {
+				if (chan->inwritebuf > -1)
+					ret |= ZT_IOMUX_WRITE;
+			   }
+			  /* if looking for write empty */
+			if (chan->iomask & ZT_IOMUX_WRITEEMPTY)
+			   {
+				  /* if everything empty -- be sure the transmitter is enabled */
+				chan->txdisable = 0;
+				if (chan->outwritebuf < 0)
+					ret |= ZT_IOMUX_WRITEEMPTY;
+			   }
+			  /* if looking for signalling event */
+			if (chan->iomask & ZT_IOMUX_SIGEVENT)
+			   {
+				  /* if event */
+				if (chan->eventinidx != chan->eventoutidx)
+					ret |= ZT_IOMUX_SIGEVENT;
+			   }
+			spin_unlock_irqrestore(&chan->lock, flags);
+			  /* if something to return, or not to wait */
+			if (ret || (chan->iomask & ZT_IOMUX_NOWAIT))
+			   {
+				  /* set return value */
+				put_user(ret,(int *)data);
+				break; /* get out of loop */
+			   }
+			rv = schluffen(&chan->eventbufq);
+			if (rv) return(rv);
+		   }
+		  /* clear IO MUX mask */
+		chan->iomask = 0;
+		break;
+	case ZT_GETEVENT:  /* Get event on queue */
+		  /* set up for no event */
+		j = ZT_EVENT_NONE;
+		spin_lock_irqsave(&chan->lock, flags);
+		  /* if some event in queue */
+		if (chan->eventinidx != chan->eventoutidx)
+		   {
+			j = chan->eventbuf[chan->eventoutidx++];
+			  /* get the data, bump index */
+			  /* if index overflow, set to beginning */
+			if (chan->eventoutidx >= ZT_MAX_EVENTSIZE)
+				chan->eventoutidx = 0;
+		   }		
+		spin_unlock_irqrestore(&chan->lock, flags);
+		put_user(j,(int *)data);
+		break;
+	case ZT_CONFMUTE:  /* set confmute flag */
+		get_user(j,(int *)data);  /* get conf # */
+		if (!(chan->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		spin_lock_irqsave(&bigzaplock, flags);
+		chan->confmute = j;
+		spin_unlock_irqrestore(&bigzaplock, flags);
+		break;
+	case ZT_GETCONFMUTE:  /* get confmute flag */
+		if (!(chan->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		j = chan->confmute;
+		put_user(j,(int *)data);  /* get conf # */
+		rv = 0;
+		break;
+	case ZT_SETTONEZONE:
+		get_user(j, (int *) data);
+		rv = set_tone_zone(chan, j);
+		return rv;
+	case ZT_GETTONEZONE:
+		spin_lock_irqsave(&chan->lock, flags);
+		if (chan->curzone)
+			j = chan->tonezone;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		put_user(j, (int *) data);
+		break;
+	case ZT_SENDTONE:
+		get_user(j,(int *)data);
+		spin_lock_irqsave(&chan->lock, flags);
+		rv = start_tone(chan, j);	
+		spin_unlock_irqrestore(&chan->lock, flags);
+		return rv;
+	case ZT_GETCONF:  /* get conf stuff */
+		if (copy_from_user(&stack.conf,(struct zt_confinfo *) data,sizeof(stack.conf)))
+			return -EFAULT;
+		i = stack.conf.chan;  /* get channel no */
+		   /* if zero, use current channel no */
+		if (!i) i = chan->channo;
+		  /* make sure channel number makes sense */
+		if ((i < 0) || (i > ZT_MAX_CONF) || (!chans[i])) return(-EINVAL);
+		if (!(chans[i]->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		stack.conf.chan = i;  /* get channel number */
+		stack.conf.confno = chans[i]->confna;  /* get conference number */
+		stack.conf.confmode = chans[i]->confmode; /* get conference mode */
+		if (copy_to_user((struct zt_confinfo *) data,&stack.conf,sizeof(stack.conf)))
+			return -EFAULT;
+		break;
+	case ZT_SETCONF:  /* set conf stuff */
+		if (copy_from_user(&stack.conf,(struct zt_confinfo *) data,sizeof(stack.conf)))
+			return -EFAULT;
+		i = stack.conf.chan;  /* get channel no */
+		   /* if zero, use current channel no */
+		if (!i) i = chan->channo;
+		  /* make sure channel number makes sense */
+		if ((i < 1) || (i > ZT_MAX_CHANNELS) || (!chans[i])) return(-EINVAL);
+		if (!(chans[i]->flags & ZT_FLAG_AUDIO)) return (-EINVAL); 
+		if ((stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORTX ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORBOTH ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_RX_PREECHO ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_TX_PREECHO ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORBOTH_PREECHO) {
+			/* Monitor mode -- it's a channel */
+			if ((stack.conf.confno < 0) || (stack.conf.confno >= ZT_MAX_CHANNELS) || !chans[stack.conf.confno]) return(-EINVAL);
+		} else {
+			  /* make sure conf number makes sense, too */
+			if ((stack.conf.confno < -1) || (stack.conf.confno > ZT_MAX_CONF)) return(-EINVAL);
+		}
+			
+		  /* if taking off of any conf, must have 0 mode */
+		if ((!stack.conf.confno) && stack.conf.confmode) return(-EINVAL);
+		  /* likewise if 0 mode must have no conf */
+		if ((!stack.conf.confmode) && stack.conf.confno) return (-EINVAL);
+		stack.conf.chan = i;  /* return with real channel # */
+		spin_lock_irqsave(&bigzaplock, flagso);
+		spin_lock_irqsave(&chan->lock, flags);
+		if (stack.conf.confno == -1) 
+			stack.conf.confno = zt_first_empty_conference();
+		if ((stack.conf.confno < 1) && (stack.conf.confmode)) {
+			/* No more empty conferences */
+			spin_unlock_irqrestore(&chan->lock, flags);
+			spin_unlock_irqrestore(&bigzaplock, flagso);
+			return -EBUSY;
+		}
+		  /* if changing confs, clear last added info */
+		if (stack.conf.confno != chans[i]->confna) {
+			memset(chans[i]->conflast, 0, ZT_MAX_CHUNKSIZE);
+			memset(chans[i]->conflast1, 0, ZT_MAX_CHUNKSIZE);
+			memset(chans[i]->conflast2, 0, ZT_MAX_CHUNKSIZE);
+		}
+		j = chans[i]->confna;  /* save old conference number */
+		chans[i]->confna = stack.conf.confno;   /* set conference number */
+		chans[i]->confmode = stack.conf.confmode;  /* set conference mode */
+		chans[i]->_confn = 0;		     /* Clear confn */
+		zt_check_conf(j);
+		zt_check_conf(stack.conf.confno);
+		if (chans[i]->span && chans[i]->span->dacs) {
+			if (((stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_DIGITALMON) &&
+			    chans[stack.conf.confno]->span &&
+			    chans[stack.conf.confno]->span->dacs == chans[i]->span->dacs &&
+			    chans[i]->txgain == defgain &&
+			    chans[i]->rxgain == defgain &&
+			    chans[stack.conf.confno]->txgain == defgain &&
+			    chans[stack.conf.confno]->rxgain == defgain) {
+				chans[i]->span->dacs(chans[i], chans[stack.conf.confno]);
+			} else {
+				chans[i]->span->dacs(chans[i], NULL);
+			}
+		}
+		/* if we are going onto a conf */
+		if (stack.conf.confno &&
+			((stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONF ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFANN ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFMON ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_CONFANNMON ||
+			(stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_REALANDPSEUDO)) {
+			/* Get alias */
+			chans[i]->_confn = zt_get_conf_alias(stack.conf.confno);
+		}
+
+		if (chans[stack.conf.confno]) {
+			if ((stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_RX_PREECHO ||
+			    (stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITOR_TX_PREECHO ||
+			    (stack.conf.confmode & ZT_CONF_MODE_MASK) == ZT_CONF_MONITORBOTH_PREECHO)
+				chans[stack.conf.confno]->readchunkpreec = kmalloc(sizeof(*chans[stack.conf.confno]->readchunkpreec) * ZT_CHUNKSIZE, GFP_ATOMIC);
+			else {
+				if (chans[stack.conf.confno]->readchunkpreec) {
+					kfree(chans[stack.conf.confno]->readchunkpreec);
+					chans[stack.conf.confno]->readchunkpreec = NULL;
+				}
+			}
+		}
+
+		spin_unlock_irqrestore(&chan->lock, flags);
+		spin_unlock_irqrestore(&bigzaplock, flagso);
+		if (copy_to_user((struct zt_confinfo *) data,&stack.conf,sizeof(stack.conf)))
+			return -EFAULT;
+		break;
+	case ZT_CONFLINK:  /* do conf link stuff */
+		if (!(chan->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		if (copy_from_user(&stack.conf,(struct zt_confinfo *) data,sizeof(stack.conf)))
+			return -EFAULT;
+		  /* check sanity of arguments */
+		if ((stack.conf.chan < 0) || (stack.conf.chan > ZT_MAX_CONF)) return(-EINVAL);
+		if ((stack.conf.confno < 0) || (stack.conf.confno > ZT_MAX_CONF)) return(-EINVAL);
+		  /* cant listen to self!! */
+		if (stack.conf.chan && (stack.conf.chan == stack.conf.confno)) return(-EINVAL);
+		spin_lock_irqsave(&bigzaplock, flagso);
+		spin_lock_irqsave(&chan->lock, flags);
+		  /* if to clear all links */
+		if ((!stack.conf.chan) && (!stack.conf.confno))
+		   {
+			   /* clear all the links */
+			memset(conf_links,0,sizeof(conf_links));
+			recalc_maxlinks();
+			spin_unlock_irqrestore(&chan->lock, flags);
+			spin_unlock_irqrestore(&bigzaplock, flagso);
+			break;
+		   }
+		rv = 0;  /* clear return value */
+		/* look for already existant specified combination */
+		for(i = 1; i <= ZT_MAX_CONF; i++)
+		   {
+			  /* if found, exit */
+			if ((conf_links[i].src == stack.conf.chan) &&
+				(conf_links[i].dst == stack.conf.confno)) break;
+		   }
+		if (i <= ZT_MAX_CONF) /* if found */
+		   {
+			if (!stack.conf.confmode) /* if to remove link */
+			   {
+				conf_links[i].src = conf_links[i].dst = 0;
+			   }
+			else /* if to add and already there, error */
+			   {
+				rv = -EEXIST;
+			   }
+		   }
+		else  /* if not found */
+		   {
+			if (stack.conf.confmode) /* if to add link */
+			   {
+				/* look for empty location */
+				for(i = 1; i <= ZT_MAX_CONF; i++)
+				   {
+					  /* if empty, exit loop */
+					if ((!conf_links[i].src) &&
+						 (!conf_links[i].dst)) break;
+				   }
+				   /* if empty spot found */
+				if (i <= ZT_MAX_CONF)
+				   {
+					conf_links[i].src = stack.conf.chan;
+					conf_links[i].dst = stack.conf.confno;
+				   }
+				else /* if no empties -- error */
+				   {
+					rv = -ENOSPC;
+				   }
+			   }
+			else /* if to remove, and not found -- error */
+			   {
+				rv = -ENOENT;
+			   }
+		   }
+		recalc_maxlinks();
+		spin_unlock_irqrestore(&chan->lock, flags);
+		spin_unlock_irqrestore(&bigzaplock, flagso);
+		return(rv);
+	case ZT_CONFDIAG:  /* output diagnostic info to console */
+		if (!(chan->flags & ZT_FLAG_AUDIO)) return (-EINVAL);
+		get_user(j,(int *)data);  /* get conf # */
+ 		  /* loop thru the interesting ones */
+		for(i = ((j) ? j : 1); i <= ((j) ? j : ZT_MAX_CONF); i++)
+		   {
+			c = 0;
+			for(k = 1; k < ZT_MAX_CHANNELS; k++)
+			   {
+				  /* skip if no pointer */
+				if (!chans[k]) continue;
+				  /* skip if not in this conf */
+				if (chans[k]->confna != i) continue;
+				if (!c) printk("Conf #%d:\n",i);
+				c = 1;
+				printk("chan %d, mode %x\n",
+					k,chans[k]->confmode);
+			   }
+			rv = 0;
+			for(k = 1; k <= ZT_MAX_CONF; k++)
+			   {
+				if (conf_links[k].dst == i)
+				   {
+					if (!c) printk("Conf #%d:\n",i);
+					c = 1;
+					if (!rv) printk("Snooping on:\n");
+					rv = 1;
+					printk("conf %d\n",conf_links[k].src);
+				   }
+			   }
+			if (c) printk("\n");
+		   }
+		break;
+	case ZT_CHANNO:  /* get channel number of stream */
+		put_user(unit,(int *)data); /* return unit/channel number */
+		break;
+	case ZT_SETLAW:
+		get_user(j, (int *)data);
+		if ((j < 0) || (j > ZT_LAW_ALAW))
+			return -EINVAL;
+		zt_set_law(chan, j);
+		break;
+	case ZT_SETLINEAR:
+		get_user(j, (int *)data);
+		/* Makes no sense on non-audio channels */
+		if (!(chan->flags & ZT_FLAG_AUDIO))
+			return -EINVAL;
+
+		if (j)
+			chan->flags |= ZT_FLAG_LINEAR;
+		else
+			chan->flags &= ~ZT_FLAG_LINEAR;
+		break;
+	case ZT_SETCADENCE:
+		if (data) {
+			/* Use specific ring cadence */
+			if (copy_from_user(&stack.cad, (struct zt_ring_cadence *)data, sizeof(stack.cad)))
+				return -EFAULT;
+			memcpy(chan->ringcadence, &stack.cad, sizeof(chan->ringcadence));
+			chan->firstcadencepos = 0;
+			/* Looking for negative ringing time indicating where to loop back into ringcadence */
+			for (i=0; i<ZT_MAX_CADENCE; i+=2 ) {
+				if (chan->ringcadence[i]<0) {
+					chan->ringcadence[i] *= -1;
+					chan->firstcadencepos = i;
+					break;
+				}
+			}
+		} else {
+			/* Reset to default */
+			chan->firstcadencepos = 0;
+			if (chan->curzone) {
+				memcpy(chan->ringcadence, chan->curzone->ringcadence, sizeof(chan->ringcadence));
+				/* Looking for negative ringing time indicating where to loop back into ringcadence */
+				for (i=0; i<ZT_MAX_CADENCE; i+=2 ) {
+					if (chan->ringcadence[i]<0) {
+						chan->ringcadence[i] *= -1;
+						chan->firstcadencepos = i;
+						break;
+					}
+				}
+			} else {
+				memset(chan->ringcadence, 0, sizeof(chan->ringcadence));
+				chan->ringcadence[0] = chan->starttime;
+				chan->ringcadence[1] = ZT_RINGOFFTIME;
+			}
+		}
+		break;
+	default:
+		/* Check for common ioctl's and private ones */
+		rv = zt_common_ioctl(inode, file, cmd, data, unit);
+		/* if no span, just return with value */
+		if (!chan->span) return rv;
+		if ((rv == -ENOTTY) && chan->span->ioctl) 
+			rv = chan->span->ioctl(chan, cmd, data);
+		return rv;
+		
+	}
+	return 0;
+}
+
+#ifdef CONFIG_ZAPATA_PPP
+/*
+ * This is called at softirq (BH) level when there are calls
+ * we need to make to the ppp_generic layer.  We do it this
+ * way because the ppp_generic layer functions may not be called
+ * at interrupt level.
+ */
+static void do_ppp_calls(unsigned long data)
+{
+	struct zt_chan *chan = (struct zt_chan *) data;
+	struct sk_buff *skb;
+
+	if (!chan->ppp)
+		return;
+	if (chan->do_ppp_wakeup) {
+		chan->do_ppp_wakeup = 0;
+		ppp_output_wakeup(chan->ppp);
+	}
+	while ((skb = skb_dequeue(&chan->ppp_rq)) != NULL)
+		ppp_input(chan->ppp, skb);
+	if (chan->do_ppp_error) {
+		chan->do_ppp_error = 0;
+		ppp_input_error(chan->ppp, 0);
+	}
+}
+#endif
+
+static int ioctl_echocancel(struct zt_chan *chan, struct zt_echocanparams *ecp, void *data)
+{
+	struct echo_can_state *ec = NULL, *tec;
+	struct zt_echocanparam *params;
+	int ret;
+	unsigned long flags;
+
+	if (ecp->param_count > ZT_MAX_ECHOCANPARAMS)
+		return -E2BIG;
+
+	if (ecp->tap_length == 0) {
+		/* disable mode, don't need to inspect params */
+		spin_lock_irqsave(&chan->lock, flags);
+		tec = chan->ec;
+		chan->ec = NULL;
+		chan->echocancel = 0;
+		chan->echostate = ECHO_STATE_IDLE;
+		chan->echolastupdate = 0;
+		chan->echotimer = 0;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		hw_echocancel_off(chan);
+		if (tec)
+			echo_can_free(tec);
+
+		return 0;
+	}
+
+	/* if parameters were supplied and this channel's span provides an echocan,
+	   but not one that takes params, then we must punt here and return an error */
+	if (ecp->param_count && chan->span && chan->span->echocan &&
+	    !chan->span->echocan_with_params)
+		return -EINVAL;
+	
+	params = kmalloc(sizeof(params[0]) * ZT_MAX_ECHOCANPARAMS, GFP_KERNEL);
+	
+	if (!params)
+		return -ENOMEM;
+
+	/* enable mode, need the params */
+	
+	if (copy_from_user(params, (struct zt_echocanparam *) data, sizeof(params[0]) * ecp->param_count)) {
+		ret = -EFAULT;
+		goto exit_with_free;
+	}
+	
+	spin_lock_irqsave(&chan->lock, flags);
+	tec = chan->ec;
+	chan->ec = NULL;
+	spin_unlock_irqrestore(&chan->lock, flags);
+	
+	if (tec)
+		echo_can_free(tec);
+
+	ret = -ENODEV;
+	
+	/* attempt to use the span's echo canceler; fall back to built-in
+	   if it fails (but not if an error occurs) */
+	if (chan->span) {
+		if (chan->span->echocan_with_params)
+			ret = chan->span->echocan_with_params(chan, ecp, params);
+		else if (chan->span->echocan)
+			ret = chan->span->echocan(chan, ecp->tap_length);
+	}
+	
+	if (ret == -ENODEV) {
+		switch (ecp->tap_length) {
+		case 32:
+		case 64:
+		case 128:
+		case 256:
+		case 512:
+		case 1024:
+			break;
+		default:
+			ecp->tap_length = deftaps;
+		}
+		
+		if ((ret = echo_can_create(ecp, params, &ec)))
+			goto exit_with_free;
+		
+		spin_lock_irqsave(&chan->lock, flags);
+		chan->echocancel = ecp->tap_length;
+		chan->ec = ec;
+		chan->echostate = ECHO_STATE_IDLE;
+		chan->echolastupdate = 0;
+		chan->echotimer = 0;
+		echo_can_disable_detector_init(&chan->txecdis);
+		echo_can_disable_detector_init(&chan->rxecdis);
+		spin_unlock_irqrestore(&chan->lock, flags);
+	}
+
+exit_with_free:
+	kfree(params);
+	return ret;
+}
+
+static int zt_chan_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data, int unit)
+{
+	struct zt_chan *chan = chans[unit];
+	unsigned long flags;
+	int j, rv;
+	int ret;
+	int oldconf;
+	void *rxgain=NULL;
+	struct echo_can_state *ec;
+
+	if (!chan)
+		return -ENOSYS;
+
+	switch(cmd) {
+	case ZT_SIGFREEZE:
+		get_user(j, (int *)data);
+		spin_lock_irqsave(&chan->lock, flags);
+		if (j) {
+			chan->flags |= ZT_FLAG_SIGFREEZE;
+		} else {
+			chan->flags &= ~ZT_FLAG_SIGFREEZE;
+		}
+		spin_unlock_irqrestore(&chan->lock, flags);
+		break;
+	case ZT_GETSIGFREEZE:
+		spin_lock_irqsave(&chan->lock, flags);
+		if (chan->flags & ZT_FLAG_SIGFREEZE)
+			j = 1;
+		else
+			j = 0;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		put_user(j, (int *)data);
+		break;
+	case ZT_AUDIOMODE:
+		/* Only literal clear channels can be put in  */
+		if (chan->sig != ZT_SIG_CLEAR) return (-EINVAL);
+		get_user(j, (int *)data);
+		if (j) {
+			spin_lock_irqsave(&chan->lock, flags);
+			chan->flags |= ZT_FLAG_AUDIO;
+			chan->flags &= ~(ZT_FLAG_HDLC | ZT_FLAG_FCS);
+			spin_unlock_irqrestore(&chan->lock, flags);
+		} else {
+			/* Coming out of audio mode, also clear all 
+			   conferencing and gain related info as well
+			   as echo canceller */
+			spin_lock_irqsave(&chan->lock, flags);
+			chan->flags &= ~ZT_FLAG_AUDIO;
+			/* save old conf number, if any */
+			oldconf = chan->confna;
+			  /* initialize conference variables */
+			chan->_confn = 0;
+			chan->confna = 0;
+			if (chan->span && chan->span->dacs)
+				chan->span->dacs(chan, NULL);
+			chan->confmode = 0;
+			chan->confmute = 0;
+			memset(chan->conflast, 0, sizeof(chan->conflast));
+			memset(chan->conflast1, 0, sizeof(chan->conflast1));
+			memset(chan->conflast2, 0, sizeof(chan->conflast2));
+			ec = chan->ec;
+			chan->ec = NULL;
+			/* release conference resource, if any to release */
+			reset_conf(chan);
+			if (chan->gainalloc && chan->rxgain)
+				rxgain = chan->rxgain;
+			else
+				rxgain = NULL;
+
+			chan->rxgain = defgain;
+			chan->txgain = defgain;
+			chan->gainalloc = 0;
+			/* Disable any native echo cancellation as well */
+			spin_unlock_irqrestore(&chan->lock, flags);
+
+			hw_echocancel_off(chan);
+
+			if (rxgain)
+				kfree(rxgain);
+			if (ec)
+				echo_can_free(ec);
+			if (oldconf) zt_check_conf(oldconf);
+		}
+		break;
+	case ZT_HDLCPPP:
+#ifdef CONFIG_ZAPATA_PPP
+		if (chan->sig != ZT_SIG_CLEAR) return (-EINVAL);
+		get_user(j, (int *)data);
+		if (j) {
+			if (!chan->ppp) {
+				chan->ppp = kmalloc(sizeof(struct ppp_channel), GFP_KERNEL);
+				if (chan->ppp) {
+					struct echo_can_state *tec;
+					memset(chan->ppp, 0, sizeof(struct ppp_channel));
+					chan->ppp->private = chan;
+					chan->ppp->ops = &ztppp_ops;
+					chan->ppp->mtu = ZT_DEFAULT_MTU_MRU;
+					chan->ppp->hdrlen = 0;
+					skb_queue_head_init(&chan->ppp_rq);
+					chan->do_ppp_wakeup = 0;
+					tasklet_init(&chan->ppp_calls, do_ppp_calls,
+						     (unsigned long)chan);
+					if ((ret = zt_reallocbufs(chan, ZT_DEFAULT_MTU_MRU, ZT_DEFAULT_NUM_BUFS))) {
+						kfree(chan->ppp);
+						chan->ppp = NULL;
+						return ret;
+					}
+						
+					if ((ret = ppp_register_channel(chan->ppp))) {
+						kfree(chan->ppp);
+						chan->ppp = NULL;
+						return ret;
+					}
+					tec = chan->ec;
+					chan->ec = NULL;
+					chan->echocancel = 0;
+					chan->echostate = ECHO_STATE_IDLE;
+					chan->echolastupdate = 0;
+					chan->echotimer = 0;
+					/* Make sure there's no gain */
+					if (chan->gainalloc)
+						kfree(chan->rxgain);
+					chan->rxgain = defgain;
+					chan->txgain = defgain;
+					chan->gainalloc = 0;
+					chan->flags &= ~ZT_FLAG_AUDIO;
+					chan->flags |= (ZT_FLAG_PPP | ZT_FLAG_HDLC | ZT_FLAG_FCS);
+					hw_echocancel_off(chan);
+					
+					if (tec)
+						echo_can_free(tec);
+				} else
+					return -ENOMEM;
+			}
+		} else {
+			chan->flags &= ~(ZT_FLAG_PPP | ZT_FLAG_HDLC | ZT_FLAG_FCS);
+			if (chan->ppp) {
+				struct ppp_channel *ppp = chan->ppp;
+				chan->ppp = NULL;
+				tasklet_kill(&chan->ppp_calls);
+				skb_queue_purge(&chan->ppp_rq);
+				ppp_unregister_channel(ppp);
+				kfree(ppp);
+			}
+		}
+#else
+		printk("Zaptel: Zaptel PPP support not compiled in\n");
+		return -ENOSYS;
+#endif
+		break;
+	case ZT_HDLCRAWMODE:
+		if (chan->sig != ZT_SIG_CLEAR)	return (-EINVAL);
+		get_user(j, (int *)data);
+		chan->flags &= ~(ZT_FLAG_AUDIO | ZT_FLAG_HDLC | ZT_FLAG_FCS);
+		if (j) {
+			chan->flags |= ZT_FLAG_HDLC;
+			fasthdlc_init(&chan->rxhdlc);
+			fasthdlc_init(&chan->txhdlc);
+		}
+		break;
+	case ZT_HDLCFCSMODE:
+		if (chan->sig != ZT_SIG_CLEAR)	return (-EINVAL);
+		get_user(j, (int *)data);
+		chan->flags &= ~(ZT_FLAG_AUDIO | ZT_FLAG_HDLC | ZT_FLAG_FCS);
+		if (j) {
+			chan->flags |= ZT_FLAG_HDLC | ZT_FLAG_FCS;
+			fasthdlc_init(&chan->rxhdlc);
+			fasthdlc_init(&chan->txhdlc);
+		}
+		break;
+	case ZT_ECHOCANCEL_PARAMS:
+	{
+		struct zt_echocanparams ecp;
+
+		if (!(chan->flags & ZT_FLAG_AUDIO))
+			return -EINVAL;
+		if (copy_from_user(&ecp, (struct zt_echocanparams *) data, sizeof(ecp)))
+			return -EFAULT;
+		data += sizeof(ecp);
+		if ((ret = ioctl_echocancel(chan, &ecp, (void *) data)))
+			return ret;
+		break;
+	}
+	case ZT_ECHOCANCEL:
+	{
+		struct zt_echocanparams ecp;
+
+		if (!(chan->flags & ZT_FLAG_AUDIO))
+			return -EINVAL;
+		get_user(j, (int *) data);
+		ecp.tap_length = j;
+		ecp.param_count = 0;
+		if ((ret = ioctl_echocancel(chan, &ecp, NULL)))
+			return ret;
+		break;
+	}
+	case ZT_ECHOTRAIN:
+		get_user(j, (int *)data); /* get pre-training time from user */
+		if ((j < 0) || (j >= ZT_MAX_PRETRAINING))
+			return -EINVAL;
+		j <<= 3;
+		if (chan->ec) {
+			/* Start pretraining stage */
+			chan->echostate = ECHO_STATE_PRETRAINING;
+			chan->echotimer = j;
+		} else
+			return -EINVAL;
+		break;
+	case ZT_SETTXBITS:
+		if (chan->sig != ZT_SIG_CAS)
+			return -EINVAL;
+		get_user(j,(int *)data);
+		zt_cas_setbits(chan, j);
+		rv = 0;
+		break;
+	case ZT_GETRXBITS:
+		put_user(chan->rxsig, (int *)data);
+		rv = 0;
+		break;
+	case ZT_LOOPBACK:
+		get_user(j, (int *)data);
+		spin_lock_irqsave(&chan->lock, flags);
+		if (j)
+			chan->flags |= ZT_FLAG_LOOPED;
+		else
+			chan->flags &= ~ZT_FLAG_LOOPED;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		rv = 0;
+		break;
+	case ZT_HOOK:
+		get_user(j,(int *)data);
+		if (chan->flags & ZT_FLAG_CLEAR)
+			return -EINVAL;
+		if (chan->sig == ZT_SIG_CAS) 
+			return -EINVAL;
+		/* if no span, just do nothing */
+		if (!chan->span) return(0);
+		spin_lock_irqsave(&chan->lock, flags);
+		/* if dialing, stop it */
+		chan->curtone = NULL;
+		chan->dialing = 0;
+		chan->txdialbuf[0] = '\0';
+		chan->tonep = 0;
+		chan->pdialcount = 0;
+		spin_unlock_irqrestore(&chan->lock, flags);
+		if (chan->span->flags & ZT_FLAG_RBS) {
+			switch (j) {
+			case ZT_ONHOOK:
+				spin_lock_irqsave(&chan->lock, flags);
+				zt_hangup(chan);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				break;
+			case ZT_OFFHOOK:
+				spin_lock_irqsave(&chan->lock, flags);
+				if ((chan->txstate == ZT_TXSTATE_KEWL) ||
+				  (chan->txstate == ZT_TXSTATE_AFTERKEWL)) {
+					spin_unlock_irqrestore(&chan->lock, flags);
+					return -EBUSY;
+				}
+				zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_DEBOUNCE, chan->debouncetime);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				break;
+			case ZT_RING:
+			case ZT_START:
+				spin_lock_irqsave(&chan->lock, flags);
+				if (!chan->curzone) {
+					spin_unlock_irqrestore(&chan->lock, flags);
+					printk(KERN_WARNING "zaptel: Cannot start tone until a tone zone is loaded.\n");
+					return -ENODATA;
+				}
+				if (chan->txstate != ZT_TXSTATE_ONHOOK) {
+					spin_unlock_irqrestore(&chan->lock, flags);
+					return -EBUSY;
+				}
+				if (chan->sig & __ZT_SIG_FXO) {
+					ret = 0;
+					chan->cadencepos = 0;
+					ret = chan->ringcadence[0];
+					zt_rbs_sethook(chan, ZT_TXSIG_START, ZT_TXSTATE_RINGON, ret);
+				} else
+					zt_rbs_sethook(chan, ZT_TXSIG_START, ZT_TXSTATE_START, chan->starttime);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				if (file->f_flags & O_NONBLOCK)
+					return -EINPROGRESS;
+#if 0
+				rv = schluffen(&chan->txstateq);
+				if (rv) return rv;
+#endif				
+				rv = 0;
+				break;
+			case ZT_WINK:
+				spin_lock_irqsave(&chan->lock, flags);
+				if (chan->txstate != ZT_TXSTATE_ONHOOK) {
+					spin_unlock_irqrestore(&chan->lock, flags);
+					return -EBUSY;
+				}
+				zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_PREWINK, chan->prewinktime);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				if (file->f_flags & O_NONBLOCK)
+					return -EINPROGRESS;
+				rv = schluffen(&chan->txstateq);
+				if (rv) return rv;
+				break;
+			case ZT_FLASH:
+				spin_lock_irqsave(&chan->lock, flags);
+				if (chan->txstate != ZT_TXSTATE_OFFHOOK) {
+					spin_unlock_irqrestore(&chan->lock, flags);
+					return -EBUSY;
+				}
+				zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_PREFLASH, chan->preflashtime);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				if (file->f_flags & O_NONBLOCK)
+					return -EINPROGRESS;
+				rv = schluffen(&chan->txstateq);
+				if (rv) return rv;
+				break;
+			case ZT_RINGOFF:
+				spin_lock_irqsave(&chan->lock, flags);
+				zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_ONHOOK, 0);
+				spin_unlock_irqrestore(&chan->lock, flags);
+				break;
+			default:
+				return -EINVAL;
+			}
+		} else if (chan->span->sethook) {
+			if (chan->txhooksig != j) {
+				chan->txhooksig = j;
+				chan->span->sethook(chan, j);
+			}
+		} else
+			return -ENOSYS;
+		break;
+#ifdef CONFIG_ZAPATA_PPP
+	case PPPIOCGCHAN:
+		if (chan->flags & ZT_FLAG_PPP)
+			return put_user(ppp_channel_index(chan->ppp), (int *)data) ? -EFAULT : 0;
+		else
+			return -EINVAL;
+		break;
+	case PPPIOCGUNIT:
+		if (chan->flags & ZT_FLAG_PPP)
+			return put_user(ppp_unit_number(chan->ppp), (int *)data) ? -EFAULT : 0;
+		else
+			return -EINVAL;
+		break;
+#endif
+	default:
+		return zt_chanandpseudo_ioctl(inode, file, cmd, data, unit);
+	}
+	return 0;
+}
+
+static int zt_prechan_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data, int unit)
+{
+	struct zt_chan *chan = file->private_data;
+	int channo;
+	int res;
+
+	if (chan) {
+		printk("Huh?  Prechan already has private data??\n");
+	}
+	switch(cmd) {
+	case ZT_SPECIFY:
+		get_user(channo,(int *)data);
+		if (channo < 1)
+			return -EINVAL;
+		if (channo > ZT_MAX_CHANNELS)
+			return -EINVAL;
+		res = zt_specchan_open(inode, file, channo, 0);
+		if (!res) {
+			/* Setup the pointer for future stuff */
+			chan = chans[channo];
+			file->private_data = chan;
+			/* Return success */
+			return 0;
+		}
+		return res;
+	default:
+		return -ENOSYS;
+	}
+	return 0;
+}
+
+static int zt_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long data)
+{
+	int unit = UNIT(file);
+	struct zt_chan *chan;
+	struct zt_timer *timer;
+
+	if (!unit)
+		return zt_ctl_ioctl(inode, file, cmd, data);
+
+	if (unit == 250)
+		return zt_transcode_fops->ioctl(inode, file, cmd, data);
+
+	if (unit == 253) {
+		timer = file->private_data;
+		if (timer)
+			return zt_timer_ioctl(inode, file, cmd, data, timer);
+		else
+			return -EINVAL;
+	}
+	if (unit == 254) {
+		chan = file->private_data;
+		if (chan)
+			return zt_chan_ioctl(inode, file, cmd, data, chan->channo);
+		else
+			return zt_prechan_ioctl(inode, file, cmd, data, unit);
+	}
+	if (unit == 255) {
+		chan = file->private_data;
+		if (!chan) {
+			printk("No pseudo channel structure to read?\n");
+			return -EINVAL;
+		}
+		return zt_chanandpseudo_ioctl(inode, file, cmd, data, chan->channo);
+	}
+	return zt_chan_ioctl(inode, file, cmd, data, unit);
+}
+
+int zt_register(struct zt_span *span, int prefmaster)
+{
+	int x;
+
+#ifdef CONFIG_PROC_FS
+	char tempfile[17];
+#endif
+	if (!span)
+		return -EINVAL;
+	if (span->flags & ZT_FLAG_REGISTERED) {
+		printk(KERN_ERR "Span %s already appears to be registered\n", span->name);
+		return -EBUSY;
+	}
+	for (x=1;x<maxspans;x++)
+		if (spans[x] == span) {
+			printk(KERN_ERR "Span %s already in list\n", span->name);
+			return -EBUSY;
+		}
+	for (x=1;x<ZT_MAX_SPANS;x++)
+		if (!spans[x])
+			break;
+	if (x < ZT_MAX_SPANS) {
+		spans[x] = span;
+		if (maxspans < x + 1)
+			maxspans = x + 1;
+	} else {
+		printk(KERN_ERR "Too many zapata spans registered\n");
+		return -EBUSY;
+	}
+	span->flags |= ZT_FLAG_REGISTERED;
+	span->spanno = x;
+	spin_lock_init(&span->lock);
+	if (!span->deflaw) {
+		printk("zaptel: Span %s didn't specify default law.  Assuming mulaw, please fix driver!\n", span->name);
+		span->deflaw = ZT_LAW_MULAW;
+	}
+
+	if (span->echocan && span->echocan_with_params) {
+		printk("zaptel: Span %s implements both echocan and echocan_with_params functions, preserving only echocan_with_params, please fix driver!\n", span->name);
+		span->echocan = NULL;
+	}
+
+	for (x=0;x<span->channels;x++) {
+		span->chans[x].span = span;
+		zt_chan_reg(&span->chans[x]); 
+	}
+
+#ifdef CONFIG_PROC_FS
+			sprintf(tempfile, "zaptel/%d", span->spanno);
+			proc_entries[span->spanno] = create_proc_read_entry(tempfile, 0444, NULL , zaptel_proc_read, (int *)(long)span->spanno);
+#endif
+
+#ifdef CONFIG_DEVFS_FS
+	{
+		char span_name[50];
+		sprintf(span_name, "span%d", span->spanno);
+		span->dhandle = devfs_mk_dir(zaptel_devfs_dir, span_name, NULL);
+		for (x = 0; x < span->channels; x++) {
+			struct zt_chan *chan = &span->chans[x];
+			chan->fhandle = register_devfs_channel(chan, chan->span->dhandle); /* Register our stuff with devfs */
+		}
+	}
+#endif /* CONFIG_DEVFS_FS */
+
+#ifdef CONFIG_ZAP_UDEV
+	for (x = 0; x < span->channels; x++) {
+		char chan_name[50];
+		if (span->chans[x].channo < 250) {
+			sprintf(chan_name, "zap%d", span->chans[x].channo);
+			CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, span->chans[x].channo), NULL, chan_name);
+		}
+	}
+#endif /* CONFIG_ZAP_UDEV */
+
+	if (debug)
+		printk("Registered Span %d ('%s') with %d channels\n", span->spanno, span->name, span->channels);
+	if (!master || prefmaster) {
+		master = span;
+		if (debug)
+			printk("Span ('%s') is new master\n", span->name);
+	}
+	return 0;
+}
+
+int zt_unregister(struct zt_span *span)
+{
+	int x;
+	int new_maxspans;
+	static struct zt_span *new_master;
+
+#ifdef CONFIG_PROC_FS
+	char tempfile[17];
+#endif /* CONFIG_PROC_FS */
+
+	if (!(span->flags & ZT_FLAG_REGISTERED)) {
+		printk(KERN_ERR "Span %s does not appear to be registered\n", span->name);
+		return -1;
+	}
+	/* Shutdown the span if it's running */
+	if (span->flags & ZT_FLAG_RUNNING)
+		if (span->shutdown)
+			span->shutdown(span);
+			
+	if (spans[span->spanno] != span) {
+		printk(KERN_ERR "Span %s has spanno %d which is something else\n", span->name, span->spanno);
+		return -1;
+	}
+	if (debug)
+		printk("Unregistering Span '%s' with %d channels\n", span->name, span->channels);
+#ifdef CONFIG_PROC_FS
+	sprintf(tempfile, "zaptel/%d", span->spanno);
+        remove_proc_entry(tempfile, NULL);
+#endif /* CONFIG_PROC_FS */
+#ifdef CONFIG_DEVFS_FS
+	for (x = 0; x < span->channels; x++) {
+		devfs_unregister(span->chans[x].fhandle);
+		devfs_unregister(span->chans[x].fhandle_symlink);
+	}
+	devfs_unregister(span->dhandle);
+#endif /* CONFIG_DEVFS_FS */
+
+#ifdef CONFIG_ZAP_UDEV
+	for (x = 0; x < span->channels; x++) {
+		if (span->chans[x].channo < 250)
+			class_device_destroy(zap_class, MKDEV(ZT_MAJOR, span->chans[x].channo));
+	}
+#endif /* CONFIG_ZAP_UDEV */
+
+	spans[span->spanno] = NULL;
+	span->spanno = 0;
+	span->flags &= ~ZT_FLAG_REGISTERED;
+	for (x=0;x<span->channels;x++)
+		zt_chan_unreg(&span->chans[x]);
+	new_maxspans = 0;
+	new_master = master; /* FIXME: locking */
+	if (master == span)
+		new_master = NULL;
+	for (x=1;x<ZT_MAX_SPANS;x++) {
+		if (spans[x]) {
+			new_maxspans = x+1;
+			if (!new_master)
+				new_master = spans[x];
+		}
+	}
+	maxspans = new_maxspans;
+	if (master != new_master)
+		if (debug)
+			printk("%s: Span ('%s') is new master\n", __FUNCTION__, 
+				(new_master)? new_master->name: "no master");
+	master = new_master;
+
+	return 0;
+}
+
+/*
+** This routine converts from linear to ulaw
+**
+** Craig Reese: IDA/Supercomputing Research Center
+** Joe Campbell: Department of Defense
+** 29 September 1989
+**
+** References:
+** 1) CCITT Recommendation G.711  (very difficult to follow)
+** 2) "A New Digital Technique for Implementation of Any
+**     Continuous PCM Companding Law," Villeret, Michel,
+**     et al. 1973 IEEE Int. Conf. on Communications, Vol 1,
+**     1973, pg. 11.12-11.17
+** 3) MIL-STD-188-113,"Interoperability and Performance Standards
+**     for Analog-to_Digital Conversion Techniques,"
+**     17 February 1987
+**
+** Input: Signed 16 bit linear sample
+** Output: 8 bit ulaw sample
+*/
+
+#define ZEROTRAP    /* turn on the trap as per the MIL-STD */
+#define BIAS 0x84   /* define the add-in bias for 16 bit samples */
+#define CLIP 32635
+
+#ifdef CONFIG_CALC_XLAW
+unsigned char
+#else
+static unsigned char  __init
+#endif
+__zt_lineartoulaw(short sample)
+{
+  static int exp_lut[256] = {0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
+                             4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+                             5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+                             5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7};
+  int sign, exponent, mantissa;
+  unsigned char ulawbyte;
+
+  /* Get the sample into sign-magnitude. */
+  sign = (sample >> 8) & 0x80;          /* set aside the sign */
+  if (sign != 0) sample = -sample;              /* get magnitude */
+  if (sample > CLIP) sample = CLIP;             /* clip the magnitude */
+
+  /* Convert from 16 bit linear to ulaw. */
+  sample = sample + BIAS;
+  exponent = exp_lut[(sample >> 7) & 0xFF];
+  mantissa = (sample >> (exponent + 3)) & 0x0F;
+  ulawbyte = ~(sign | (exponent << 4) | mantissa);
+#ifdef ZEROTRAP
+  if (ulawbyte == 0) ulawbyte = 0x02;   /* optional CCITT trap */
+#endif
+  if (ulawbyte == 0xff) ulawbyte = 0x7f;   /* never return 0xff */
+  return(ulawbyte);
+}
+
+#define AMI_MASK 0x55
+
+#ifdef CONFIG_CALC_XLAW
+unsigned char
+#else
+static inline unsigned char __init
+#endif
+__zt_lineartoalaw (short linear)
+{
+    int mask;
+    int seg;
+    int pcm_val;
+    static int seg_end[8] =
+    {
+         0xFF, 0x1FF, 0x3FF, 0x7FF, 0xFFF, 0x1FFF, 0x3FFF, 0x7FFF
+    };
+    
+    pcm_val = linear;
+    if (pcm_val >= 0)
+    {
+        /* Sign (7th) bit = 1 */
+        mask = AMI_MASK | 0x80;
+    }
+    else
+    {
+        /* Sign bit = 0 */
+        mask = AMI_MASK;
+        pcm_val = -pcm_val;
+    }
+
+    /* Convert the scaled magnitude to segment number. */
+    for (seg = 0;  seg < 8;  seg++)
+    {
+        if (pcm_val <= seg_end[seg])
+	    break;
+    }
+    /* Combine the sign, segment, and quantization bits. */
+    return  ((seg << 4) | ((pcm_val >> ((seg)  ?  (seg + 3)  :  4)) & 0x0F)) ^ mask;
+}
+/*- End of function --------------------------------------------------------*/
+
+static inline short int __init alaw2linear (uint8_t alaw)
+{
+    int i;
+    int seg;
+
+    alaw ^= AMI_MASK;
+    i = ((alaw & 0x0F) << 4);
+    seg = (((int) alaw & 0x70) >> 4);
+    if (seg)
+        i = (i + 0x100) << (seg - 1);
+    return (short int) ((alaw & 0x80)  ?  i  :  -i);
+}
+/*- End of function --------------------------------------------------------*/
+static void  __init zt_conv_init(void)
+{
+	int i;
+
+	/* 
+	 *  Set up mu-law conversion table
+	 */
+	for(i = 0;i < 256;i++)
+	   {
+		short mu,e,f,y;
+		static short etab[]={0,132,396,924,1980,4092,8316,16764};
+
+		mu = 255-i;
+		e = (mu & 0x70)/16;
+		f = mu & 0x0f;
+		y = f * (1 << (e + 3));
+		y += etab[e];
+		if (mu & 0x80) y = -y;
+	        __zt_mulaw[i] = y;
+		__zt_alaw[i] = alaw2linear(i);
+		/* Default (0.0 db) gain table */
+		defgain[i] = i;
+	   }
+#ifndef CONFIG_CALC_XLAW
+	  /* set up the reverse (mu-law) conversion table */
+	for(i = -32768; i < 32768; i += 4)
+	   {
+		__zt_lin2mu[((unsigned short)(short)i) >> 2] = __zt_lineartoulaw(i);
+		__zt_lin2a[((unsigned short)(short)i) >> 2] = __zt_lineartoalaw(i);
+	   }
+#endif
+}
+
+static inline void __zt_process_getaudio_chunk(struct zt_chan *ss, unsigned char *txb)
+{
+	/* We transmit data from our master channel */
+	/* Called with ss->lock held */
+	struct zt_chan *ms = ss->master;
+	/* Linear representation */
+	short getlin[ZT_CHUNKSIZE], k[ZT_CHUNKSIZE];
+	int x;
+
+	/* Okay, now we've got something to transmit */
+	for (x=0;x<ZT_CHUNKSIZE;x++)
+		getlin[x] = ZT_XLAW(txb[x], ms);
+#ifndef NO_ECHOCAN_DISABLE
+	if (ms->ec) {
+		for (x=0;x<ZT_CHUNKSIZE;x++) {
+			/* Check for echo cancel disabling tone */
+			if (echo_can_disable_detector_update(&ms->txecdis, getlin[x])) {
+				printk("zaptel Disabled echo canceller because of tone (tx) on channel %d\n", ss->channo);
+				ms->echocancel = 0;
+				ms->echostate = ECHO_STATE_IDLE;
+				ms->echolastupdate = 0;
+				ms->echotimer = 0;
+				echo_can_free(ms->ec);
+				ms->ec = NULL;
+				__qevent(ss, ZT_EVENT_EC_DISABLED);
+				break;
+			}
+		}
+	}
+#endif
+	if ((!ms->confmute && !ms->dialing) || (ms->flags & ZT_FLAG_PSEUDO)) {
+		/* Handle conferencing on non-clear channel and non-HDLC channels */
+		switch(ms->confmode & ZT_CONF_MODE_MASK) {
+		case ZT_CONF_NORMAL:
+			/* Do nuffin */
+			break;
+		case ZT_CONF_MONITOR:	/* Monitor a channel's rx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO) break;
+			/* Add monitored channel */
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				ACSS(getlin, chans[ms->confna]->getlin);
+			} else {
+				ACSS(getlin, chans[ms->confna]->putlin);
+			}
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+			break;
+		case ZT_CONF_MONITORTX: /* Monitor a channel's tx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO) break;
+			/* Add monitored channel */
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				ACSS(getlin, chans[ms->confna]->putlin);
+			} else {
+				ACSS(getlin, chans[ms->confna]->getlin);
+			}
+
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+			break;
+		case ZT_CONF_MONITORBOTH: /* monitor a channel's rx and tx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO) break;
+			ACSS(getlin, chans[ms->confna]->putlin);
+			ACSS(getlin, chans[ms->confna]->getlin);
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+			break;
+		case ZT_CONF_MONITOR_RX_PREECHO:	/* Monitor a channel's rx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO)
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			/* Add monitored channel */
+			ACSS(getlin, chans[ms->confna]->flags & ZT_FLAG_PSEUDO ?
+			     chans[ms->confna]->readchunkpreec : chans[ms->confna]->putlin);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+
+			break;
+		case ZT_CONF_MONITOR_TX_PREECHO: /* Monitor a channel's tx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO)
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			/* Add monitored channel */
+			ACSS(getlin, chans[ms->confna]->flags & ZT_FLAG_PSEUDO ?
+			     chans[ms->confna]->putlin : chans[ms->confna]->readchunkpreec);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+
+			break;
+		case ZT_CONF_MONITORBOTH_PREECHO: /* monitor a channel's rx and tx mode */
+			  /* if a pseudo-channel, ignore */
+			if (ms->flags & ZT_FLAG_PSEUDO)
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			ACSS(getlin, chans[ms->confna]->putlin);
+			ACSS(getlin, chans[ms->confna]->readchunkpreec);
+
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+
+			break;
+		case ZT_CONF_REALANDPSEUDO:
+			/* This strange mode takes the transmit buffer and
+				puts it on the conference, minus its last sample,
+				then outputs from the conference minus the 
+				real channel's last sample. */
+			  /* if to talk on conf */
+			if (ms->confmode & ZT_CONF_PSEUDO_TALKER) {
+				/* Store temp value */
+				memcpy(k, getlin, ZT_CHUNKSIZE * sizeof(short));
+				/* Add conf value */
+				ACSS(k, conf_sums_next[ms->_confn]);
+				/* save last one */
+				memcpy(ms->conflast2, ms->conflast1, ZT_CHUNKSIZE * sizeof(short));
+				memcpy(ms->conflast1, k, ZT_CHUNKSIZE * sizeof(short));
+				/*  get amount actually added */
+				SCSS(ms->conflast1, conf_sums_next[ms->_confn]);
+				/* Really add in new value */
+				ACSS(conf_sums_next[ms->_confn], ms->conflast1);
+			} else {
+				memset(ms->conflast1, 0, ZT_CHUNKSIZE * sizeof(short));
+				memset(ms->conflast2, 0, ZT_CHUNKSIZE * sizeof(short));
+			}
+			memset(getlin, 0, ZT_CHUNKSIZE * sizeof(short));
+			txb[0] = ZT_LIN2X(0, ms);
+			memset(txb + 1, txb[0], ZT_CHUNKSIZE - 1);
+			/* fall through to normal conf mode */
+		case ZT_CONF_CONF:	/* Normal conference mode */
+			if (ms->flags & ZT_FLAG_PSEUDO) /* if pseudo-channel */
+			   {
+				  /* if to talk on conf */
+				if (ms->confmode & ZT_CONF_TALKER) {
+					/* Store temp value */
+					memcpy(k, getlin, ZT_CHUNKSIZE * sizeof(short));
+					/* Add conf value */
+					ACSS(k, conf_sums[ms->_confn]);
+					/*  get amount actually added */
+					memcpy(ms->conflast, k, ZT_CHUNKSIZE * sizeof(short));
+					SCSS(ms->conflast, conf_sums[ms->_confn]);
+					/* Really add in new value */
+					ACSS(conf_sums[ms->_confn], ms->conflast);
+					memcpy(ms->getlin, getlin, ZT_CHUNKSIZE * sizeof(short));
+				} else {
+					memset(ms->conflast, 0, ZT_CHUNKSIZE * sizeof(short));
+					memcpy(getlin, ms->getlin, ZT_CHUNKSIZE * sizeof(short));
+				}
+				txb[0] = ZT_LIN2X(0, ms);
+				memset(txb + 1, txb[0], ZT_CHUNKSIZE - 1);
+				break;
+		 	   }
+			/* fall through */
+		case ZT_CONF_CONFMON:	/* Conference monitor mode */
+			if (ms->confmode & ZT_CONF_LISTENER) {
+				/* Subtract out last sample written to conf */
+				SCSS(getlin, ms->conflast);
+				/* Add in conference */
+				ACSS(getlin, conf_sums[ms->_confn]);
+			}
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+			break;
+		case ZT_CONF_CONFANN:
+		case ZT_CONF_CONFANNMON:
+			/* First, add tx buffer to conf */
+			ACSS(conf_sums_next[ms->_confn], getlin);
+			/* Start with silence */
+			memset(getlin, 0, ZT_CHUNKSIZE * sizeof(short));
+			/* If a listener on the conf... */
+			if (ms->confmode & ZT_CONF_LISTENER) {
+				/* Subtract last value written */
+				SCSS(getlin, ms->conflast);
+				/* Add in conf */
+				ACSS(getlin, conf_sums[ms->_confn]);
+			}
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				txb[x] = ZT_LIN2X(getlin[x], ms);
+			break;
+		case ZT_CONF_DIGITALMON:
+			/* Real digital monitoring, but still echo cancel if desired */
+			if (!chans[ms->confna])
+				break;
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				if (ms->ec) {
+					for (x=0;x<ZT_CHUNKSIZE;x++)
+						txb[x] = ZT_LIN2X(chans[ms->confna]->getlin[x], ms);
+				} else {
+					memcpy(txb, chans[ms->confna]->getraw, ZT_CHUNKSIZE);
+				}
+			} else {
+				if (ms->ec) {
+					for (x=0;x<ZT_CHUNKSIZE;x++)
+						txb[x] = ZT_LIN2X(chans[ms->confna]->putlin[x], ms);
+				} else {
+					memcpy(txb, chans[ms->confna]->putraw, ZT_CHUNKSIZE);
+				}
+			}
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				getlin[x] = ZT_XLAW(txb[x], ms);
+			break;
+		}
+	}
+	if (ms->confmute || (ms->echostate & __ECHO_STATE_MUTE)) {
+		txb[0] = ZT_LIN2X(0, ms);
+		memset(txb + 1, txb[0], ZT_CHUNKSIZE - 1);
+		if (ms->echostate == ECHO_STATE_STARTTRAINING) {
+			/* Transmit impulse now */
+			txb[0] = ZT_LIN2X(16384, ms);
+			ms->echostate = ECHO_STATE_AWAITINGECHO;
+		}
+	}
+	/* save value from last chunk */
+	memcpy(ms->getlin_lastchunk, ms->getlin, ZT_CHUNKSIZE * sizeof(short));
+	/* save value from current */
+	memcpy(ms->getlin, getlin, ZT_CHUNKSIZE * sizeof(short));
+	/* save value from current */
+	memcpy(ms->getraw, txb, ZT_CHUNKSIZE);
+	/* if to make tx tone */
+	if (ms->v1_1 || ms->v2_1 || ms->v3_1)
+	{
+		for (x=0;x<ZT_CHUNKSIZE;x++)
+		{
+			getlin[x] += zt_txtone_nextsample(ms);
+			txb[x] = ZT_LIN2X(getlin[x], ms);
+		}
+	}
+	/* This is what to send (after having applied gain) */
+	for (x=0;x<ZT_CHUNKSIZE;x++)
+		txb[x] = ms->txgain[txb[x]];
+}
+
+static inline void __zt_getbuf_chunk(struct zt_chan *ss, unsigned char *txb)
+{
+	/* Called with ss->lock held */
+	/* We transmit data from our master channel */
+	struct zt_chan *ms = ss->master;
+	/* Buffer we're using */
+	unsigned char *buf;
+	/* Old buffer number */
+	int oldbuf;
+	/* Linear representation */
+	int getlin;
+	/* How many bytes we need to process */
+	int bytes = ZT_CHUNKSIZE, left;
+	int x;
+
+	/* Let's pick something to transmit.  First source to
+	   try is our write-out buffer.  Always check it first because
+	   its our 'fast path' for whatever that's worth. */
+	while(bytes) {
+		if ((ms->outwritebuf > -1) && !ms->txdisable) {
+			buf= ms->writebuf[ms->outwritebuf];
+			left = ms->writen[ms->outwritebuf] - ms->writeidx[ms->outwritebuf];
+			if (left > bytes)
+				left = bytes;
+			if (ms->flags & ZT_FLAG_HDLC) {
+				/* If this is an HDLC channel we only send a byte of
+				   HDLC. */
+				for(x=0;x<left;x++) {
+					if (ms->txhdlc.bits < 8)
+						/* Load a byte of data only if needed */
+						fasthdlc_tx_load_nocheck(&ms->txhdlc, buf[ms->writeidx[ms->outwritebuf]++]);
+					*(txb++) = fasthdlc_tx_run_nocheck(&ms->txhdlc);
+				}
+				bytes -= left;
+			} else {
+				memcpy(txb, buf + ms->writeidx[ms->outwritebuf], left);
+				ms->writeidx[ms->outwritebuf]+=left;
+				txb += left;
+				bytes -= left;
+			}
+			/* Check buffer status */
+			if (ms->writeidx[ms->outwritebuf] >= ms->writen[ms->outwritebuf]) {
+				/* We've reached the end of our buffer.  Go to the next. */
+				oldbuf = ms->outwritebuf;
+				/* Clear out write index and such */
+				ms->writeidx[oldbuf] = 0;
+				ms->outwritebuf = (ms->outwritebuf + 1) % ms->numbufs;
+
+				if (!(ms->flags & ZT_FLAG_MTP2)) {
+					ms->writen[oldbuf] = 0;
+					if (ms->outwritebuf == ms->inwritebuf) {
+						/* Whoopsies, we're run out of buffers.  Mark ours
+						as -1 and wait for the filler to notify us that
+						there is something to write */
+						ms->outwritebuf = -1;
+						if (ms->iomask & (ZT_IOMUX_WRITE | ZT_IOMUX_WRITEEMPTY))
+							wake_up_interruptible(&ms->eventbufq);
+						/* If we're only supposed to start when full, disable the transmitter */
+						if (ms->txbufpolicy == ZT_POLICY_WHEN_FULL)
+							ms->txdisable = 1;
+					}
+				} else {
+					if (ms->outwritebuf == ms->inwritebuf) {
+						ms->outwritebuf = oldbuf;
+						if (ms->iomask & (ZT_IOMUX_WRITE | ZT_IOMUX_WRITEEMPTY))
+							wake_up_interruptible(&ms->eventbufq);
+						/* If we're only supposed to start when full, disable the transmitter */
+						if (ms->txbufpolicy == ZT_POLICY_WHEN_FULL)
+							ms->txdisable = 1;
+					}
+				}
+				if (ms->inwritebuf < 0) {
+					/* The filler doesn't have a place to put data.  Now
+					that we're done with this buffer, notify them. */
+					ms->inwritebuf = oldbuf;
+				}
+/* In the very orignal driver, it was quite well known to me (Jim) that there
+was a possibility that a channel sleeping on a write block needed to
+be potentially woken up EVERY time a buffer was emptied, not just on the first
+one, because if only done on the first one there is a slight timing potential
+of missing the wakeup (between where it senses the (lack of) active condition
+(with interrupts disabled) and where it does the sleep (interrupts enabled)
+in the read or iomux call, etc). That is why the write and iomux calls start
+with an infinite loop that gets broken out of upon an active condition,
+otherwise keeps sleeping and looking. The part in this code got "optimized"
+out in the later versions, and is put back now. */
+				if (!(ms->flags & (ZT_FLAG_NETDEV | ZT_FLAG_PPP))) {
+					wake_up_interruptible(&ms->writebufq);
+					wake_up_interruptible(&ms->sel);
+					if (ms->iomask & ZT_IOMUX_WRITE)
+						wake_up_interruptible(&ms->eventbufq);
+				}
+				/* Transmit a flag if this is an HDLC channel */
+				if (ms->flags & ZT_FLAG_HDLC)
+					fasthdlc_tx_frame_nocheck(&ms->txhdlc);
+#ifdef CONFIG_ZAPATA_NET
+				if (ms->flags & ZT_FLAG_NETDEV)
+					netif_wake_queue(ztchan_to_dev(ms));
+#endif				
+#ifdef CONFIG_ZAPATA_PPP
+				if (ms->flags & ZT_FLAG_PPP) {
+					ms->do_ppp_wakeup = 1;
+					tasklet_schedule(&ms->ppp_calls);
+				}
+#endif
+			}
+		} else if (ms->curtone && !(ms->flags & ZT_FLAG_PSEUDO)) {
+			left = ms->curtone->tonesamples - ms->tonep;
+			if (left > bytes)
+				left = bytes;
+			for (x=0;x<left;x++) {
+				/* Pick our default value from the next sample of the current tone */
+				getlin = zt_tone_nextsample(&ms->ts, ms->curtone);
+				*(txb++) = ZT_LIN2X(getlin, ms);
+			}
+			ms->tonep+=left;
+			bytes -= left;
+			if (ms->tonep >= ms->curtone->tonesamples) {
+				struct zt_tone *last;
+				/* Go to the next sample of the tone */
+				ms->tonep = 0;
+				last = ms->curtone;
+				ms->curtone = ms->curtone->next;
+				if (!ms->curtone) {
+					/* No more tones...  Is this dtmf or mf?  If so, go to the next digit */
+					if (ms->dialing)
+						__do_dtmf(ms);
+				} else {
+					if (last != ms->curtone)
+						zt_init_tone_state(&ms->ts, ms->curtone);
+				}
+			}
+		} else if (ms->flags & ZT_FLAG_LOOPED) {
+			for (x = 0; x < bytes; x++)
+				txb[x] = ms->readchunk[x];
+			bytes = 0;
+		} else if (ms->flags & ZT_FLAG_HDLC) {
+			for (x=0;x<bytes;x++) {
+				/* Okay, if we're HDLC, then transmit a flag by default */
+				if (ms->txhdlc.bits < 8) 
+					fasthdlc_tx_frame_nocheck(&ms->txhdlc);
+				*(txb++) = fasthdlc_tx_run_nocheck(&ms->txhdlc);
+			}
+			bytes = 0;
+		} else if (ms->flags & ZT_FLAG_CLEAR) {
+			/* Clear channels that are idle in audio mode need
+			   to send silence; in non-audio mode, always send 0xff
+			   so stupid switches won't consider the channel active
+			*/
+			if (ms->flags & ZT_FLAG_AUDIO) {
+				memset(txb, ZT_LIN2X(0, ms), bytes);
+			} else {
+				memset(txb, 0xFF, bytes);
+			}
+			bytes = 0;
+		} else {
+			memset(txb, ZT_LIN2X(0, ms), bytes);	/* Lastly we use silence on telephony channels */
+			bytes = 0;
+		}
+	}	
+}
+
+static inline void rbs_itimer_expire(struct zt_chan *chan)
+{
+	/* the only way this could have gotten here, is if a channel
+	    went onf hook longer then the wink or flash detect timeout */
+	/* Called with chan->lock held */
+	switch(chan->sig)
+	{
+	    case ZT_SIG_FXOLS:  /* if FXO, its definitely on hook */
+	    case ZT_SIG_FXOGS:
+	    case ZT_SIG_FXOKS:
+		__qevent(chan,ZT_EVENT_ONHOOK);
+		chan->gotgs = 0; 
+		break;
+#if defined(EMFLASH) || defined(EMPULSE)
+	    case ZT_SIG_EM:
+	    case ZT_SIG_EM_E1:
+		if (chan->rxhooksig == ZT_RXSIG_ONHOOK) {
+			__qevent(chan,ZT_EVENT_ONHOOK); 
+			break;
+		}
+		__qevent(chan,ZT_EVENT_RINGOFFHOOK); 
+		break;
+#endif
+#ifdef	FXSFLASH
+	    case ZT_SIG_FXSKS:
+		if (chan->rxhooksig == ZT_RXSIG_ONHOOK) {
+			__qevent(chan, ZT_EVENT_ONHOOK); 
+			break;
+		}
+#endif
+		/* fall thru intentionally */
+	    default:  /* otherwise, its definitely off hook */
+		__qevent(chan,ZT_EVENT_RINGOFFHOOK); 
+		break;
+	}
+}
+
+static inline void __rbs_otimer_expire(struct zt_chan *chan)
+{
+	int len = 0;
+	/* Called with chan->lock held */
+
+	chan->otimer = 0;
+	/* Move to the next timer state */	
+	switch(chan->txstate) {
+	case ZT_TXSTATE_RINGOFF:
+		/* Turn on the ringer now that the silent time has passed */
+		++chan->cadencepos;
+		if (chan->cadencepos >= ZT_MAX_CADENCE)
+			chan->cadencepos = chan->firstcadencepos;
+		len = chan->ringcadence[chan->cadencepos];
+
+		if (!len) {
+			chan->cadencepos = chan->firstcadencepos;
+			len = chan->ringcadence[chan->cadencepos];
+		}
+
+		zt_rbs_sethook(chan, ZT_TXSIG_START, ZT_TXSTATE_RINGON, len);
+		__qevent(chan, ZT_EVENT_RINGERON);
+		break;
+		
+	case ZT_TXSTATE_RINGON:
+		/* Turn off the ringer now that the loud time has passed */
+		++chan->cadencepos;
+		if (chan->cadencepos >= ZT_MAX_CADENCE)
+			chan->cadencepos = 0;
+		len = chan->ringcadence[chan->cadencepos];
+
+		if (!len) {
+			chan->cadencepos = 0;
+			len = chan->curzone->ringcadence[chan->cadencepos];
+		}
+
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_RINGOFF, len);
+		__qevent(chan, ZT_EVENT_RINGEROFF);
+		break;
+		
+	case ZT_TXSTATE_START:
+		/* If we were starting, go off hook now ready to debounce */
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_AFTERSTART, ZT_AFTERSTART_TIME);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+		
+	case ZT_TXSTATE_PREWINK:
+		/* Actually wink */
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_WINK, chan->winktime);
+		break;
+		
+	case ZT_TXSTATE_WINK:
+		/* Wink complete, go on hook and stabalize */
+		zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_ONHOOK, 0);
+		if (chan->file && (chan->file->f_flags & O_NONBLOCK))
+			__qevent(chan, ZT_EVENT_HOOKCOMPLETE);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+		
+	case ZT_TXSTATE_PREFLASH:
+		/* Actually flash */
+		zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_FLASH, chan->flashtime);
+		break;
+
+	case ZT_TXSTATE_FLASH:
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_OFFHOOK, 0);
+		if (chan->file && (chan->file->f_flags & O_NONBLOCK))
+			__qevent(chan, ZT_EVENT_HOOKCOMPLETE);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+	
+	case ZT_TXSTATE_DEBOUNCE:
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_OFFHOOK, 0);
+		/* See if we've gone back on hook */
+		if ((chan->rxhooksig == ZT_RXSIG_ONHOOK) && (chan->rxflashtime > 2))
+			chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+		wake_up_interruptible(&chan->txstateq);
+		break;
+		
+	case ZT_TXSTATE_AFTERSTART:
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_OFFHOOK, 0);
+		if (chan->file && (chan->file->f_flags & O_NONBLOCK))
+			__qevent(chan, ZT_EVENT_HOOKCOMPLETE);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+
+	case ZT_TXSTATE_KEWL:
+		zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, ZT_TXSTATE_AFTERKEWL, ZT_AFTERKEWLTIME);
+		if (chan->file && (chan->file->f_flags & O_NONBLOCK))
+			__qevent(chan, ZT_EVENT_HOOKCOMPLETE);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+
+	case ZT_TXSTATE_AFTERKEWL:
+		if (chan->kewlonhook)  {
+			__qevent(chan,ZT_EVENT_ONHOOK);
+		}
+		chan->txstate = ZT_TXSTATE_ONHOOK;
+		chan->gotgs = 0;
+		break;
+
+	case ZT_TXSTATE_PULSEBREAK:
+		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_PULSEMAKE, 
+			chan->pulsemaketime);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+
+	case ZT_TXSTATE_PULSEMAKE:
+		if (chan->pdialcount)
+			chan->pdialcount--;
+		if (chan->pdialcount)
+		{
+			zt_rbs_sethook(chan, ZT_TXSIG_ONHOOK, 
+				ZT_TXSTATE_PULSEBREAK, chan->pulsebreaktime);
+			break;
+		}
+		chan->txstate = ZT_TXSTATE_PULSEAFTER;
+		chan->otimer = chan->pulseaftertime * ZT_CHUNKSIZE;
+		wake_up_interruptible(&chan->txstateq);
+		break;
+
+	case ZT_TXSTATE_PULSEAFTER:
+		chan->txstate = ZT_TXSTATE_OFFHOOK;
+		__do_dtmf(chan);
+		wake_up_interruptible(&chan->txstateq);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void __zt_hooksig_pvt(struct zt_chan *chan, zt_rxsig_t rxsig)
+{
+
+	/* State machines for receive hookstate transitions 
+		called with chan->lock held */
+
+	if ((chan->rxhooksig) == rxsig) return;
+	
+	if ((chan->flags & ZT_FLAG_SIGFREEZE)) return;
+
+	chan->rxhooksig = rxsig;
+#ifdef	RINGBEGIN
+	if ((chan->sig & __ZT_SIG_FXS) && (rxsig == ZT_RXSIG_RING) &&
+	    (!chan->ringdebtimer))
+		__qevent(chan,ZT_EVENT_RINGBEGIN);  
+#endif
+	switch(chan->sig) {
+	    case ZT_SIG_EM:  /* E and M */
+	    case ZT_SIG_EM_E1:
+		switch(rxsig) {
+		    case ZT_RXSIG_OFFHOOK: /* went off hook */
+			/* The interface is going off hook */
+#ifdef	EMFLASH
+			if (chan->itimer)
+			{
+				__qevent(chan,ZT_EVENT_WINKFLASH); 
+				chan->itimerset = chan->itimer = 0;
+				break;				
+			}
+#endif
+#ifdef EMPULSE
+			if (chan->itimer) /* if timer still running */
+			{
+			    int plen = chan->itimerset - chan->itimer;
+			    if (plen <= ZT_MAXPULSETIME)
+			    {
+					if (plen >= ZT_MINPULSETIME)
+					{
+						chan->pulsecount++;
+
+						chan->pulsetimer = ZT_PULSETIMEOUT;
+                                                chan->itimerset = chan->itimer = 0;
+						if (chan->pulsecount == 1)
+							__qevent(chan,ZT_EVENT_PULSE_START); 
+					} 
+			    } 
+			    break;
+			}
+#endif
+			/* set wink timer */
+			chan->itimerset = chan->itimer = chan->rxwinktime * ZT_CHUNKSIZE;
+			break;
+		    case ZT_RXSIG_ONHOOK: /* went on hook */
+			/* This interface is now going on hook.
+			   Check for WINK, etc */
+			if (chan->itimer)
+				__qevent(chan,ZT_EVENT_WINKFLASH); 
+#if defined(EMFLASH) || defined(EMPULSE)
+			else {
+#ifdef EMFLASH
+				chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+
+#else /* EMFLASH */
+				chan->itimerset = chan->itimer = chan->rxwinktime * ZT_CHUNKSIZE;
+
+#endif /* EMFLASH */
+				chan->gotgs = 0;
+				break;				
+			}
+#else /* EMFLASH || EMPULSE */
+			else {
+				__qevent(chan,ZT_EVENT_ONHOOK); 
+				chan->gotgs = 0;
+			}
+#endif
+			chan->itimerset = chan->itimer = 0;
+			break;
+		    default:
+			break;
+		}
+		break;
+	   case ZT_SIG_FXSKS:  /* FXS Kewlstart */
+		  /* ignore a bit poopy if loop not closed and stable */
+		if (chan->txstate != ZT_TXSTATE_OFFHOOK) break;
+#ifdef	FXSFLASH
+		if (rxsig == ZT_RXSIG_ONHOOK) {
+			chan->itimer = ZT_FXSFLASHMAXTIME * ZT_CHUNKSIZE;
+			break;
+		} else 	if (rxsig == ZT_RXSIG_OFFHOOK) {
+			if (chan->itimer) {
+				/* did the offhook occur in the window? if not, ignore both events */
+				if (chan->itimer <= ((ZT_FXSFLASHMAXTIME - ZT_FXSFLASHMINTIME) * ZT_CHUNKSIZE))
+					__qevent(chan, ZT_EVENT_WINKFLASH);
+			}
+			chan->itimer = 0;
+			break;
+		}
+#endif
+		/* fall through intentionally */
+	   case ZT_SIG_FXSGS:  /* FXS Groundstart */
+		if (rxsig == ZT_RXSIG_ONHOOK) {
+			chan->ringdebtimer = RING_DEBOUNCE_TIME;
+			chan->ringtrailer = 0;
+			if (chan->txstate != ZT_TXSTATE_DEBOUNCE) {
+				chan->gotgs = 0;
+				__qevent(chan,ZT_EVENT_ONHOOK);
+			}
+		}
+		break;
+	   case ZT_SIG_FXOGS: /* FXO Groundstart */
+		if (rxsig == ZT_RXSIG_START) {
+			  /* if havent got gs, report it */
+			if (!chan->gotgs) {
+				__qevent(chan,ZT_EVENT_RINGOFFHOOK);
+				chan->gotgs = 1;
+			}
+		}
+		/* fall through intentionally */
+	   case ZT_SIG_FXOLS: /* FXO Loopstart */
+	   case ZT_SIG_FXOKS: /* FXO Kewlstart */
+		switch(rxsig) {
+		    case ZT_RXSIG_OFFHOOK: /* went off hook */
+			  /* if asserti ng ring, stop it */
+			if (chan->txstate == ZT_TXSTATE_START) {
+				zt_rbs_sethook(chan,ZT_TXSIG_OFFHOOK, ZT_TXSTATE_AFTERSTART, ZT_AFTERSTART_TIME);
+			}
+			chan->kewlonhook = 0;
+#ifdef CONFIG_ZAPATA_DEBUG
+			printk("Off hook on channel %d, itimer = %d, gotgs = %d\n", chan->channo, chan->itimer, chan->gotgs);
+#endif
+			if (chan->itimer) /* if timer still running */
+			{
+			    int plen = chan->itimerset - chan->itimer;
+			    if (plen <= ZT_MAXPULSETIME)
+			    {
+					if (plen >= ZT_MINPULSETIME)
+					{
+						chan->pulsecount++;
+						chan->pulsetimer = ZT_PULSETIMEOUT;
+						chan->itimer = chan->itimerset;
+						if (chan->pulsecount == 1)
+							__qevent(chan,ZT_EVENT_PULSE_START); 
+					} 
+			    } else 
+					__qevent(chan,ZT_EVENT_WINKFLASH); 
+			} else {
+				  /* if havent got GS detect */
+				if (!chan->gotgs) {
+					__qevent(chan,ZT_EVENT_RINGOFFHOOK); 
+					chan->gotgs = 1;
+					chan->itimerset = chan->itimer = 0;
+				}
+			}
+			chan->itimerset = chan->itimer = 0;
+			break;
+		    case ZT_RXSIG_ONHOOK: /* went on hook */
+			  /* if not during offhook debounce time */
+			if ((chan->txstate != ZT_TXSTATE_DEBOUNCE) &&
+			    (chan->txstate != ZT_TXSTATE_KEWL) && 
+			    (chan->txstate != ZT_TXSTATE_AFTERKEWL)) {
+				chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+			}
+			if (chan->txstate == ZT_TXSTATE_KEWL)
+				chan->kewlonhook = 1;
+			break;
+		    default:
+			break;
+		}
+	    default:
+		break;
+	}
+}
+
+void zt_hooksig(struct zt_chan *chan, zt_rxsig_t rxsig)
+{
+	  /* skip if no change */
+	unsigned long flags;
+	spin_lock_irqsave(&chan->lock, flags);
+	__zt_hooksig_pvt(chan,rxsig);
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+void zt_rbsbits(struct zt_chan *chan, int cursig)
+{
+	unsigned long flags;
+	if (cursig == chan->rxsig)
+		return;
+
+	if ((chan->flags & ZT_FLAG_SIGFREEZE)) return;
+
+	spin_lock_irqsave(&chan->lock, flags);
+	switch(chan->sig) {
+	    case ZT_SIG_FXOGS: /* FXO Groundstart */
+		/* B-bit only matters for FXO GS */
+		if (!(cursig & ZT_BBIT)) {
+			__zt_hooksig_pvt(chan, ZT_RXSIG_START);
+			break;
+		}
+		/* Fall through */
+	    case ZT_SIG_EM:  /* E and M */
+	    case ZT_SIG_EM_E1:
+	    case ZT_SIG_FXOLS: /* FXO Loopstart */
+	    case ZT_SIG_FXOKS: /* FXO Kewlstart */
+		if (cursig & ZT_ABIT)  /* off hook */
+			__zt_hooksig_pvt(chan,ZT_RXSIG_OFFHOOK);
+		else /* on hook */
+			__zt_hooksig_pvt(chan,ZT_RXSIG_ONHOOK);
+		break;
+
+	   case ZT_SIG_FXSKS:  /* FXS Kewlstart */
+	   case ZT_SIG_FXSGS:  /* FXS Groundstart */
+		/* Fall through */
+	   case ZT_SIG_FXSLS:
+		if (!(cursig & ZT_BBIT)) {
+			/* Check for ringing first */
+			__zt_hooksig_pvt(chan, ZT_RXSIG_RING);
+			break;
+		}
+		if ((chan->sig != ZT_SIG_FXSLS) && (cursig & ZT_ABIT)) { 
+			    /* if went on hook */
+			__zt_hooksig_pvt(chan, ZT_RXSIG_ONHOOK);
+		} else {
+			__zt_hooksig_pvt(chan, ZT_RXSIG_OFFHOOK);
+		}
+		break;
+	   case ZT_SIG_CAS:
+		/* send event that something changed */
+		__qevent(chan, ZT_EVENT_BITSCHANGED);
+		break;
+
+	   default:
+		break;
+	}
+	/* Keep track of signalling for next time */
+	chan->rxsig = cursig;
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+static inline void __zt_ec_chunk(struct zt_chan *ss, unsigned char *rxchunk, const unsigned char *txchunk)
+{
+	short rxlin, txlin;
+	int x;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ss->lock, flags);
+
+	if (ss->readchunkpreec) {
+		/* Save a copy of the audio before the echo can has its way with it */
+		for (x = 0; x < ZT_CHUNKSIZE; x++)
+			/* We only ever really need to deal with signed linear - let's just convert it now */
+			ss->readchunkpreec[x] = ZT_XLAW(rxchunk[x], ss);
+	}
+
+	/* Perform echo cancellation on a chunk if necessary */
+	if (ss->ec) {
+#if defined(CONFIG_ZAPTEL_MMX) || defined(ECHO_CAN_FP)
+		zt_kernel_fpu_begin();
+#endif		
+		if (ss->echostate & __ECHO_STATE_MUTE) {
+			/* Special stuff for training the echo can */
+			for (x=0;x<ZT_CHUNKSIZE;x++) {
+				rxlin = ZT_XLAW(rxchunk[x], ss);
+				txlin = ZT_XLAW(txchunk[x], ss);
+				if (ss->echostate == ECHO_STATE_PRETRAINING) {
+					if (--ss->echotimer <= 0) {
+						ss->echotimer = 0;
+						ss->echostate = ECHO_STATE_STARTTRAINING;
+					}
+				}
+				if ((ss->echostate == ECHO_STATE_AWAITINGECHO) && (txlin > 8000)) {
+					ss->echolastupdate = 0;
+					ss->echostate = ECHO_STATE_TRAINING;
+				}
+				if (ss->echostate == ECHO_STATE_TRAINING) {
+					if (echo_can_traintap(ss->ec, ss->echolastupdate++, rxlin)) {
+#if 0
+						printk("Finished training (%d taps trained)!\n", ss->echolastupdate);
+#endif						
+						ss->echostate = ECHO_STATE_ACTIVE;
+					}
+				}
+				rxlin = 0;
+				rxchunk[x] = ZT_LIN2X((int)rxlin, ss);
+			}
+		} else {
+#if !defined(ZT_EC_ARRAY_UPDATE)
+			for (x=0;x<ZT_CHUNKSIZE;x++) {
+				rxlin = ZT_XLAW(rxchunk[x], ss);
+				rxlin = echo_can_update(ss->ec, ZT_XLAW(txchunk[x], ss), rxlin);
+				rxchunk[x] = ZT_LIN2X((int) rxlin, ss);
+			}
+#else /* defined(ZT_EC_ARRAY_UPDATE) */
+			short rxlins[ZT_CHUNKSIZE], txlins[ZT_CHUNKSIZE];
+			for (x = 0; x < ZT_CHUNKSIZE; x++) {
+				rxlins[x] = ZT_XLAW(rxchunk[x], ss);
+				txlins[x] = ZT_XLAW(txchunk[x], ss);
+			}
+			echo_can_array_update(ss->ec, rxlins, txlins);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				rxchunk[x] = ZT_LIN2X((int) rxlins[x], ss);
+#endif /* defined(ZT_EC_ARRAY_UPDATE) */
+		}
+#if defined(CONFIG_ZAPTEL_MMX) || defined(ECHO_CAN_FP)
+		kernel_fpu_end();
+#endif		
+	}
+	spin_unlock_irqrestore(&ss->lock, flags);
+}
+
+void zt_ec_chunk(struct zt_chan *ss, unsigned char *rxchunk, const unsigned char *txchunk)
+{
+	__zt_ec_chunk(ss, rxchunk, txchunk);
+}
+
+void zt_ec_span(struct zt_span *span)
+{
+	int x;
+	for (x = 0; x < span->channels; x++) {
+		if (span->chans[x].ec)
+			__zt_ec_chunk(&span->chans[x], span->chans[x].readchunk, span->chans[x].writechunk);
+	}
+}
+
+/* return 0 if nothing detected, 1 if lack of tone, 2 if presence of tone */
+/* modifies buffer pointed to by 'amp' with notched-out values */
+static inline int sf_detect (sf_detect_state_t *s,
+                 short *amp,
+                 int samples,long p1, long p2, long p3)
+{
+int     i,rv = 0;
+long x,y;
+
+#define	SF_DETECT_SAMPLES (ZT_CHUNKSIZE * 5)
+#define	SF_DETECT_MIN_ENERGY 500
+#define	NB 14  /* number of bits to shift left */
+         
+        /* determine energy level before filtering */
+        for(i = 0; i < samples; i++)
+        {
+                if (amp[i] < 0) s->e1 -= amp[i];
+                else s->e1 += amp[i];
+        }
+	/* do 2nd order IIR notch filter at given freq. and calculate
+	    energy */
+        for(i = 0; i < samples; i++)
+        {
+                x = amp[i] << NB;
+                y = s->x2 + (p1 * (s->x1 >> NB)) + x;
+                y += (p2 * (s->y2 >> NB)) + 
+			(p3 * (s->y1 >> NB));
+                s->x2 = s->x1;
+                s->x1 = x;
+                s->y2 = s->y1;
+                s->y1 = y;
+                amp[i] = y >> NB;
+                if (amp[i] < 0) s->e2 -= amp[i];
+                else s->e2 += amp[i];
+        }
+	s->samps += i;
+	/* if time to do determination */
+	if ((s->samps) >= SF_DETECT_SAMPLES)
+	{
+		rv = 1; /* default to no tone */
+		/* if enough energy, it is determined to be a tone */
+		if (((s->e1 - s->e2) / s->samps) > SF_DETECT_MIN_ENERGY) rv = 2;
+		/* reset energy processing variables */
+		s->samps = 0;
+		s->e1 = s->e2 = 0;
+	}
+	return(rv);		
+}
+
+static inline void __zt_process_putaudio_chunk(struct zt_chan *ss, unsigned char *rxb)
+{
+	/* We transmit data from our master channel */
+	/* Called with ss->lock held */
+	struct zt_chan *ms = ss->master;
+	/* Linear version of received data */
+	short putlin[ZT_CHUNKSIZE],k[ZT_CHUNKSIZE];
+	int x,r;
+
+	if (ms->dialing) ms->afterdialingtimer = 50;
+	else if (ms->afterdialingtimer) ms->afterdialingtimer--;
+	if (ms->afterdialingtimer && (!(ms->flags & ZT_FLAG_PSEUDO))) {
+		/* Be careful since memset is likely a macro */
+		rxb[0] = ZT_LIN2X(0, ms);
+		memset(&rxb[1], rxb[0], ZT_CHUNKSIZE - 1);  /* receive as silence if dialing */
+	} 
+	for (x=0;x<ZT_CHUNKSIZE;x++) {
+		rxb[x] = ms->rxgain[rxb[x]];
+		putlin[x] = ZT_XLAW(rxb[x], ms);
+	}
+
+#ifndef NO_ECHOCAN_DISABLE
+	if (ms->ec) {
+		for (x=0;x<ZT_CHUNKSIZE;x++) {
+			if (echo_can_disable_detector_update(&ms->rxecdis, putlin[x])) {
+				printk("zaptel Disabled echo canceller because of tone (rx) on channel %d\n", ss->channo);
+				ms->echocancel = 0;
+				ms->echostate = ECHO_STATE_IDLE;
+				ms->echolastupdate = 0;
+				ms->echotimer = 0;
+				echo_can_free(ms->ec);
+				ms->ec = NULL;
+				break;
+			}
+		}
+	}
+#endif	
+	/* if doing rx tone decoding */
+	if (ms->rxp1 && ms->rxp2 && ms->rxp3)
+	{
+		r = sf_detect(&ms->rd,putlin,ZT_CHUNKSIZE,ms->rxp1,
+			ms->rxp2,ms->rxp3);
+		/* Convert back */
+		for(x=0;x<ZT_CHUNKSIZE;x++)
+			rxb[x] = ZT_LIN2X(putlin[x], ms);
+		if (r) /* if something happened */
+		{
+			if (r != ms->rd.lastdetect)
+			{
+				if (((r == 2) && !(ms->toneflags & ZT_REVERSE_RXTONE)) ||
+				    ((r == 1) && (ms->toneflags & ZT_REVERSE_RXTONE)))
+				{
+					__qevent(ms,ZT_EVENT_RINGOFFHOOK);
+				}
+				else
+				{
+					__qevent(ms,ZT_EVENT_ONHOOK);
+				}
+				ms->rd.lastdetect = r;
+			}
+		}
+	}		
+
+	if (!(ms->flags &  ZT_FLAG_PSEUDO)) {
+		memcpy(ms->putlin, putlin, ZT_CHUNKSIZE * sizeof(short));
+		memcpy(ms->putraw, rxb, ZT_CHUNKSIZE);
+	}
+	
+	/* Take the rxc, twiddle it for conferencing if appropriate and put it
+	   back */
+	if ((!ms->confmute && !ms->afterdialingtimer) ||
+	    (ms->flags & ZT_FLAG_PSEUDO)) {
+		switch(ms->confmode & ZT_CONF_MODE_MASK) {
+		case ZT_CONF_NORMAL:		/* Normal mode */
+			/* Do nothing.  rx goes output */
+			break;
+		case ZT_CONF_MONITOR:		/* Monitor a channel's rx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO)) break;
+			/* Add monitored channel */
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				ACSS(putlin, chans[ms->confna]->getlin);
+			} else {
+				ACSS(putlin, chans[ms->confna]->putlin);
+			}
+			/* Convert back */
+			for(x=0;x<ZT_CHUNKSIZE;x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+			break;
+		case ZT_CONF_MONITORTX:	/* Monitor a channel's tx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO)) break;
+			/* Add monitored channel */
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				ACSS(putlin, chans[ms->confna]->putlin);
+			} else {
+				ACSS(putlin, chans[ms->confna]->getlin);
+			}
+			/* Convert back */
+			for(x=0;x<ZT_CHUNKSIZE;x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+			break;
+		case ZT_CONF_MONITORBOTH:	/* Monitor a channel's tx and rx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO)) break;
+			/* Note: Technically, saturation should be done at 
+			   the end of the whole addition, but for performance
+			   reasons, we don't do that.  Besides, it only matters
+			   when you're so loud you're clipping anyway */
+			ACSS(putlin, chans[ms->confna]->getlin);
+			ACSS(putlin, chans[ms->confna]->putlin);
+			/* Convert back */
+			for(x=0;x<ZT_CHUNKSIZE;x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+			break;
+		case ZT_CONF_MONITOR_RX_PREECHO:		/* Monitor a channel's rx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO))
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			/* Add monitored channel */
+			ACSS(putlin, chans[ms->confna]->flags & ZT_FLAG_PSEUDO ?
+			     chans[ms->confna]->getlin : chans[ms->confna]->readchunkpreec);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+
+			break;
+		case ZT_CONF_MONITOR_TX_PREECHO:	/* Monitor a channel's tx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO))
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			/* Add monitored channel */
+			ACSS(putlin, chans[ms->confna]->flags & ZT_FLAG_PSEUDO ?
+			     chans[ms->confna]->readchunkpreec : chans[ms->confna]->getlin);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+
+			break;
+		case ZT_CONF_MONITORBOTH_PREECHO:	/* Monitor a channel's tx and rx mode */
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO))
+				break;
+
+			if (!chans[ms->confna]->readchunkpreec)
+				break;
+
+			/* Note: Technically, saturation should be done at 
+			   the end of the whole addition, but for performance
+			   reasons, we don't do that.  Besides, it only matters
+			   when you're so loud you're clipping anyway */
+			ACSS(putlin, chans[ms->confna]->getlin);
+			ACSS(putlin, chans[ms->confna]->readchunkpreec);
+			for (x = 0; x < ZT_CHUNKSIZE; x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+
+			break;
+		case ZT_CONF_REALANDPSEUDO:
+			  /* do normal conf mode processing */
+			if (ms->confmode & ZT_CONF_TALKER) {
+				/* Store temp value */
+				memcpy(k, putlin, ZT_CHUNKSIZE * sizeof(short));
+				/* Add conf value */
+				ACSS(k, conf_sums_next[ms->_confn]);
+				/*  get amount actually added */
+				memcpy(ms->conflast, k, ZT_CHUNKSIZE * sizeof(short));
+				SCSS(ms->conflast, conf_sums_next[ms->_confn]);
+				/* Really add in new value */
+				ACSS(conf_sums_next[ms->_confn], ms->conflast);
+			} else memset(ms->conflast, 0, ZT_CHUNKSIZE * sizeof(short));
+			  /* do the pseudo-channel part processing */
+			memset(putlin, 0, ZT_CHUNKSIZE * sizeof(short));
+			if (ms->confmode & ZT_CONF_PSEUDO_LISTENER) {
+				/* Subtract out previous last sample written to conf */
+				SCSS(putlin, ms->conflast2);
+				/* Add in conference */
+				ACSS(putlin, conf_sums[ms->_confn]);
+			}
+			/* Convert back */
+			for(x=0;x<ZT_CHUNKSIZE;x++)
+				rxb[x] = ZT_LIN2X(putlin[x], ms);
+			break;
+		case ZT_CONF_CONF:	/* Normal conference mode */
+			if (ms->flags & ZT_FLAG_PSEUDO) /* if a pseudo-channel */
+			   {
+				if (ms->confmode & ZT_CONF_LISTENER) {
+					/* Subtract out last sample written to conf */
+					SCSS(putlin, ms->conflast);
+					/* Add in conference */
+					ACSS(putlin, conf_sums[ms->_confn]);
+				}
+				/* Convert back */
+				for(x=0;x<ZT_CHUNKSIZE;x++)
+					rxb[x] = ZT_LIN2X(putlin[x], ms);
+				memcpy(ss->putlin, putlin, ZT_CHUNKSIZE * sizeof(short));
+				break;
+			   }
+			/* fall through */
+		case ZT_CONF_CONFANN:  /* Conference with announce */
+			if (ms->confmode & ZT_CONF_TALKER) {
+				/* Store temp value */
+				memcpy(k, putlin, ZT_CHUNKSIZE * sizeof(short));
+				/* Add conf value */
+				ACSS(k, conf_sums_next[ms->_confn]);
+				/*  get amount actually added */
+				memcpy(ms->conflast, k, ZT_CHUNKSIZE * sizeof(short));
+				SCSS(ms->conflast, conf_sums_next[ms->_confn]);
+				/* Really add in new value */
+				ACSS(conf_sums_next[ms->_confn], ms->conflast);
+			} else 
+				memset(ms->conflast, 0, ZT_CHUNKSIZE * sizeof(short));
+			  /* rxc unmodified */
+			break;
+		case ZT_CONF_CONFMON:
+		case ZT_CONF_CONFANNMON:
+			if (ms->confmode & ZT_CONF_TALKER) {
+				/* Store temp value */
+				memcpy(k, putlin, ZT_CHUNKSIZE * sizeof(short));
+				/* Subtract last value */
+				SCSS(conf_sums[ms->_confn], ms->conflast);
+				/* Add conf value */
+				ACSS(k, conf_sums[ms->_confn]);
+				/*  get amount actually added */
+				memcpy(ms->conflast, k, ZT_CHUNKSIZE * sizeof(short));
+				SCSS(ms->conflast, conf_sums[ms->_confn]);
+				/* Really add in new value */
+				ACSS(conf_sums[ms->_confn], ms->conflast);
+			} else 
+				memset(ms->conflast, 0, ZT_CHUNKSIZE * sizeof(short));
+			for (x=0;x<ZT_CHUNKSIZE;x++)
+				rxb[x] = ZT_LIN2X((int)conf_sums_prev[ms->_confn][x], ms);
+			break;
+		case ZT_CONF_DIGITALMON:
+			  /* if not a pseudo-channel, ignore */
+			if (!(ms->flags & ZT_FLAG_PSEUDO)) break;
+			/* Add monitored channel */
+			if (chans[ms->confna]->flags & ZT_FLAG_PSEUDO) {
+				memcpy(rxb, chans[ms->confna]->getraw, ZT_CHUNKSIZE);
+			} else {
+				memcpy(rxb, chans[ms->confna]->putraw, ZT_CHUNKSIZE);
+			}
+			break;			
+		}
+	}
+}
+
+/* HDLC (or other) receiver buffer functions for read side */
+static inline void __putbuf_chunk(struct zt_chan *ss, unsigned char *rxb, int bytes)
+{
+	/* We transmit data from our master channel */
+	/* Called with ss->lock held */
+	struct zt_chan *ms = ss->master;
+	/* Our receive buffer */
+	unsigned char *buf;
+#if defined(CONFIG_ZAPATA_NET)  || defined(CONFIG_ZAPATA_PPP)
+	/* SKB for receiving network stuff */
+	struct sk_buff *skb=NULL;
+#endif	
+	int oldbuf;
+	int eof=0;
+	int abort=0;
+	int res;
+	int left, x;
+
+	while(bytes) {
+#if defined(CONFIG_ZAPATA_NET)  || defined(CONFIG_ZAPATA_PPP)
+		skb = NULL;
+#endif	
+		abort = 0;
+		eof = 0;
+		/* Next, figure out if we've got a buffer to receive into */
+		if (ms->inreadbuf > -1) {
+			/* Read into the current buffer */
+			buf = ms->readbuf[ms->inreadbuf];
+			left = ms->blocksize - ms->readidx[ms->inreadbuf];
+			if (left > bytes)
+				left = bytes;
+			if (ms->flags & ZT_FLAG_HDLC) {
+				for (x=0;x<left;x++) {
+					/* Handle HDLC deframing */
+					fasthdlc_rx_load_nocheck(&ms->rxhdlc, *(rxb++));
+					bytes--;
+					res = fasthdlc_rx_run(&ms->rxhdlc);
+					/* If there is nothing there, continue */
+					if (res & RETURN_EMPTY_FLAG)
+						continue;
+					else if (res & RETURN_COMPLETE_FLAG) {
+						/* Only count this if it's a non-empty frame */
+						if (ms->readidx[ms->inreadbuf]) {
+							if ((ms->flags & ZT_FLAG_FCS) && (ms->infcs != PPP_GOODFCS)) {
+								abort = ZT_EVENT_BADFCS;
+							} else
+								eof=1;
+							break;
+						}
+						continue;
+					} else if (res & RETURN_DISCARD_FLAG) {
+						/* This could be someone idling with 
+						  "idle" instead of "flag" */
+						if (!ms->readidx[ms->inreadbuf])
+							continue;
+						abort = ZT_EVENT_ABORT;
+						break;
+					} else {
+						unsigned char rxc;
+						rxc = res;
+						ms->infcs = PPP_FCS(ms->infcs, rxc);
+						buf[ms->readidx[ms->inreadbuf]++] = rxc;
+						/* Pay attention to the possibility of an overrun */
+						if (ms->readidx[ms->inreadbuf] >= ms->blocksize) {
+							if (!ss->span->alarms) 
+								printk(KERN_WARNING "HDLC Receiver overrun on channel %s (master=%s)\n", ss->name, ss->master->name);
+							abort=ZT_EVENT_OVERRUN;
+							/* Force the HDLC state back to frame-search mode */
+							ms->rxhdlc.state = 0;
+							ms->rxhdlc.bits = 0;
+							ms->readidx[ms->inreadbuf]=0;
+							break;
+						}
+					}
+				}
+			} else {
+				/* Not HDLC */
+				memcpy(buf + ms->readidx[ms->inreadbuf], rxb, left);
+				rxb += left;
+				ms->readidx[ms->inreadbuf] += left;
+				bytes -= left;
+				/* End of frame is decided by block size of 'N' */
+				eof = (ms->readidx[ms->inreadbuf] >= ms->blocksize);
+				if (eof && (ss->flags & ZT_FLAG_NOSTDTXRX)) {
+					eof = 0;
+					abort = ZT_EVENT_OVERRUN;
+				}
+			}
+			if (eof)  {
+				/* Finished with this buffer, try another. */
+				oldbuf = ms->inreadbuf;
+				ms->infcs = PPP_INITFCS;
+				ms->readn[ms->inreadbuf] = ms->readidx[ms->inreadbuf];
+#ifdef CONFIG_ZAPATA_DEBUG
+				printk("EOF, len is %d\n", ms->readn[ms->inreadbuf]);
+#endif
+#if defined(CONFIG_ZAPATA_NET) || defined(CONFIG_ZAPATA_PPP)
+				if (ms->flags & (ZT_FLAG_NETDEV | ZT_FLAG_PPP)) {
+#ifdef CONFIG_ZAPATA_NET
+#endif /* CONFIG_ZAPATA_NET */
+					/* Our network receiver logic is MUCH
+					  different.  We actually only use a single
+					  buffer */
+					if (ms->readn[ms->inreadbuf] > 1) {
+						/* Drop the FCS */
+						ms->readn[ms->inreadbuf] -= 2;
+						/* Allocate an SKB */
+#ifdef CONFIG_ZAPATA_PPP
+						if (!ms->do_ppp_error)
+#endif
+							skb = dev_alloc_skb(ms->readn[ms->inreadbuf]);
+						if (skb) {
+							/* XXX Get rid of this memcpy XXX */
+							memcpy(skb->data, ms->readbuf[ms->inreadbuf], ms->readn[ms->inreadbuf]);
+							skb_put(skb, ms->readn[ms->inreadbuf]);
+#ifdef CONFIG_ZAPATA_NET
+							if (ms->flags & ZT_FLAG_NETDEV) {
+#ifdef LINUX26
+								struct net_device_stats *stats = hdlc_stats(ms->hdlcnetdev->netdev);
+#else  /* LINUX26 */
+								struct net_device_stats *stats = &ms->hdlcnetdev->netdev.stats;
+#endif /* LINUX26 */
+								stats->rx_packets++;
+								stats->rx_bytes += ms->readn[ms->inreadbuf];
+							}
+#endif
+
+						} else {
+#ifdef CONFIG_ZAPATA_NET
+							if (ms->flags & ZT_FLAG_NETDEV) {
+#ifdef LINUX26
+								struct net_device_stats *stats = hdlc_stats(ms->hdlcnetdev->netdev);
+#else  /* LINUX26 */
+								struct net_device_stats *stats = &ms->hdlcnetdev->netdev.stats;
+#endif /* LINUX26 */
+								stats->rx_dropped++;
+							}
+#endif
+#ifdef CONFIG_ZAPATA_PPP
+							if (ms->flags & ZT_FLAG_PPP) {
+								abort = ZT_EVENT_OVERRUN;
+							}
+#endif
+#if 1
+#ifdef CONFIG_ZAPATA_PPP
+							if (!ms->do_ppp_error)
+#endif
+								printk("Memory squeeze, dropped one\n");
+#endif
+						}
+					}
+					/* We don't cycle through buffers, just
+					reuse the same one */
+					ms->readn[ms->inreadbuf] = 0;
+					ms->readidx[ms->inreadbuf] = 0;
+				} else 
+#endif
+				{
+					/* This logic might confuse and astound.  Basically we need to find
+					 * the previous buffer index.  It should be safe because, regardless
+					 * of whether or not it has been copied to user space, nothing should
+					 * have messed around with it since then */
+
+					int comparemessage;
+
+					if (ms->flags & ZT_FLAG_MTP2) {
+						comparemessage = (ms->inreadbuf - 1) & (ms->numbufs - 1);
+
+						res = memcmp(ms->readbuf[comparemessage], ms->readbuf[ms->inreadbuf], ms->readn[ms->inreadbuf]);
+					}
+
+					if ((ms->flags & ZT_FLAG_MTP2) && !res) {
+						/* Our messages are the same, so discard -
+						 * 	Don't advance buffers, reset indexes and buffer sizes. */
+						ms->readn[ms->inreadbuf] = 0;
+						ms->readidx[ms->inreadbuf] = 0;
+					} else {
+						ms->inreadbuf = (ms->inreadbuf + 1) % ms->numbufs;
+						if (ms->inreadbuf == ms->outreadbuf) {
+							/* Whoops, we're full, and have no where else
+							to store into at the moment.  We'll drop it
+							until there's a buffer available */
+#ifdef CONFIG_ZAPATA_DEBUG
+							printk("Out of storage space\n");
+#endif
+							ms->inreadbuf = -1;
+							/* Enable the receiver in case they've got POLICY_WHEN_FULL */
+							ms->rxdisable = 0;
+						}
+						if (ms->outreadbuf < 0) { /* start out buffer if not already */
+							ms->outreadbuf = oldbuf;
+						}
+/* In the very orignal driver, it was quite well known to me (Jim) that there
+was a possibility that a channel sleeping on a receive block needed to
+be potentially woken up EVERY time a buffer was filled, not just on the first
+one, because if only done on the first one there is a slight timing potential
+of missing the wakeup (between where it senses the (lack of) active condition
+(with interrupts disabled) and where it does the sleep (interrupts enabled)
+in the read or iomux call, etc). That is why the read and iomux calls start
+with an infinite loop that gets broken out of upon an active condition,
+otherwise keeps sleeping and looking. The part in this code got "optimized"
+out in the later versions, and is put back now. */
+						if (!ms->rxdisable) { /* if receiver enabled */
+							/* Notify a blocked reader that there is data available
+							to be read, unless we're waiting for it to be full */
+#ifdef CONFIG_ZAPATA_DEBUG
+							printk("Notifying reader data in block %d\n", oldbuf);
+#endif
+							wake_up_interruptible(&ms->readbufq);
+							wake_up_interruptible(&ms->sel);
+							if (ms->iomask & ZT_IOMUX_READ)
+								wake_up_interruptible(&ms->eventbufq);
+						}
+					}
+				}
+			}
+			if (abort) {
+				/* Start over reading frame */
+				ms->readidx[ms->inreadbuf] = 0;
+				ms->infcs = PPP_INITFCS;
+
+#ifdef CONFIG_ZAPATA_NET
+				if (ms->flags & ZT_FLAG_NETDEV) {
+#ifdef LINUX26
+					struct net_device_stats *stats = hdlc_stats(ms->hdlcnetdev->netdev);
+#else  /* LINUX26 */
+					struct net_device_stats *stats = &ms->hdlcnetdev->netdev.stats;
+#endif /* LINUX26 */
+					stats->rx_errors++;
+					if (abort == ZT_EVENT_OVERRUN)
+						stats->rx_over_errors++;
+					if (abort == ZT_EVENT_BADFCS)
+						stats->rx_crc_errors++;
+					if (abort == ZT_EVENT_ABORT)
+						stats->rx_frame_errors++;
+				} else 
+#endif			
+#ifdef CONFIG_ZAPATA_PPP
+				if (ms->flags & ZT_FLAG_PPP) {
+					ms->do_ppp_error = 1;
+					tasklet_schedule(&ms->ppp_calls);
+				} else
+#endif
+
+				if ((ms->flags & ZT_FLAG_OPEN) && !ss->span->alarms) 
+						/* Notify the receiver... */
+					__qevent(ss->master, abort);
+#if 0
+				printk("torintr_receive: Aborted %d bytes of frame on %d\n", amt, ss->master);
+#endif
+
+			}
+		} else /* No place to receive -- drop on the floor */
+			break;
+#ifdef CONFIG_ZAPATA_NET
+		if (skb && (ms->flags & ZT_FLAG_NETDEV))
+#ifdef NEW_HDLC_INTERFACE
+		{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+			skb->mac.raw = skb->data;
+#else
+			skb_reset_mac_header(skb);
+#endif
+			skb->dev = ztchan_to_dev(ms);
+#ifdef ZAP_HDLC_TYPE_TRANS
+			skb->protocol = hdlc_type_trans(skb, ztchan_to_dev(ms));
+#else
+			skb->protocol = htons (ETH_P_HDLC);
+#endif
+			netif_rx(skb);
+		}
+#else
+			hdlc_netif_rx(&ms->hdlcnetdev->netdev, skb);
+#endif
+#endif
+#ifdef CONFIG_ZAPATA_PPP
+		if (skb && (ms->flags & ZT_FLAG_PPP)) {
+			unsigned char *tmp;
+			tmp = skb->data;
+			skb_pull(skb, 2);
+			/* Make sure that it's addressed to ALL STATIONS and UNNUMBERED */
+			if (!tmp || (tmp[0] != 0xff) || (tmp[1] != 0x03)) {
+				/* Invalid SKB -- drop */
+				if (tmp)
+					printk("Received invalid SKB (%02x, %02x)\n", tmp[0], tmp[1]);
+				dev_kfree_skb_irq(skb);
+			} else {
+				skb_queue_tail(&ms->ppp_rq, skb);
+				tasklet_schedule(&ms->ppp_calls);
+			}
+		}
+#endif
+	}
+}
+
+static inline void __zt_putbuf_chunk(struct zt_chan *ss, unsigned char *rxb)
+{
+	__putbuf_chunk(ss, rxb, ZT_CHUNKSIZE);
+}
+
+static void __zt_hdlc_abort(struct zt_chan *ss, int event)
+{
+	if (ss->inreadbuf >= 0)
+		ss->readidx[ss->inreadbuf] = 0;
+	if ((ss->flags & ZT_FLAG_OPEN) && !ss->span->alarms)
+		__qevent(ss->master, event);
+}
+
+extern void zt_hdlc_abort(struct zt_chan *ss, int event)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&ss->lock, flags);
+	__zt_hdlc_abort(ss, event);
+	spin_unlock_irqrestore(&ss->lock, flags);
+}
+
+extern void zt_hdlc_putbuf(struct zt_chan *ss, unsigned char *rxb, int bytes)
+{
+	unsigned long flags;
+	int res;
+	int left;
+
+	spin_lock_irqsave(&ss->lock, flags);
+	if (ss->inreadbuf < 0) {
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("No place to receive HDLC frame\n");
+#endif
+		spin_unlock_irqrestore(&ss->lock, flags);
+		return;
+	}
+	/* Read into the current buffer */
+	left = ss->blocksize - ss->readidx[ss->inreadbuf];
+	if (left > bytes)
+		left = bytes;
+	if (left > 0) {
+		memcpy(ss->readbuf[ss->inreadbuf] + ss->readidx[ss->inreadbuf], rxb, left);
+		rxb += left;
+		ss->readidx[ss->inreadbuf] += left;
+		bytes -= left;
+	}
+	/* Something isn't fit into buffer */
+	if (bytes) {
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("HDLC frame isn't fit into buffer space\n");
+#endif
+		__zt_hdlc_abort(ss, ZT_EVENT_OVERRUN);
+	}
+	res = left;
+	spin_unlock_irqrestore(&ss->lock, flags);
+}
+
+extern void zt_hdlc_finish(struct zt_chan *ss)
+{
+	int oldreadbuf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ss->lock, flags);
+
+	if ((oldreadbuf = ss->inreadbuf) < 0) {
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("No buffers to finish\n");
+#endif
+		spin_unlock_irqrestore(&ss->lock, flags);
+		return;
+	}
+
+	if (!ss->readidx[ss->inreadbuf]) {
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("Empty HDLC frame received\n");
+#endif
+		spin_unlock_irqrestore(&ss->lock, flags);
+		return;
+	}
+
+	ss->readn[ss->inreadbuf] = ss->readidx[ss->inreadbuf];
+	ss->inreadbuf = (ss->inreadbuf + 1) % ss->numbufs;
+	if (ss->inreadbuf == ss->outreadbuf) {
+		ss->inreadbuf = -1;
+#ifdef CONFIG_ZAPATA_DEBUG
+		printk("Notifying reader data in block %d\n", oldreadbuf);
+#endif
+		ss->rxdisable = 0;
+	}
+	if (ss->outreadbuf < 0) {
+		ss->outreadbuf = oldreadbuf;
+	}
+
+	if (!ss->rxdisable) {
+		wake_up_interruptible(&ss->readbufq);
+		wake_up_interruptible(&ss->sel);
+		if (ss->iomask & ZT_IOMUX_READ)
+			wake_up_interruptible(&ss->eventbufq);
+	}
+	spin_unlock_irqrestore(&ss->lock, flags);
+}
+
+/* Returns 1 if EOF, 0 if data is still in frame, -1 if EOF and no buffers left */
+extern int zt_hdlc_getbuf(struct zt_chan *ss, unsigned char *bufptr, unsigned int *size)
+{
+	unsigned char *buf;
+	unsigned long flags;
+	int left = 0;
+	int res;
+	int oldbuf;
+
+	spin_lock_irqsave(&ss->lock, flags);
+	if (ss->outwritebuf > -1) {
+		buf = ss->writebuf[ss->outwritebuf];
+		left = ss->writen[ss->outwritebuf] - ss->writeidx[ss->outwritebuf];
+		/* Strip off the empty HDLC CRC end */
+		left -= 2;
+		if (left <= *size) {
+			*size = left;
+			res = 1;
+		} else
+			res = 0;
+
+		memcpy(bufptr, &buf[ss->writeidx[ss->outwritebuf]], *size);
+		ss->writeidx[ss->outwritebuf] += *size;
+
+		if (res) {
+			/* Rotate buffers */
+			oldbuf = ss->outwritebuf;
+			ss->writeidx[oldbuf] = 0;
+			ss->writen[oldbuf] = 0;
+			ss->outwritebuf = (ss->outwritebuf + 1) % ss->numbufs;
+			if (ss->outwritebuf == ss->inwritebuf) {
+				ss->outwritebuf = -1;
+				if (ss->iomask & (ZT_IOMUX_WRITE | ZT_IOMUX_WRITEEMPTY))
+					wake_up_interruptible(&ss->eventbufq);
+				/* If we're only supposed to start when full, disable the transmitter */
+				if (ss->txbufpolicy == ZT_POLICY_WHEN_FULL)
+					ss->txdisable = 1;
+				res = -1;
+			}
+
+			if (ss->inwritebuf < 0)
+				ss->inwritebuf = oldbuf;
+
+			if (!(ss->flags & (ZT_FLAG_NETDEV | ZT_FLAG_PPP))) {
+				wake_up_interruptible(&ss->writebufq);
+				wake_up_interruptible(&ss->sel);
+				if ((ss->iomask & ZT_IOMUX_WRITE) && (res >= 0))
+					wake_up_interruptible(&ss->eventbufq);
+			}
+		}
+	} else {
+		res = -1;
+		*size = 0;
+	}
+	spin_unlock_irqrestore(&ss->lock, flags);
+
+	return res;
+}
+
+
+static void process_timers(void)
+{
+	unsigned long flags;
+	struct zt_timer *cur;
+	spin_lock_irqsave(&zaptimerlock, flags);
+	cur = zaptimers;
+	while(cur) {
+		if (cur->ms) {
+			cur->pos -= ZT_CHUNKSIZE;
+			if (cur->pos <= 0) {
+				cur->tripped++;
+				cur->pos = cur->ms;
+				wake_up_interruptible(&cur->sel);
+			}
+		}
+		cur = cur->next;
+	}
+	spin_unlock_irqrestore(&zaptimerlock, flags);
+}
+
+static unsigned int zt_timer_poll(struct file *file, struct poll_table_struct *wait_table)
+{
+	struct zt_timer *timer = file->private_data;
+	unsigned long flags;
+	int ret = 0;
+	if (timer) {
+		poll_wait(file, &timer->sel, wait_table);
+		spin_lock_irqsave(&zaptimerlock, flags);
+		if (timer->tripped || timer->ping) 
+			ret |= POLLPRI;
+		spin_unlock_irqrestore(&zaptimerlock, flags);
+	} else
+		ret = -EINVAL;
+	return ret;
+}
+
+/* device poll routine */
+static unsigned int
+zt_chan_poll(struct file *file, struct poll_table_struct *wait_table, int unit)
+{   
+	
+	struct zt_chan *chan = chans[unit];
+	int	ret;
+	unsigned long flags;
+
+	  /* do the poll wait */
+	if (chan) {
+		poll_wait(file, &chan->sel, wait_table);
+		ret = 0; /* start with nothing to return */
+		spin_lock_irqsave(&chan->lock, flags);
+		   /* if at least 1 write buffer avail */
+		if (chan->inwritebuf > -1) {
+			ret |= POLLOUT | POLLWRNORM;
+		}
+		if ((chan->outreadbuf > -1) && !chan->rxdisable) {
+			ret |= POLLIN | POLLRDNORM;
+		}
+		if (chan->eventoutidx != chan->eventinidx)
+		   {
+			/* Indicate an exception */
+			ret |= POLLPRI;
+		   }
+		spin_unlock_irqrestore(&chan->lock, flags);
+	} else
+		ret = -EINVAL;
+	return(ret);  /* return what we found */
+}
+
+static int zt_mmap(struct file *file, struct vm_area_struct *vm)
+{
+	int unit = UNIT(file);
+	if (unit == 250)
+		return zt_transcode_fops->mmap(file, vm);
+	return -ENOSYS;
+}
+
+static unsigned int zt_poll(struct file *file, struct poll_table_struct *wait_table)
+{
+	int unit = UNIT(file);
+	struct zt_chan *chan;
+
+	if (!unit)
+		return -EINVAL;
+
+	if (unit == 250)
+		return zt_transcode_fops->poll(file, wait_table);
+
+	if (unit == 253)
+		return zt_timer_poll(file, wait_table);
+		
+	if (unit == 254) {
+		chan = file->private_data;
+		if (!chan)
+			return -EINVAL;
+		return zt_chan_poll(file, wait_table,chan->channo);
+	}
+	if (unit == 255) {
+		chan = file->private_data;
+		if (!chan) {
+			printk("No pseudo channel structure to read?\n");
+			return -EINVAL;
+		}
+		return zt_chan_poll(file, wait_table, chan->channo);
+	}
+	return zt_chan_poll(file, wait_table, unit);
+}
+
+static void __zt_transmit_chunk(struct zt_chan *chan, unsigned char *buf)
+{
+	unsigned char silly[ZT_CHUNKSIZE];
+	/* Called with chan->lock locked */
+#ifdef	OPTIMIZE_CHANMUTE
+	if(likely(chan->chanmute))
+		return;
+#endif
+	if (!buf)
+		buf = silly;
+	__zt_getbuf_chunk(chan, buf);
+
+	if ((chan->flags & ZT_FLAG_AUDIO) || (chan->confmode)) {
+#ifdef CONFIG_ZAPTEL_MMX
+		zt_kernel_fpu_begin();
+#endif
+		__zt_process_getaudio_chunk(chan, buf);
+#ifdef CONFIG_ZAPTEL_MMX
+		kernel_fpu_end();
+#endif
+	}
+}
+
+static inline void __zt_real_transmit(struct zt_chan *chan)
+{
+	/* Called with chan->lock held */
+#ifdef	OPTIMIZE_CHANMUTE
+	if(likely(chan->chanmute))
+		return;
+#endif
+	if (chan->confmode) {
+		/* Pull queued data off the conference */
+		__buf_pull(&chan->confout, chan->writechunk, chan, "zt_real_transmit");
+	} else {
+		__zt_transmit_chunk(chan, chan->writechunk);
+	}
+}
+
+static void __zt_getempty(struct zt_chan *ms, unsigned char *buf)
+{
+	int bytes = ZT_CHUNKSIZE;
+	int left;
+	unsigned char *txb = buf;
+	int x;
+	short getlin;
+	/* Called with ms->lock held */
+
+	while(bytes) {
+		/* Receive silence, or tone */
+		if (ms->curtone) {
+			left = ms->curtone->tonesamples - ms->tonep;
+			if (left > bytes)
+				left = bytes;
+			for (x=0;x<left;x++) {
+				/* Pick our default value from the next sample of the current tone */
+				getlin = zt_tone_nextsample(&ms->ts, ms->curtone);
+				*(txb++) = ZT_LIN2X(getlin, ms);
+			}
+			ms->tonep+=left;
+			bytes -= left;
+			if (ms->tonep >= ms->curtone->tonesamples) {
+				struct zt_tone *last;
+				/* Go to the next sample of the tone */
+				ms->tonep = 0;
+				last = ms->curtone;
+				ms->curtone = ms->curtone->next;
+				if (!ms->curtone) {
+					/* No more tones...  Is this dtmf or mf?  If so, go to the next digit */
+					if (ms->dialing)
+						__do_dtmf(ms);
+				} else {
+					if (last != ms->curtone)
+						zt_init_tone_state(&ms->ts, ms->curtone);
+				}
+			}
+		} else {
+			/* Use silence */
+			memset(txb, ZT_LIN2X(0, ms), bytes);
+			bytes = 0;
+		}
+	}
+		
+}
+
+static void __zt_receive_chunk(struct zt_chan *chan, unsigned char *buf)
+{
+	/* Receive chunk of audio -- called with chan->lock held */
+	unsigned char waste[ZT_CHUNKSIZE];
+
+#ifdef	OPTIMIZE_CHANMUTE
+	if(likely(chan->chanmute))
+		return;
+#endif
+	if (!buf) {
+		memset(waste, ZT_LIN2X(0, chan), sizeof(waste));
+		buf = waste;
+	}
+	if ((chan->flags & ZT_FLAG_AUDIO) || (chan->confmode)) {
+#ifdef CONFIG_ZAPTEL_MMX                         
+		zt_kernel_fpu_begin();
+#endif
+		__zt_process_putaudio_chunk(chan, buf);
+#ifdef CONFIG_ZAPTEL_MMX
+		kernel_fpu_end();
+#endif
+	}
+	__zt_putbuf_chunk(chan, buf);
+}
+
+static inline void __zt_real_receive(struct zt_chan *chan)
+{
+	/* Called with chan->lock held */
+#ifdef	OPTIMIZE_CHANMUTE
+	if(likely(chan->chanmute))
+		return;
+#endif
+	if (chan->confmode) {
+		/* Load into queue if we have space */
+		__buf_push(&chan->confin, chan->readchunk, "zt_real_receive");
+	} else {
+		__zt_receive_chunk(chan, chan->readchunk);
+	}
+}
+
+int zt_transmit(struct zt_span *span)
+{
+	int x,y,z;
+	unsigned long flags;
+
+#if 1
+	for (x=0;x<span->channels;x++) {
+		spin_lock_irqsave(&span->chans[x].lock, flags);
+		if (span->chans[x].flags & ZT_FLAG_NOSTDTXRX) {
+			spin_unlock_irqrestore(&span->chans[x].lock, flags);
+			continue;
+		}
+		if (&span->chans[x] == span->chans[x].master) {
+			if (span->chans[x].otimer) {
+				span->chans[x].otimer -= ZT_CHUNKSIZE;
+				if (span->chans[x].otimer <= 0) {
+					__rbs_otimer_expire(&span->chans[x]);
+				}
+			}
+			if (span->chans[x].flags & ZT_FLAG_AUDIO) {
+				__zt_real_transmit(&span->chans[x]);
+			} else {
+				if (span->chans[x].nextslave) {
+					u_char data[ZT_CHUNKSIZE];
+					int pos=ZT_CHUNKSIZE;
+					/* Process master/slaves one way */
+					for (y=0;y<ZT_CHUNKSIZE;y++) {
+						/* Process slaves for this byte too */
+						z = x;
+						do {
+							if (pos==ZT_CHUNKSIZE) {
+								/* Get next chunk */
+								__zt_transmit_chunk(&span->chans[x], data);
+								pos = 0;
+							}
+							span->chans[z].writechunk[y] = data[pos++]; 
+							z = span->chans[z].nextslave;
+						} while(z);
+					}
+				} else {
+					/* Process independents elsewise */
+					__zt_real_transmit(&span->chans[x]);
+				}
+			}
+			if (span->chans[x].sig == ZT_SIG_DACS_RBS) {
+				if (chans[span->chans[x].confna]) {
+				    	/* Just set bits for our destination */
+					if (span->chans[x].txsig != chans[span->chans[x].confna]->rxsig) {
+						span->chans[x].txsig = chans[span->chans[x].confna]->rxsig;
+						span->rbsbits(&span->chans[x], chans[span->chans[x].confna]->rxsig);
+					}
+				}
+			}
+
+		}
+		spin_unlock_irqrestore(&span->chans[x].lock, flags);
+	}
+	if (span->mainttimer) {
+		span->mainttimer -= ZT_CHUNKSIZE;
+		if (span->mainttimer <= 0) {
+			span->mainttimer = 0;
+			if (span->maint)
+				span->maint(span, ZT_MAINT_LOOPSTOP);
+			span->maintstat = 0;
+			wake_up_interruptible(&span->maintq);
+		}
+	}
+#endif
+	return 0;
+}
+
+int zt_receive(struct zt_span *span)
+{
+	int x,y,z;
+	unsigned long flags, flagso;
+
+#if 1
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+	span->watchcounter--;
+#endif	
+	for (x=0;x<span->channels;x++) {
+		if (span->chans[x].master == &span->chans[x]) {
+			spin_lock_irqsave(&span->chans[x].lock, flags);
+			if (span->chans[x].nextslave) {
+				/* Must process each slave at the same time */
+				u_char data[ZT_CHUNKSIZE];
+				int pos = 0;
+				for (y=0;y<ZT_CHUNKSIZE;y++) {
+					/* Put all its slaves, too */
+					z = x;
+					do {
+						data[pos++] = span->chans[z].readchunk[y];
+						if (pos == ZT_CHUNKSIZE) {
+							if(!(span->chans[x].flags & ZT_FLAG_NOSTDTXRX))
+								__zt_receive_chunk(&span->chans[x], data);
+							pos = 0;
+						}
+						z=span->chans[z].nextslave;
+					} while(z);
+				}
+			} else {
+				/* Process a normal channel */
+				if (!(span->chans[x].flags & ZT_FLAG_NOSTDTXRX))
+					__zt_real_receive(&span->chans[x]);
+			}
+			if (span->chans[x].itimer) {
+				span->chans[x].itimer -= ZT_CHUNKSIZE;
+				if (span->chans[x].itimer <= 0) {
+					rbs_itimer_expire(&span->chans[x]);
+				}
+			}
+			if (span->chans[x].ringdebtimer)
+				span->chans[x].ringdebtimer--;
+			if (span->chans[x].sig & __ZT_SIG_FXS) {
+				if (span->chans[x].rxhooksig == ZT_RXSIG_RING)
+					span->chans[x].ringtrailer = ZT_RINGTRAILER;
+				else if (span->chans[x].ringtrailer) {
+					span->chans[x].ringtrailer-= ZT_CHUNKSIZE;
+					/* See if RING trailer is expired */
+					if (!span->chans[x].ringtrailer && !span->chans[x].ringdebtimer) 
+						__qevent(&span->chans[x],ZT_EVENT_RINGOFFHOOK);
+				}
+			}
+			if (span->chans[x].pulsetimer)
+			{
+				span->chans[x].pulsetimer--;
+				if (span->chans[x].pulsetimer <= 0)
+				{
+					if (span->chans[x].pulsecount)
+					{
+						if (span->chans[x].pulsecount > 12) {
+						
+							printk("Got pulse digit %d on %s???\n",
+						    span->chans[x].pulsecount,
+							span->chans[x].name);
+						} else if (span->chans[x].pulsecount > 11) {
+							__qevent(&span->chans[x], ZT_EVENT_PULSEDIGIT | '#');
+						} else if (span->chans[x].pulsecount > 10) {
+							__qevent(&span->chans[x], ZT_EVENT_PULSEDIGIT | '*');
+						} else if (span->chans[x].pulsecount > 9) {
+							__qevent(&span->chans[x], ZT_EVENT_PULSEDIGIT | '0');
+						} else {
+							__qevent(&span->chans[x], ZT_EVENT_PULSEDIGIT | ('0' + 
+								span->chans[x].pulsecount));
+						}
+						span->chans[x].pulsecount = 0;
+					}
+				}
+			}
+			spin_unlock_irqrestore(&span->chans[x].lock, flags);
+		}
+	}
+
+	if (span == master) {
+		/* Hold the big zap lock for the duration of major
+		   activities which touch all sorts of channels */
+		spin_lock_irqsave(&bigzaplock, flagso);			
+		/* Process any timers */
+		process_timers();
+		/* If we have dynamic stuff, call the ioctl with 0,0 parameters to
+		   make it run */
+		if (zt_dynamic_ioctl)
+			zt_dynamic_ioctl(0,0);
+		for (x=1;x<maxchans;x++) {
+			if (chans[x] && chans[x]->confmode && !(chans[x]->flags & ZT_FLAG_PSEUDO)) {
+				u_char *data;
+				spin_lock_irqsave(&chans[x]->lock, flags);
+				data = __buf_peek(&chans[x]->confin);
+				__zt_receive_chunk(chans[x], data);
+				if (data)
+					__buf_pull(&chans[x]->confin, NULL,chans[x], "confreceive");
+				spin_unlock_irqrestore(&chans[x]->lock, flags);
+			}
+		}
+		/* This is the master channel, so make things switch over */
+		rotate_sums();
+		/* do all the pseudo and/or conferenced channel receives (getbuf's) */
+		for (x=1;x<maxchans;x++) {
+			if (chans[x] && (chans[x]->flags & ZT_FLAG_PSEUDO)) {
+				spin_lock_irqsave(&chans[x]->lock, flags);
+				__zt_transmit_chunk(chans[x], NULL);
+				spin_unlock_irqrestore(&chans[x]->lock, flags);
+			}
+		}
+		if (maxlinks) {
+#ifdef CONFIG_ZAPTEL_MMX
+			zt_kernel_fpu_begin();
+#endif			
+			  /* process all the conf links */
+			for(x = 1; x <= maxlinks; x++) {
+				  /* if we have a destination conf */
+				if (((z = confalias[conf_links[x].dst]) > 0) &&
+				    ((y = confalias[conf_links[x].src]) > 0)) {
+					ACSS(conf_sums[z], conf_sums[y]);
+				}
+			}
+#ifdef CONFIG_ZAPTEL_MMX
+			kernel_fpu_end();
+#endif			
+		}
+		/* do all the pseudo/conferenced channel transmits (putbuf's) */
+		for (x=1;x<maxchans;x++) {
+			if (chans[x] && (chans[x]->flags & ZT_FLAG_PSEUDO)) {
+				unsigned char tmp[ZT_CHUNKSIZE];
+				spin_lock_irqsave(&chans[x]->lock, flags);
+				__zt_getempty(chans[x], tmp);
+				__zt_receive_chunk(chans[x], tmp);
+				spin_unlock_irqrestore(&chans[x]->lock, flags);
+			}
+		}
+		for (x=1;x<maxchans;x++) {
+			if (chans[x] && chans[x]->confmode && !(chans[x]->flags & ZT_FLAG_PSEUDO)) {
+				u_char *data;
+				spin_lock_irqsave(&chans[x]->lock, flags);
+				data = __buf_pushpeek(&chans[x]->confout);
+				__zt_transmit_chunk(chans[x], data);
+				if (data)
+					__buf_push(&chans[x]->confout, NULL, "conftransmit");
+				spin_unlock_irqrestore(&chans[x]->lock, flags);
+			}
+		}
+#ifdef	ZAPTEL_SYNC_TICK
+		for (x=0;x<maxspans;x++) {
+			struct zt_span	*s = spans[x];
+
+			if (s && s->sync_tick)
+				s->sync_tick(s, s == master);
+		}
+#endif
+		spin_unlock_irqrestore(&bigzaplock, flagso);			
+	}
+#endif
+	return 0;
+}
+
+MODULE_AUTHOR("Mark Spencer <markster@digium.com>");
+MODULE_DESCRIPTION("Zapata Telephony Interface");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+#ifdef MODULE_VERSION
+MODULE_VERSION(ZAPTEL_VERSION);
+#endif
+
+#ifdef LINUX26
+module_param(debug, int, 0644);
+module_param(deftaps, int, 0644);
+#else
+MODULE_PARM(debug, "i");
+MODULE_PARM(deftaps, "i");
+#endif
+
+static struct file_operations zt_fops = {
+	owner: THIS_MODULE,
+	llseek: NULL,
+	open: zt_open,
+	release: zt_release,
+	ioctl: zt_ioctl,
+	read: zt_read,
+	write: zt_write,
+	poll: zt_poll,
+	mmap: zt_mmap,
+	flush: NULL,
+	fsync: NULL,
+	fasync: NULL,
+};
+
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+static struct timer_list watchdogtimer;
+
+static void watchdog_check(unsigned long ignored)
+{
+	int x;
+	unsigned long flags;
+	static int wdcheck=0;
+	
+	local_irq_save(flags);
+	for (x=0;x<maxspans;x++) {
+		if (spans[x] && (spans[x]->flags & ZT_FLAG_RUNNING)) {
+			if (spans[x]->watchcounter == ZT_WATCHDOG_INIT) {
+				/* Whoops, dead card */
+				if ((spans[x]->watchstate == ZT_WATCHSTATE_OK) || 
+					(spans[x]->watchstate == ZT_WATCHSTATE_UNKNOWN)) {
+					spans[x]->watchstate = ZT_WATCHSTATE_RECOVERING;
+					if (spans[x]->watchdog) {
+						printk("Kicking span %s\n", spans[x]->name);
+						spans[x]->watchdog(spans[x], ZT_WATCHDOG_NOINTS);
+					} else {
+						printk("Span %s is dead with no revival\n", spans[x]->name);
+						spans[x]->watchstate = ZT_WATCHSTATE_FAILED;
+					}
+				}
+			} else {
+				if ((spans[x]->watchstate != ZT_WATCHSTATE_OK) &&
+					(spans[x]->watchstate != ZT_WATCHSTATE_UNKNOWN))
+						printk("Span %s is alive!\n", spans[x]->name);
+				spans[x]->watchstate = ZT_WATCHSTATE_OK;
+			}
+			spans[x]->watchcounter = ZT_WATCHDOG_INIT;
+		}
+	}
+	local_irq_restore(flags);
+	if (!wdcheck) {
+		printk("Zaptel watchdog on duty!\n");
+		wdcheck=1;
+	}
+	mod_timer(&watchdogtimer, jiffies + 2);
+}
+
+static int __init watchdog_init(void)
+{
+	init_timer(&watchdogtimer);
+	watchdogtimer.expires = 0;
+	watchdogtimer.data =0;
+	watchdogtimer.function = watchdog_check;
+	/* Run every couple of jiffy or so */
+	mod_timer(&watchdogtimer, jiffies + 2);
+	return 0;
+}
+
+static void __exit watchdog_cleanup(void)
+{
+	del_timer(&watchdogtimer);
+}
+
+#endif
+
+int zt_register_chardev(struct zt_chardev *dev)
+{
+#ifdef CONFIG_DEVFS_FS
+	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+#endif /* CONFIG_DEVFS_FS */
+
+#ifdef CONFIG_ZAP_UDEV
+	char udevname[strlen(dev->name) + 3];
+
+	strcpy(udevname, "zap");
+	strcat(udevname, dev->name);
+	CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, dev->minor), NULL, udevname);
+#endif /* CONFIG_ZAP_UDEV */
+	
+#ifdef CONFIG_DEVFS_FS
+	dev->devfs_handle = devfs_register(zaptel_devfs_dir, dev->name, DEVFS_FL_DEFAULT, ZT_MAJOR, dev->minor, mode, &zt_fops, NULL);
+#endif /* CONFIG_DEVFS_FS */
+
+	return 0;
+}
+
+int zt_unregister_chardev(struct zt_chardev *dev)
+{
+#ifdef CONFIG_ZAP_UDEV
+	class_device_destroy(zap_class, MKDEV(ZT_MAJOR, dev->minor));
+#endif /* CONFIG_ZAP_UDEV */
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_unregister(dev->devfs_handle);
+#endif /* CONFIG_DEVFS_FS */
+
+	return 0;
+}
+
+static int __init zt_init(void) {
+	int res = 0;
+
+#ifdef CONFIG_PROC_FS
+	proc_entries[0] = proc_mkdir("zaptel", NULL);
+#endif
+
+#ifdef CONFIG_ZAP_UDEV /* udev support functions */
+	zap_class = class_create(THIS_MODULE, "zaptel");
+	CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, 253), NULL, "zaptimer");
+	CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, 254), NULL, "zapchannel");
+	CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, 255), NULL, "zappseudo");
+	CLASS_DEV_CREATE(zap_class, MKDEV(ZT_MAJOR, 0), NULL, "zapctl");
+#endif /* CONFIG_ZAP_UDEV */
+
+#ifdef CONFIG_DEVFS_FS
+	{
+		umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+
+		devfs_register_chrdev(ZT_MAJOR, "zaptel", &zt_fops);
+		if (!(zaptel_devfs_dir = devfs_mk_dir(NULL, "zap", NULL)))
+			return -EBUSY; /* This would be bad */
+		timer = devfs_register(zaptel_devfs_dir, "timer", DEVFS_FL_DEFAULT, ZT_MAJOR, 253, mode, &zt_fops, NULL);
+		channel = devfs_register(zaptel_devfs_dir, "channel", DEVFS_FL_DEFAULT, ZT_MAJOR, 254, mode, &zt_fops, NULL);
+		pseudo = devfs_register(zaptel_devfs_dir, "pseudo", DEVFS_FL_DEFAULT, ZT_MAJOR, 255, mode, &zt_fops, NULL);
+		ctl = devfs_register(zaptel_devfs_dir, "ctl", DEVFS_FL_DEFAULT, ZT_MAJOR, 0, mode, &zt_fops, NULL);
+	}
+#else
+	if ((res = register_chrdev(ZT_MAJOR, "zaptel", &zt_fops))) {
+		printk(KERN_ERR "Unable to register Zaptel character device handler on %d\n", ZT_MAJOR);
+		return res;
+	}
+#endif /* CONFIG_DEVFS_FS */
+
+	printk(KERN_INFO "Zapata Telephony Interface Registered on major %d\n", ZT_MAJOR);
+	printk(KERN_INFO "Zaptel Version: %s\n", ZAPTEL_VERSION);
+	echo_can_init();
+	zt_conv_init();
+	fasthdlc_precalc();
+	rotate_sums();
+	rwlock_init(&chan_lock);
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+	watchdog_init();
+#endif	
+	return res;
+}
+
+static void __exit zt_cleanup(void) {
+	int x;
+
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("zaptel", NULL);
+#endif
+
+	printk(KERN_INFO "Zapata Telephony Interface Unloaded\n");
+	for (x = 0; x < ZT_TONE_ZONE_MAX; x++) {
+		if (tone_zones[x])
+			kfree(tone_zones[x]);
+	}
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_unregister(timer);
+	devfs_unregister(channel);
+	devfs_unregister(pseudo);
+	devfs_unregister(ctl);
+	devfs_unregister(zaptel_devfs_dir);
+	devfs_unregister_chrdev(ZT_MAJOR, "zaptel");
+#else
+#ifdef CONFIG_ZAP_UDEV
+	class_device_destroy(zap_class, MKDEV(ZT_MAJOR, 253)); /* timer */
+	class_device_destroy(zap_class, MKDEV(ZT_MAJOR, 254)); /* channel */
+	class_device_destroy(zap_class, MKDEV(ZT_MAJOR, 255)); /* pseudo */
+	class_device_destroy(zap_class, MKDEV(ZT_MAJOR, 0)); /* ctl */
+	class_destroy(zap_class);
+#endif /* CONFIG_ZAP_UDEV */
+	unregister_chrdev(ZT_MAJOR, "zaptel");
+#endif
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+	watchdog_cleanup();
+#endif
+
+	echo_can_shutdown();
+}
+
+module_init(zt_init);
+module_exit(zt_cleanup);
diff -urN zaptel-1.4.11.org/kernel/zaptel.h zaptel-1.4.11/kernel/zaptel.h
--- zaptel-1.4.11.org/kernel/zaptel.h	2008-05-12 19:28:24.000000000 +0200
+++ zaptel-1.4.11/kernel/zaptel.h	2008-07-16 22:06:17.201145996 +0200
@@ -1314,6 +1314,13 @@
 	int do_ppp_error;
 	struct sk_buff_head ppp_rq;
 #endif
+#ifdef CONFIG_ZAPATA_BRI_DCHANS
+	int bytes2receive;
+	int maxbytes2transmit; /* size of the tx buffer in the card driver */
+	int bytes2transmit;
+	int eofrx;
+	int eoftx;
+#endif
 	spinlock_t lock;
 	char name[40];		/* Name */
 	/* Specified by zaptel */
@@ -1582,6 +1589,10 @@
 	ZT_FLAGBIT_MTP2       = 19,
 };
 
+#if defined(CONFIG_ZAPATA_BRI_DCHANS)
+#define ZT_FLAG_BRIDCHAN		(1 << 19)
+#endif
+
 struct zt_span {
 	spinlock_t lock;
 	void *pvt;			/* Private stuff */
@@ -1698,6 +1709,10 @@
 	int watchcounter;
 	int watchstate;
 #endif	
+#ifdef CONFIG_PROC_FS
+	/* Allow subordinate drivers to print out their own stuff */
+	int (*proc_read)(struct zt_span *span, char *start);
+#endif
 };
 
 struct zt_transcoder_channel {
@@ -1833,6 +1848,9 @@
 /* Notify a change possible change in alarm status on a span */
 void zt_alarm_notify(struct zt_span *span);
 
+/* Notify a change possible change in alarm status, DONT change the zaptel master! */
+extern void zt_alarm_notify_no_master_change(struct zt_span *span);
+
 /* Initialize a tone state */
 void zt_init_tone_state(struct zt_tone_state *ts, struct zt_tone *zt);
 
diff -urN zaptel-1.4.11.org/kernel/zaptel.h.orig zaptel-1.4.11/kernel/zaptel.h.orig
--- zaptel-1.4.11.org/kernel/zaptel.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zaptel.h.orig	2008-07-16 22:06:17.204532637 +0200
@@ -0,0 +1,2107 @@
+/*
+ * Zapata Telephony Interface
+ *
+ * Written by Mark Spencer <markster@linux-suppot.net>
+ * Based on previous works, designs, and architectures conceived and
+ * written by Jim Dixon <jim@lambdatel.com>.
+ *
+ * Copyright (C) 2001 Jim Dixon / Zapata Telephony.
+ * Copyright (C) 2001 - 2006 Digium, Inc.
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ */
+
+#ifndef _LINUX_ZAPTEL_H
+#define _LINUX_ZAPTEL_H
+
+#ifdef __KERNEL__
+#include "zconfig.h"
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include <linux/config.h>
+#endif
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+
+#ifdef CONFIG_ZAPATA_NET	
+#include <linux/hdlc.h>
+#endif
+
+#ifdef CONFIG_ZAPATA_PPP
+#include <linux/ppp_channel.h>
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+#define zap_pci_module pci_register_driver
+#else
+#define zap_pci_module pci_module_init
+#endif
+
+#ifdef LINUX26
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+#define ZAP_IRQ_HANDLER(a) static irqreturn_t a(int irq, void *dev_id)
+#else
+#define ZAP_IRQ_HANDLER(a) static irqreturn_t a(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+#else
+#define ZAP_IRQ_HANDLER(a) static void a(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#define ZAP_IRQ_SHARED IRQF_SHARED
+#define ZAP_IRQ_DISABLED IRQF_DISABLED
+#define ZAP_IRQ_SHARED_DISABLED IRQF_SHARED | IRQF_DISABLED
+#else
+#define ZAP_IRQ_SHARED SA_SHIRQ
+#define ZAP_IRQ_DISABLED SA_INTERRUPT
+#define ZAP_IRQ_SHARED_DISABLED SA_SHIRQ | SA_INTERRUPT
+#endif
+
+#include "ecdis.h"
+#include "fasthdlc.h"
+
+#ifdef CONFIG_DEVFS_FS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/devfs_fs_kernel.h>
+#else
+#undef CONFIG_DEVFS_FS
+//#warning "Zaptel doesn't support DEVFS in post 2.4 kernels.  Disabling DEVFS in zaptel"
+#endif
+#endif /* CONFIG_DEVFS_FS */
+#endif /* __KERNEL__ */
+
+#include <linux/types.h>
+
+#ifndef ELAST
+#define ELAST 500
+#endif
+
+/* Per-span configuration values */
+#define	ZT_CONFIG_TXLEVEL	7	/* bits 0-2 are tx level */
+
+/* Line configuration */
+/* These apply to T1 */
+#define ZT_CONFIG_D4	 (1 << 4)	
+#define ZT_CONFIG_ESF	 (1 << 5)
+#define ZT_CONFIG_AMI	 (1 << 6)
+#define ZT_CONFIG_B8ZS 	 (1 << 7)
+/* These apply to E1 */
+#define	ZT_CONFIG_CCS	 (1 << 8)	/* CCS (ISDN) instead of CAS (Robbed Bit) */
+#define	ZT_CONFIG_HDB3	 (1 << 9)	/* HDB3 instead of AMI (line coding) */
+#define	ZT_CONFIG_CRC4   (1 << 10)	/* CRC4 framing */
+#define ZT_CONFIG_NOTOPEN (1 << 16)
+
+/* Signalling types */
+#define ZT_SIG_BROKEN	(1 << 31)	/* The port is broken and/or failed initialization */
+
+#define __ZT_SIG_FXO	(1 << 12)	/* Never use directly */
+#define __ZT_SIG_FXS	(1 << 13)	/* Never use directly */
+
+#define ZT_SIG_NONE		(0)			/* Channel not configured */
+#define ZT_SIG_FXSLS	((1 << 0) | __ZT_SIG_FXS)	/* FXS, Loopstart */
+#define ZT_SIG_FXSGS	((1 << 1) | __ZT_SIG_FXS)	/* FXS, Groundstart */
+#define ZT_SIG_FXSKS	((1 << 2) | __ZT_SIG_FXS)	/* FXS, Kewlstart */
+
+#define ZT_SIG_FXOLS	((1 << 3) | __ZT_SIG_FXO)	/* FXO, Loopstart */
+#define ZT_SIG_FXOGS	((1 << 4) | __ZT_SIG_FXO)	/* FXO, Groupstart */
+#define ZT_SIG_FXOKS	((1 << 5) | __ZT_SIG_FXO)	/* FXO, Kewlstart */
+
+#define ZT_SIG_EM	(1 << 6)		/* Ear & Mouth (E&M) */
+
+/* The following are all variations on clear channel */
+
+#define __ZT_SIG_DACS	(1 << 16)
+
+#define ZT_SIG_CLEAR	(1 << 7)					/* Clear channel */
+#define ZT_SIG_HDLCRAW	((1 << 8)  | ZT_SIG_CLEAR)	/* Raw unchecked HDLC */
+#define ZT_SIG_HDLCFCS	((1 << 9)  | ZT_SIG_HDLCRAW)	/* HDLC with FCS calculation */
+#define ZT_SIG_HDLCNET	((1 << 10) | ZT_SIG_HDLCFCS)	/* HDLC Network */
+#define ZT_SIG_SLAVE	(1 << 11) 					/* Slave to another channel */
+#define	ZT_SIG_SF	(1 << 14)			/* Single Freq. tone only, no sig bits */
+#define ZT_SIG_CAS	(1 << 15)			/* Just get bits */
+#define ZT_SIG_DACS	(__ZT_SIG_DACS | ZT_SIG_CLEAR)	/* Cross connect */
+#define ZT_SIG_EM_E1	(1 << 17)			/* E1 E&M Variation */
+#define ZT_SIG_DACS_RBS	((1 << 18) | __ZT_SIG_DACS)	/* Cross connect w/ RBS */
+#define ZT_SIG_HARDHDLC	((1 << 19) | ZT_SIG_CLEAR)
+#define ZT_SIG_MTP2	((1 << 20) | ZT_SIG_HDLCFCS)	/* MTP2 support  Need HDLC bitstuff and FCS calcuation too */
+
+/* tone flag values */
+#define	ZT_REVERSE_RXTONE 1  /* reverse polarity rx tone logic */
+#define	ZT_REVERSE_TXTONE 2  /* reverse polarity tx tone logic */
+
+#define ZT_ABIT			8
+#define ZT_BBIT			4
+#define	ZT_CBIT			2
+#define	ZT_DBIT			1
+
+#define ZT_MAJOR	196
+
+#define ZT_CODE	'J'
+
+/* Default chunk size for conferences and such -- static right now, might make
+   variable sometime.  8 samples = 1 ms = most frequent service interval possible
+   for a USB device */
+#define ZT_CHUNKSIZE		 8
+#define ZT_MIN_CHUNKSIZE	 ZT_CHUNKSIZE
+#define ZT_DEFAULT_CHUNKSIZE	 ZT_CHUNKSIZE
+#define ZT_MAX_CHUNKSIZE 	 ZT_CHUNKSIZE
+#define ZT_CB_SIZE		 2
+
+#define ZT_MAX_BLOCKSIZE 	 8192
+#define ZT_DEFAULT_NUM_BUFS	 2
+#define ZT_MAX_NUM_BUFS		 32
+#define ZT_MAX_BUF_SPACE         32768
+
+#define ZT_DEFAULT_BLOCKSIZE 1024
+#define ZT_DEFAULT_MTR_MRU	 2048
+
+#define ZT_POLICY_IMMEDIATE	 0		/* Start play/record immediately */
+#define ZT_POLICY_WHEN_FULL  1		/* Start play/record when buffer is full */
+
+#define	RING_DEBOUNCE_TIME	2000	/* 2000 ms ring debounce time */
+
+#define ZT_GET_PARAMS_RETURN_MASTER 0x40000000
+
+/* Extended attributes in lineconfig structure */
+#define ZT_SPANINFO_HAS_LINECONFIG
+#define ZT_SPANINFO_HAS_LBONAME
+
+struct zt_params_v1
+{
+	int channo;		/* Channel number */
+	int spanno;		/* Span itself */
+	int chanpos;		/* Channel number in span */
+	int sigtype;		/* read-only */
+	int sigcap;		/* read-only */
+	int rxisoffhook;	/* read-only */
+	int rxbits;		/* read-only */
+	int txbits;		/* read-only */
+	int txhooksig;		/* read-only */
+	int rxhooksig;		/* read-only */
+	int curlaw;		/* read-only  -- one of ZT_LAW_MULAW or ZT_LAW_ALAW */
+	int idlebits;		/* read-only  -- What is considered the idle state */
+	char name[40];		/* Name of channel */
+	int prewinktime;
+	int preflashtime;
+	int winktime;
+	int flashtime;
+	int starttime;
+	int rxwinktime;
+	int rxflashtime;
+	int debouncetime;
+	int pulsebreaktime;
+	int pulsemaketime;
+	int pulseaftertime;
+};
+
+typedef struct zt_params
+{
+	int channo;		/* Channel number */
+	int spanno;		/* Span itself */
+	int chanpos;		/* Channel number in span */
+	int sigtype;		/* read-only */
+	int sigcap;		/* read-only */
+	int rxisoffhook;	/* read-only */
+	int rxbits;		/* read-only */
+	int txbits;		/* read-only */
+	int txhooksig;		/* read-only */
+	int rxhooksig;		/* read-only */
+	int curlaw;		/* read-only  -- one of ZT_LAW_MULAW or ZT_LAW_ALAW */
+	int idlebits;		/* read-only  -- What is considered the idle state */
+	char name[40];		/* Name of channel */
+	int prewinktime;
+	int preflashtime;
+	int winktime;
+	int flashtime;
+	int starttime;
+	int rxwinktime;
+	int rxflashtime;
+	int debouncetime;
+	int pulsebreaktime;
+	int pulsemaketime;
+	int pulseaftertime;
+	__u32 chan_alarms;	/* alarms on this channel */
+} ZT_PARAMS;
+
+struct zt_spaninfo_v1 {
+	int	spanno;		/* span number */
+	char	name[20];	/* Name */
+	char	desc[40];	/* Description */
+	int	alarms;		/* alarms status */
+	int	txlevel;	/* what TX level is set to */
+	int	rxlevel;	/* current RX level */
+	int	bpvcount;	/* current BPV count */
+	int	crc4count;	/* current CRC4 error count */
+	int	ebitcount;	/* current E-bit error count */
+	int	fascount;	/* current FAS error count */
+	int	irqmisses;	/* current IRQ misses */
+	int	syncsrc;	/* span # of current sync source, or 0 for free run  */
+	int	numchans;	/* number of configured channels on this span */
+	int	totalchans;	/* total number of channels on the span */
+	int	totaflspans;	/* total number of spans in entire system */
+};
+
+struct zt_spaninfo_v2 {
+	int	spanno;		/* span number */
+	char	name[20];	/* Name */
+	char	desc[40];	/* Description */
+	int	alarms;		/* alarms status */
+	int	txlevel;	/* what TX level is set to */
+	int	rxlevel;	/* current RX level */
+	int	bpvcount;	/* current BPV count */
+	int	crc4count;	/* current CRC4 error count */
+	int	ebitcount;	/* current E-bit error count */
+	int	fascount;	/* current FAS error count */
+	int	irqmisses;	/* current IRQ misses */
+	int	syncsrc;	/* span # of current sync source, or 0 for free run  */
+	int	numchans;	/* number of configured channels on this span */
+	int	totalchans;	/* total number of channels on the span */
+	int	totalspans;	/* total number of spans in entire system */
+	int	lbo;        	/* line build out */
+	int	lineconfig;	 /* framing/coding */
+};
+
+typedef struct zt_spaninfo {
+	int	spanno;		/* span number */
+	char	name[20];	/* Name */
+	char	desc[40];	/* Description */
+	int	alarms;		/* alarms status */
+	int	txlevel;	/* what TX level is set to */
+	int	rxlevel;	/* current RX level */
+	int	bpvcount;	/* current BPV count */
+	int	crc4count;	/* current CRC4 error count */
+	int	ebitcount;	/* current E-bit error count */
+	int	fascount;	/* current FAS error count */
+	int	irqmisses;	/* current IRQ misses */
+	int	syncsrc;	/* span # of current sync source, or 0 for free run  */
+	int	numchans;	/* number of configured channels on this span */
+	int	totalchans;	/* total number of channels on the span */
+	int	totalspans;	/* total number of spans in entire system */
+	int	lbo;		/* line build out */
+	int	lineconfig;	/* framing/coding */
+	char 	lboname[40];	/* line build out in text form */
+	char	location[40];	/* span's device location in system */
+	char	manufacturer[40]; /* manufacturer of span's device */
+	char	devicetype[40];	/* span's device type */
+	int	irq;		/* span's device IRQ */
+	int	linecompat;	/* signaling modes possible on this span */
+	char	spantype[6];	/* type of span in text form */
+} ZT_SPANINFO;
+
+typedef struct zt_maintinfo
+{
+int	spanno;		/* span number 1-2 */
+int	command;	/* command */
+} ZT_MAINTINFO;
+
+typedef struct zt_confinfo
+{
+int	chan;		/* channel number, 0 for current */
+int	confno;		/* conference number */
+int	confmode;	/* conferencing mode */
+} ZT_CONFINFO;
+
+typedef struct zt_gains
+{
+int	chan;		/* channel number, 0 for current */
+unsigned char rxgain[256];	/* Receive gain table */
+unsigned char txgain[256];	/* Transmit gain table */
+} ZT_GAINS;
+
+typedef struct zt_lineconfig
+{
+int span;		/* Which span number (0 to use name) */
+char name[20];	/* Name of span to use */
+int	lbo;		/* line build-outs */
+int	lineconfig;	/* line config parameters (framing, coding) */
+int	sync;		/* what level of sync source we are */
+} ZT_LINECONFIG;
+
+typedef struct zt_chanconfig
+{
+int	chan;		/* Channel we're applying this to (0 to use name) */
+char name[40];		/* Name of channel to use */
+int	sigtype;	/* Signal type */
+int	deflaw;		/* Default law (ZT_LAW_DEFAULT, ZT_LAW_MULAW, or ZT_LAW_ALAW */
+int	master;		/* Master channel if sigtype is ZT_SLAVE */
+int	idlebits;	/* Idle bits (if this is a CAS channel) or
+			   channel to monitor (if this is DACS channel) */
+char netdev_name[16]; /*name for the hdlc network device*/
+} ZT_CHANCONFIG;
+
+typedef struct zt_sfconfig
+{
+int	chan;		/* Channel we're applying this to (0 to use name) */
+char	name[40];	/* Name of channel to use */
+long	rxp1;		/* receive tone det. p1 */
+long	rxp2;		/* receive tone det. p2 */
+long	rxp3;		/* receive tone det. p3 */
+int	txtone;		/* Tx tone factor */
+int	tx_v2;		/* initial v2 value */
+int	tx_v3;		/* initial v3 value */
+int	toneflag;	/* Tone flags */
+} ZT_SFCONFIG;
+
+typedef struct zt_bufferinfo
+{
+int txbufpolicy;	/* Policy for handling receive buffers */
+int rxbufpolicy;	/* Policy for handling receive buffers */
+int numbufs;		/* How many buffers to use */
+int bufsize;		/* How big each buffer is */
+int readbufs;		/* How many read buffers are full (read-only) */
+int writebufs;		/* How many write buffers are full (read-only) */
+} ZT_BUFFERINFO;
+
+typedef struct zt_dialparams {
+	int mfv1_tonelen;	/* MF R1 tone length for digits */
+	int dtmf_tonelen;	/* DTMF tone length */
+	int mfr2_tonelen;	/* MF R2 tone length */
+	int reserved[3];	/* Reserved for future expansion -- always set to 0 */
+} ZT_DIAL_PARAMS;
+
+typedef struct zt_dynamic_span {
+	char driver[20];	/* Which low-level driver to use */
+	char addr[40];		/* Destination address */
+	int numchans;		/* Number of channels */
+	int timing;		/* Timing source preference */
+	int spanno;		/* Span number (filled in by zaptel) */
+} ZT_DYNAMIC_SPAN;
+
+/* Define the max # of outgoing DTMF, MFR1 or MFR2 digits to queue in-kernel */
+#define ZT_MAX_DTMF_BUF 256
+
+#define ZT_DIAL_OP_APPEND	1
+#define ZT_DIAL_OP_REPLACE	2
+#define ZT_DIAL_OP_CANCEL	3
+
+#define ZT_LAW_DEFAULT	0	/* Default law for span */
+#define ZT_LAW_MULAW	1	/* Mu-law */
+#define ZT_LAW_ALAW	2	/* A-law */
+
+typedef struct zt_dialoperation {
+	int op;
+	char dialstr[ZT_MAX_DTMF_BUF];
+} ZT_DIAL_OPERATION;
+
+
+typedef struct zt_indirect_data
+{
+int	chan;
+int	op;
+void	*data;
+} ZT_INDIRECT_DATA;	
+
+struct zt_versioninfo {
+	char version[80];
+	char echo_canceller[80];
+};
+
+struct zt_hwgain{
+	__s32 newgain;	/* desired gain in dB but x10.  -3.5dB would be -35 */
+	__u32 tx:1;	/* 0=rx; 1=tx */
+};
+
+
+/* ioctl definitions */
+#define ZT_CODE	'J'
+
+/*
+ * Get Transfer Block Size.
+ */
+#define ZT_GET_BLOCKSIZE	_IOR (ZT_CODE, 1, int)
+
+/*
+ * Set Transfer Block Size.
+ */
+#define ZT_SET_BLOCKSIZE	_IOW (ZT_CODE, 2, int)
+
+/*
+ * Flush Buffer(s) and stop I/O
+ */
+#define	ZT_FLUSH		_IOW (ZT_CODE, 3, int)
+
+/*
+ * Wait for Write to Finish
+ */
+#define	ZT_SYNC		_IOW (ZT_CODE, 4, int)
+
+/*
+ * Get channel parameters
+ */
+#define ZT_GET_PARAMS_V1	_IOR (ZT_CODE, 5, struct zt_params_v1)
+#define ZT_GET_PARAMS		_IOR (ZT_CODE, 5, struct zt_params)
+
+/*
+ * Get channel parameters
+ */
+#define ZT_SET_PARAMS_V1	_IOW (ZT_CODE, 6, struct zt_params_v1)
+#define ZT_SET_PARAMS		_IOW (ZT_CODE, 6, struct zt_params)
+
+/*
+ * Set Hookswitch Status
+ */
+#define ZT_HOOK		_IOW (ZT_CODE, 7, int)
+
+/*
+ * Get Signalling Event
+ */
+#define ZT_GETEVENT		_IOR (ZT_CODE, 8, int)
+
+/*
+ * Wait for something to happen (IO Mux)
+ */
+#define ZT_IOMUX		_IOWR (ZT_CODE, 9, int)
+
+/*
+ * Get Span Status
+ */
+#define ZT_SPANSTAT_V1		_IOWR (ZT_CODE, 10, struct zt_spaninfo_v1)
+#define ZT_SPANSTAT_V2		_IOWR (ZT_CODE, 10, struct zt_spaninfo_v2)
+#define ZT_SPANSTAT		_IOWR (ZT_CODE, 10, struct zt_spaninfo)
+
+/*
+ * Set Maintenance Mode
+ */
+#define ZT_MAINT		_IOW (ZT_CODE, 11, struct zt_maintinfo)
+
+/*
+ * Get Conference Mode
+ */
+#define ZT_GETCONF		_IOWR (ZT_CODE, 12, struct zt_confinfo)
+
+/*
+ * Set Conference Mode
+ */
+#define ZT_SETCONF		_IOWR (ZT_CODE, 13, struct zt_confinfo)
+
+/*
+ * Setup or Remove Conference Link
+ */
+#define ZT_CONFLINK		_IOW (ZT_CODE, 14, struct zt_confinfo)
+
+/*
+ * Display Conference Diagnostic Information on Console
+ */
+#define ZT_CONFDIAG		_IOR (ZT_CODE, 15, int)
+
+/*
+ * Get Channel audio gains
+ */
+#define ZT_GETGAINS		_IOWR (ZT_CODE, 16, struct zt_gains)
+
+/*
+ * Set Channel audio gains
+ */
+#define ZT_SETGAINS		_IOWR (ZT_CODE, 17, struct zt_gains)
+
+/*
+ * Set Line (T1) Configurations and start system
+ */
+#define	ZT_SPANCONFIG		_IOW (ZT_CODE, 18, struct zt_lineconfig)
+
+/*
+ * Set Channel Configuration
+ */
+#define	ZT_CHANCONFIG		_IOW (ZT_CODE, 19, struct zt_chanconfig)
+
+/*
+ * Set Conference to mute mode
+ */
+#define	ZT_CONFMUTE		_IOW (ZT_CODE, 20, int)
+
+/*
+ * Send a particular tone (see ZT_TONE_*)
+ */
+#define	ZT_SENDTONE		_IOW (ZT_CODE, 21, int)
+
+/*
+ * Set your region for tones (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_SETTONEZONE		_IOW (ZT_CODE, 22, int)
+
+/*
+ * Retrieve current region for tones (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_GETTONEZONE		_IOR (ZT_CODE, 23, int)
+
+/*
+ * Master unit only -- set default zone (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_DEFAULTZONE		_IOW (ZT_CODE, 24, int)
+
+/*
+ * Load a tone zone from a zt_tone_def_header, see
+ * below...
+ */
+#define ZT_LOADZONE		_IOW (ZT_CODE, 25, struct zt_tone_def_header)
+
+/*
+ * Free a tone zone 
+ */
+#define ZT_FREEZONE		_IOW (ZT_CODE, 26, int)
+
+/*
+ * Set buffer policy 
+ */
+#define ZT_SET_BUFINFO		_IOW (ZT_CODE, 27, struct zt_bufferinfo)
+
+/*
+ * Get current buffer info
+ */
+#define ZT_GET_BUFINFO		_IOR (ZT_CODE, 28, struct zt_bufferinfo)
+
+/*
+ * Get dialing parameters
+ */
+#define ZT_GET_DIALPARAMS	_IOR (ZT_CODE, 29, struct zt_dialparams)
+
+/*
+ * Set dialing parameters
+ */
+#define ZT_SET_DIALPARAMS	_IOW (ZT_CODE, 30, struct zt_dialparams)
+
+/*
+ * Append, replace, or cancel a dial string
+ */
+#define ZT_DIAL			_IOW (ZT_CODE, 31, struct zt_dialoperation)
+
+/*
+ * Set a clear channel into audio mode
+ */
+#define ZT_AUDIOMODE		_IOW (ZT_CODE, 32, int)
+
+/*
+ * Enable or disable echo cancellation on a channel 
+ *
+ * For ECHOCANCEL:
+ * The number is zero to disable echo cancellation and non-zero
+ * to enable echo cancellation.  If the number is between 32
+ * and 1024, it will also set the number of taps in the echo canceller
+ *
+ * For ECHOCANCEL_PARAMS:
+ * The structure contains parameters that should be passed to the
+ * echo canceler instance for the selected channel.
+ */
+#define ZT_ECHOCANCEL		_IOW (ZT_CODE, 33, int)
+#define ZT_ECHOCANCEL_PARAMS	_IOW (ZT_CODE, 33, struct zt_echocanparams)
+
+/*
+ * Return a channel's channel number (useful for the /dev/zap/pseudo type interfaces 
+ */
+#define ZT_CHANNO		_IOR (ZT_CODE, 34, int)
+
+/*
+ * Return a flag indicating whether channel is currently dialing
+ */
+#define ZT_DIALING		_IOR (ZT_CODE, 35, int)
+
+/* Numbers 60 to 90 are reserved for private use of low level hardware
+   drivers */
+
+/*
+ * Set a clear channel into HDLC w/out FCS checking/calculation mode
+ */
+#define ZT_HDLCRAWMODE		_IOW (ZT_CODE, 36, int)
+
+/*
+ * Set a clear channel into HDLC w/ FCS mode
+ */
+#define ZT_HDLCFCSMODE		_IOW (ZT_CODE, 37, int)
+
+/* 
+ * Specify a channel on /dev/zap/chan -- must be done before any other ioctl's and is only
+ * valid on /dev/zap/chan
+ */
+#define ZT_SPECIFY		_IOW (ZT_CODE, 38, int)
+
+/*
+ * Temporarily set the law on a channel to 
+ * ZT_LAW_DEFAULT, ZT_LAW_ALAW, or ZT_LAW_MULAW.  Is reset on close.  
+ */
+#define ZT_SETLAW		_IOW (ZT_CODE, 39, int)
+
+/*
+ * Temporarily set the channel to operate in linear mode when non-zero
+ * or default law if 0
+ */
+#define ZT_SETLINEAR		_IOW (ZT_CODE, 40, int)
+
+/*
+ * Set a clear channel into HDLC w/ PPP interface mode
+ */
+#define ZT_HDLCPPP		_IOW (ZT_CODE, 41, int)
+
+/*
+ * Set the ring cadence for FXS interfaces
+ */
+#define ZT_SETCADENCE		_IOW (ZT_CODE, 42, struct zt_ring_cadence)
+
+/*
+ * Set the bits going out for CAS interface
+ */
+#define ZT_SETTXBITS			_IOW (ZT_CODE, 43, int)
+
+
+/*
+ * Display Channel Diagnostic Information on Console
+ */
+#define ZT_CHANDIAG		_IOR (ZT_CODE, 44, int) 
+
+/* 
+ * Obtain received signalling
+ */
+#define ZT_GETRXBITS _IOR (ZT_CODE, 45, int)
+
+/*
+ * Set Channel's SF Tone Configuration
+ */
+#define	ZT_SFCONFIG		_IOW (ZT_CODE, 46, struct zt_sfconfig)
+
+/*
+ * Set timer expiration (in samples)
+ */
+#define ZT_TIMERCONFIG	_IOW (ZT_CODE, 47, int)
+
+/*
+ * Acknowledge timer expiration (number to acknowledge, or -1 for all)
+ */
+#define ZT_TIMERACK _IOW (ZT_CODE, 48, int)
+
+/*
+ * Get Conference to mute mode
+ */
+#define	ZT_GETCONFMUTE		_IOR (ZT_CODE, 49, int)
+
+/*
+ * Request echo training in some number of ms (with muting in the mean time)
+ */
+#define	ZT_ECHOTRAIN		_IOW (ZT_CODE, 50, int)
+
+/*
+ * Set on hook transfer for n number of ms -- implemnted by low level driver
+ */
+#define	ZT_ONHOOKTRANSFER		_IOW (ZT_CODE, 51, int)
+
+/*
+ * Queue Ping
+ */
+#define ZT_TIMERPING _IOW (ZT_CODE, 42, int) /* Should be 52, but works */
+
+/*
+ * Acknowledge ping
+ */
+#define ZT_TIMERPONG _IOW (ZT_CODE, 53, int)
+
+/*
+ * Set/get signalling freeze
+ */
+#define ZT_SIGFREEZE _IOW (ZT_CODE, 54, int)
+#define ZT_GETSIGFREEZE _IOR (ZT_CODE, 55, int)
+
+/*
+ * Do a channel IOCTL from the /dev/zap/ctl interface
+ */
+#define ZT_INDIRECT _IOWR (ZT_CODE, 56, struct zt_indirect_data)
+
+
+/*
+ * Get the version of Zaptel that is running, and a description
+ * of the compiled-in echo canceller (if any)
+ */
+#define ZT_GETVERSION _IOR(ZT_CODE, 57, struct zt_versioninfo)
+
+/*
+ * Put the channel in loopback mode (receive from the channel is
+ * transmitted back on the interface)
+ */
+#define ZT_LOOPBACK _IOW(ZT_CODE, 58, int)
+
+
+/*
+ *  60-80 are reserved for private drivers
+ *  80-85 are reserved for dynamic span stuff
+ */
+
+/*
+ * Create a dynamic span
+ */
+#define ZT_DYNAMIC_CREATE	_IOWR (ZT_CODE, 80, struct zt_dynamic_span)
+
+/* 
+ * Destroy a dynamic span 
+ */
+#define ZT_DYNAMIC_DESTROY	_IOW (ZT_CODE, 81, struct zt_dynamic_span)
+
+/*
+ * Set the HW gain for a device
+ */
+#define ZT_SET_HWGAIN		_IOW (ZT_CODE, 86, struct zt_hwgain)
+
+/*
+ * Enable tone detection -- implemented by low level driver
+ */
+#define ZT_TONEDETECT		_IOW (ZT_CODE, 91, int)
+
+/*
+ * Set polarity -- implemented by individual driver.  0 = forward, 1 = reverse
+ */
+#define	ZT_SETPOLARITY		_IOW (ZT_CODE, 92, int)
+
+/*
+ * Transcoder operations
+ */
+#define ZT_TRANSCODE_OP		_IOWR(ZT_CODE, 93, int)
+
+/*
+ * VoiceMail Waiting Indication (WMWI) -- implemented by low-level driver.
+ * Value: number of waiting messages (hence 0: switch messages off).
+ */
+#define ZT_VMWI			_IOWR(ZT_CODE, 94, int)
+
+/* 
+ * Startup or Shutdown a span
+ */
+#define ZT_STARTUP		_IOW (ZT_CODE, 99, int)
+#define ZT_SHUTDOWN		_IOW (ZT_CODE, 100, int)
+
+#define ZT_TONE_ZONE_MAX		128
+
+#define ZT_TONE_ZONE_DEFAULT 	-1	/* To restore default */
+
+#define ZT_TONE_STOP		-1
+#define ZT_TONE_DIALTONE	0
+#define ZT_TONE_BUSY		1
+#define ZT_TONE_RINGTONE	2
+#define ZT_TONE_CONGESTION	3
+#define ZT_TONE_CALLWAIT	4
+#define ZT_TONE_DIALRECALL	5
+#define ZT_TONE_RECORDTONE	6
+#define ZT_TONE_INFO		7
+#define ZT_TONE_CUST1		8
+#define ZT_TONE_CUST2		9
+#define ZT_TONE_STUTTER		10
+#define ZT_TONE_MAX		16
+
+#define ZT_TONE_DTMF_BASE	64
+#define ZT_TONE_MFR1_BASE	80
+#define ZT_TONE_MFR2_FWD_BASE	96
+#define ZT_TONE_MFR2_REV_BASE	112
+
+enum {
+	ZT_TONE_DTMF_0 = ZT_TONE_DTMF_BASE,
+	ZT_TONE_DTMF_1,
+	ZT_TONE_DTMF_2,
+	ZT_TONE_DTMF_3,
+	ZT_TONE_DTMF_4,
+	ZT_TONE_DTMF_5,
+	ZT_TONE_DTMF_6,
+	ZT_TONE_DTMF_7,
+	ZT_TONE_DTMF_8,
+	ZT_TONE_DTMF_9,
+	ZT_TONE_DTMF_s,
+	ZT_TONE_DTMF_p,
+	ZT_TONE_DTMF_A,
+	ZT_TONE_DTMF_B,
+	ZT_TONE_DTMF_C,
+	ZT_TONE_DTMF_D
+};
+
+#define ZT_TONE_DTMF_MAX ZT_TONE_DTMF_D
+
+enum {
+	ZT_TONE_MFR1_0 = ZT_TONE_MFR1_BASE,
+	ZT_TONE_MFR1_1,
+	ZT_TONE_MFR1_2,
+	ZT_TONE_MFR1_3,
+	ZT_TONE_MFR1_4,
+	ZT_TONE_MFR1_5,
+	ZT_TONE_MFR1_6,
+	ZT_TONE_MFR1_7,
+	ZT_TONE_MFR1_8,
+	ZT_TONE_MFR1_9,
+	ZT_TONE_MFR1_KP,
+	ZT_TONE_MFR1_ST,
+	ZT_TONE_MFR1_STP,
+	ZT_TONE_MFR1_ST2P,
+	ZT_TONE_MFR1_ST3P,
+};
+
+#define ZT_TONE_MFR1_MAX ZT_TONE_MFR1_ST3P
+
+enum {
+	ZT_TONE_MFR2_FWD_1 = ZT_TONE_MFR2_FWD_BASE,
+	ZT_TONE_MFR2_FWD_2,
+	ZT_TONE_MFR2_FWD_3,
+	ZT_TONE_MFR2_FWD_4,
+	ZT_TONE_MFR2_FWD_5,
+	ZT_TONE_MFR2_FWD_6,
+	ZT_TONE_MFR2_FWD_7,
+	ZT_TONE_MFR2_FWD_8,
+	ZT_TONE_MFR2_FWD_9,
+	ZT_TONE_MFR2_FWD_10,
+	ZT_TONE_MFR2_FWD_11,
+	ZT_TONE_MFR2_FWD_12,
+	ZT_TONE_MFR2_FWD_13,
+	ZT_TONE_MFR2_FWD_14,
+	ZT_TONE_MFR2_FWD_15,
+};
+
+#define ZT_TONE_MFR2_FWD_MAX ZT_TONE_MFR2_FWD_15
+
+enum {
+	ZT_TONE_MFR2_REV_1 = ZT_TONE_MFR2_REV_BASE,
+	ZT_TONE_MFR2_REV_2,
+	ZT_TONE_MFR2_REV_3,
+	ZT_TONE_MFR2_REV_4,
+	ZT_TONE_MFR2_REV_5,
+	ZT_TONE_MFR2_REV_6,
+	ZT_TONE_MFR2_REV_7,
+	ZT_TONE_MFR2_REV_8,
+	ZT_TONE_MFR2_REV_9,
+	ZT_TONE_MFR2_REV_10,
+	ZT_TONE_MFR2_REV_11,
+	ZT_TONE_MFR2_REV_12,
+	ZT_TONE_MFR2_REV_13,
+	ZT_TONE_MFR2_REV_14,
+	ZT_TONE_MFR2_REV_15,
+};
+
+#define ZT_TONE_MFR2_REV_MAX ZT_TONE_MFR2_REV_15
+
+#define ZT_MAX_CADENCE		16
+
+#define ZT_TONEDETECT_ON	(1 << 0)		/* Detect tones */
+#define ZT_TONEDETECT_MUTE	(1 << 1)		/* Mute audio in received channel */
+
+#define ZT_TRANSCODE_MAGIC 0x74a9c0de
+
+/* Operations */
+#define ZT_TCOP_ALLOCATE	1			/* Allocate/reset DTE channel */
+#define ZT_TCOP_TRANSCODE	2			/* Begin transcoding a block */
+#define ZT_TCOP_GETINFO		3			/* Get information (use zt_transcode_info) */
+#define ZT_TCOP_RELEASE         4                       /* Release DTE channel */
+#define ZT_TCOP_TEST            5                       /* test DTE device */
+typedef struct zt_transcode_info {
+	unsigned int op;
+	unsigned int tcnum;
+	char name[80];
+	int numchannels;
+	unsigned int srcfmts;
+	unsigned int dstfmts;
+} ZT_TRANSCODE_INFO;
+
+#define ZT_TCCONF_USETS		(1 << 0)		/* Use/update timestamp field */
+#define ZT_TCCONF_USESEQ	(1 << 1)		/* Use/update seqno field */
+
+#define ZT_TCSTAT_DSTRDY	(1 << 0)		/* Destination data is ready */
+#define ZT_TCSTAT_DSTBUSY	(1 << 1)		/* Destination data is outstanding */
+
+#define __ZT_TRANSCODE_BUFSIZ	16384
+#define ZT_TRANSCODE_HDRLEN	256
+#define ZT_TRANSCODE_BUFSIZ	((__ZT_TRANSCODE_BUFSIZ) - (ZT_TRANSCODE_HDRLEN))
+#define ZT_TRANSCODE_DSTOFFSET	(((ZT_TRANSCODE_BUFSIZ) / 2) + ZT_TRANSCODE_HDRLEN)
+#define ZT_TRANSCODE_SRCOFFSET	(((ZT_TRANSCODE_BUFSIZ) / 2) + ZT_TRANSCODE_HDRLEN)
+
+typedef struct zt_transcode_header {
+	unsigned int srcfmt;		/* See formats.h -- use TCOP_RESET when you change */
+	unsigned int srcoffset; 	/* In bytes -- written by user */
+	unsigned int srclen;		/* In bytes -- written by user */
+	unsigned int srctimestamp;	/* In samples -- written by user (only used if ZT_TCCONF_USETS is set) */
+	unsigned int srcseqno;		/* In units -- written by user (only used if ZT_TCCONF_USESEQ is set) */
+
+	unsigned int dstfmt;		/* See formats.h -- use TCOP_RESET when you change */
+	unsigned int dstoffset;  	/* In bytes -- written by user */
+	unsigned int dsttimestamp;	/* In samples -- read by user */
+	unsigned int dstseqno;		/* In units -- read by user (only used if ZT_TCCONF_USESEQ is set) */
+	unsigned int dstlen;  		/* In bytes -- read by user */
+	unsigned int dstsamples;	/* In timestamp units -- read by user */
+
+	unsigned int magic;		/* Magic value -- ZT_TRANSCODE_MAGIC, read by user */
+	unsigned int config;		/* Read/write by user */
+	unsigned int status;		/* Read/write by user */
+	unsigned char userhdr[ZT_TRANSCODE_HDRLEN - (sizeof(unsigned int) * 14)];	/* Storage for user parameters */
+	unsigned char srcdata[ZT_TRANSCODE_BUFSIZ / 2];	/* Storage of source data */
+	unsigned char dstdata[ZT_TRANSCODE_BUFSIZ / 2];	/* Storage of destination data */
+} ZT_TRANSCODE_HEADER;
+
+struct zt_ring_cadence {
+	int ringcadence[ZT_MAX_CADENCE];
+};
+
+#define ZT_MAX_ECHOCANPARAMS 8
+
+struct zt_echocanparam {
+	char name[16];
+        __s32 value;
+};
+
+struct zt_echocanparams {
+	__u32 tap_length;		/* 8 taps per millisecond */
+	__u32 param_count;		/* number of parameters supplied */
+	/* immediately follow this structure with zt_echocanparam structures */
+	struct zt_echocanparam params[0];
+};
+
+struct zt_tone_def_header {
+	int count;		/* How many samples follow */
+	int zone;		/* Which zone we are loading */
+	int ringcadence[ZT_MAX_CADENCE];	/* Ring cadence in ms (0=on, 1=off, ends with 0 value) */
+	char name[40];		/* Informational name of zone */
+	/* Immediately follow the zt_tone_def_header by zt_tone_def's */
+};
+
+struct zt_tone_def {		/* Structure for zone programming */
+	int tone;		/* See ZT_TONE_* */
+	int next;		/* What the next position in the cadence is
+				   (They're numbered by the order the appear here) */
+	int samples;		/* How many samples to play for this cadence */
+				/* Now come the constants we need to make tones */
+	int shift;		/* How much to scale down the volume (2 is nice) */
+
+	/* 
+		Calculate the next 6 factors using the following equations:
+		l = <level in dbm>, f1 = <freq1>, f2 = <freq2>
+		gain = pow(10.0, (l - 3.14) / 20.0) * 65536.0 / 2.0;
+
+		// Frequency factor 1 
+		fac_1 = 2.0 * cos(2.0 * M_PI * (f1/8000.0)) * 32768.0;
+		// Last previous two samples 
+		init_v2_1 = sin(-4.0 * M_PI * (f1/8000.0)) * gain;
+		init_v3_1 = sin(-2.0 * M_PI * (f1/8000.0)) * gain;
+
+		// Frequency factor 2 
+		fac_2 = 2.0 * cos(2.0 * M_PI * (f2/8000.0)) * 32768.0;
+		// Last previous two samples 
+		init_v2_2 = sin(-4.0 * M_PI * (f2/8000.0)) * gain;
+		init_v3_2 = sin(-2.0 * M_PI * (f2/8000.0)) * gain;
+	*/
+	int fac1;		
+	int init_v2_1;		
+	int init_v3_1;		
+	int fac2;		
+	int init_v2_2;		
+	int init_v3_2;
+	int modulate;
+
+};
+
+#ifdef __KERNEL__
+#endif /* KERNEL */
+
+/* Define the maximum block size */
+#define	ZT_MAX_BLOCKSIZE	8192
+
+/* Define the default network block size */
+#define ZT_DEFAULT_MTU_MRU	2048
+
+/* Flush and stop the read (input) process */
+#define	ZT_FLUSH_READ		1
+
+/* Flush and stop the write (output) process */
+#define	ZT_FLUSH_WRITE		2
+
+/* Flush and stop both (input and output) processes */
+#define	ZT_FLUSH_BOTH		(ZT_FLUSH_READ | ZT_FLUSH_WRITE)
+
+/* Flush the event queue */
+#define	ZT_FLUSH_EVENT		4
+
+/* Flush everything */
+#define	ZT_FLUSH_ALL		(ZT_FLUSH_READ | ZT_FLUSH_WRITE | ZT_FLUSH_EVENT)
+
+
+/* Value for ZT_HOOK, set to ON hook */
+#define	ZT_ONHOOK	0
+
+/* Value for ZT_HOOK, set to OFF hook */
+#define	ZT_OFFHOOK	1
+
+/* Value for ZT_HOOK, wink (off hook momentarily) */
+#define	ZT_WINK		2
+
+/* Value for ZT_HOOK, flash (on hook momentarily) */
+#define	ZT_FLASH	3
+
+/* Value for ZT_HOOK, start line */
+#define	ZT_START	4
+
+/* Value for ZT_HOOK, ring line (same as start line) */
+#define	ZT_RING		5
+
+/* Value for ZT_HOOK, turn ringer off */
+#define ZT_RINGOFF  6
+
+/* Ret. Value for GET/WAIT Event, no event */
+#define	ZT_EVENT_NONE	0
+
+/* Ret. Value for GET/WAIT Event, Went Onhook */
+#define	ZT_EVENT_ONHOOK 1
+
+/* Ret. Value for GET/WAIT Event, Went Offhook or got Ring */
+#define	ZT_EVENT_RINGOFFHOOK 2
+
+/* Ret. Value for GET/WAIT Event, Got Wink or Flash */
+#define	ZT_EVENT_WINKFLASH 3
+
+/* Ret. Value for GET/WAIT Event, Got Alarm */
+#define	ZT_EVENT_ALARM	4
+
+/* Ret. Value for GET/WAIT Event, Got No Alarm (after alarm) */
+#define	ZT_EVENT_NOALARM 5
+
+/* Ret. Value for GET/WAIT Event, HDLC Abort frame */
+#define ZT_EVENT_ABORT 6
+
+/* Ret. Value for GET/WAIT Event, HDLC Frame overrun */
+#define ZT_EVENT_OVERRUN 7
+
+/* Ret. Value for GET/WAIT Event, Bad FCS */
+#define ZT_EVENT_BADFCS 8
+
+/* Ret. Value for dial complete */
+#define ZT_EVENT_DIALCOMPLETE	9
+
+/* Ret Value for ringer going on */
+#define ZT_EVENT_RINGERON 10
+
+/* Ret Value for ringer going off */
+#define ZT_EVENT_RINGEROFF 11
+
+/* Ret Value for hook change complete */
+#define ZT_EVENT_HOOKCOMPLETE 12
+
+/* Ret Value for bits changing on a CAS / User channel */
+#define ZT_EVENT_BITSCHANGED 13
+
+/* Ret value for the beginning of a pulse coming on its way */
+#define ZT_EVENT_PULSE_START 14
+
+/* Timer event -- timer expired */
+#define ZT_EVENT_TIMER_EXPIRED	15
+
+/* Timer event -- ping ready */
+#define ZT_EVENT_TIMER_PING		16
+
+/* Polarity reversal event */
+#define ZT_EVENT_POLARITY  17
+
+/* Ring Begin event */
+#define ZT_EVENT_RINGBEGIN  18
+
+/* Echo can disabled event */
+#define ZT_EVENT_EC_DISABLED 19
+
+/* Channel was disconnected. Hint user to close channel */
+#define ZT_EVENT_REMOVED   20
+
+/* A neon MWI pulse was detected */
+#define ZT_EVENT_NEONMWI_ACTIVE   21
+
+/* No neon MWI pulses were detected over some period of time */
+#define ZT_EVENT_NEONMWI_INACTIVE   22
+
+#define ZT_EVENT_PULSEDIGIT (1 << 16)	/* This is OR'd with the digit received */
+#define ZT_EVENT_DTMFDOWN  (1 << 17)	/* Ditto for DTMF key down event */
+#define ZT_EVENT_DTMFUP (1 << 18)	/* Ditto for DTMF key up event */
+
+/* Flag Value for IOMUX, read avail */
+#define	ZT_IOMUX_READ	1
+
+/* Flag Value for IOMUX, write avail */
+#define	ZT_IOMUX_WRITE	2
+
+/* Flag Value for IOMUX, write done */
+#define	ZT_IOMUX_WRITEEMPTY	4
+
+/* Flag Value for IOMUX, signalling event avail */
+#define	ZT_IOMUX_SIGEVENT	8
+
+/* Flag Value for IOMUX, Do Not Wait if nothing to report */
+#define	ZT_IOMUX_NOWAIT	0x100
+
+/* Alarm Condition bits */
+#define	ZT_ALARM_NONE		0	/* No alarms */
+#define	ZT_ALARM_RECOVER	1	/* Recovering from alarm */
+#define	ZT_ALARM_LOOPBACK	2	/* In loopback */
+#define	ZT_ALARM_YELLOW		4	/* Yellow Alarm */
+#define	ZT_ALARM_RED		8	/* Red Alarm */
+#define	ZT_ALARM_BLUE		16	/* Blue Alarm */
+#define ZT_ALARM_NOTOPEN	32
+/* Maintenance modes */
+#define	ZT_MAINT_NONE		0	/* Normal Mode */
+#define	ZT_MAINT_LOCALLOOP	1	/* Local Loopback */
+#define	ZT_MAINT_REMOTELOOP	2	/* Remote Loopback */
+#define	ZT_MAINT_LOOPUP	3	/* send loopup code */
+#define	ZT_MAINT_LOOPDOWN	4	/* send loopdown code */
+#define	ZT_MAINT_LOOPSTOP	5	/* stop sending loop codes */
+
+
+/* Conference modes */
+#define	ZT_CONF_MODE_MASK 0xff		/* mask for modes */
+#define	ZT_CONF_NORMAL	0		/* normal mode */
+#define	ZT_CONF_MONITOR 1		/* monitor mode (rx of other chan) */
+#define	ZT_CONF_MONITORTX 2		/* monitor mode (tx of other chan) */
+#define	ZT_CONF_MONITORBOTH 3		/* monitor mode (rx & tx of other chan) */
+#define	ZT_CONF_CONF 4			/* conference mode */
+#define	ZT_CONF_CONFANN 5		/* conference announce mode */
+#define	ZT_CONF_CONFMON 6		/* conference monitor mode */
+#define	ZT_CONF_CONFANNMON 7		/* conference announce/monitor mode */
+#define	ZT_CONF_REALANDPSEUDO 8	/* real and pseudo port both on conf */
+#define ZT_CONF_DIGITALMON 9	/* Do not decode or interpret */
+#define	ZT_CONF_MONITOR_RX_PREECHO 10	/* monitor mode (rx of other chan) - before echo can is done */
+#define	ZT_CONF_MONITOR_TX_PREECHO 11	/* monitor mode (tx of other chan) - before echo can is done */
+#define	ZT_CONF_MONITORBOTH_PREECHO 12	/* monitor mode (rx & tx of other chan) - before echo can is done */
+#define	ZT_CONF_FLAG_MASK 0xff00	/* mask for flags */
+#define	ZT_CONF_LISTENER 0x100		/* is a listener on the conference */
+#define	ZT_CONF_TALKER 0x200		/* is a talker on the conference */
+#define	ZT_CONF_PSEUDO_LISTENER 0x400	/* pseudo is a listener on the conference */
+#define	ZT_CONF_PSEUDO_TALKER 0x800	/* pseudo is a talker on the conference */
+
+
+#define	ZT_DEFAULT_WINKTIME	150	/* 150 ms default wink time */
+#define	ZT_DEFAULT_FLASHTIME	750	/* 750 ms default flash time */
+
+#define	ZT_DEFAULT_PREWINKTIME	50	/* 50 ms before wink */
+#define	ZT_DEFAULT_PREFLASHTIME 50	/* 50 ms before flash */
+#define	ZT_DEFAULT_STARTTIME 1500	/* 1500 ms of start */
+#define	ZT_DEFAULT_RINGTIME 2000	/* 2000 ms of ring on (start, FXO) */
+#if 0
+#define	ZT_DEFAULT_RXWINKTIME 250	/* 250ms longest rx wink */
+#endif
+#define	ZT_DEFAULT_RXWINKTIME 300	/* 300ms longest rx wink (to work with the Atlas) */
+#define	ZT_DEFAULT_RXFLASHTIME 1250	/* 1250ms longest rx flash */
+#define	ZT_DEFAULT_DEBOUNCETIME 600	/* 600ms of FXS GS signalling debounce */
+#define	ZT_DEFAULT_PULSEMAKETIME 50	/* 50 ms of line closed when dial pulsing */
+#define	ZT_DEFAULT_PULSEBREAKTIME 50	/* 50 ms of line open when dial pulsing */
+#define	ZT_DEFAULT_PULSEAFTERTIME 750	/* 750ms between dial pulse digits */
+
+#define	ZT_MINPULSETIME (15 * 8)	/* 15 ms minimum */
+
+#ifdef SHORT_FLASH_TIME
+#define	ZT_MAXPULSETIME (80 * 8)	/* we need 80 ms, not 200ms, as we have a short flash */
+#else
+#define	ZT_MAXPULSETIME (200 * 8)	/* 200 ms maximum */
+#endif
+
+#define	ZT_PULSETIMEOUT ((ZT_MAXPULSETIME / 8) + 50)
+
+#define ZT_RINGTRAILER (50 * 8)	/* Don't consider a ring "over" until it's been gone at least this
+									   much time */
+
+#define	ZT_LOOPCODE_TIME 10000		/* send loop codes for 10 secs */
+#define	ZT_ALARMSETTLE_TIME	5000	/* allow alarms to settle for 5 secs */
+#define	ZT_AFTERSTART_TIME 500		/* 500ms after start */
+
+#define ZT_RINGOFFTIME 4000		/* Turn off ringer for 4000 ms */
+#define	ZT_KEWLTIME 500		/* 500ms for kewl pulse */
+#define	ZT_AFTERKEWLTIME 300    /* 300ms after kewl pulse */
+
+#define ZT_MAX_PRETRAINING   1000	/* 1000ms max pretraining time */
+
+#define ZT_MAX_SPANS		128		/* Max, 128 spans */
+#define ZT_MAX_CHANNELS		1024	/* Max, 1024 channels */
+#define ZT_MAX_CONF			1024	/* Max, 1024 conferences */
+
+#ifdef	FXSFLASH
+#define ZT_FXSFLASHMINTIME	450	/* min 450ms */
+#define ZT_FXSFLASHMAXTIME	550	/* max 550ms */
+#endif
+
+#ifdef __KERNEL__
+
+#include <linux/poll.h>
+
+#define	ZT_MAX_EVENTSIZE	64	/* 64 events max in buffer */
+
+struct zt_span;
+struct zt_chan;
+
+struct zt_tone_state {
+	int v1_1;
+	int v2_1;
+	int v3_1;
+	int v1_2;
+	int v2_2;
+	int v3_2;
+	int modulate;
+};
+
+struct zt_chardev {
+	const char *name;
+	__u8 minor;
+#ifdef CONFIG_DEVFS_FS
+	devfs_handle_t devfs_handle;
+#endif
+};
+
+int zt_register_chardev(struct zt_chardev *dev);
+int zt_unregister_chardev(struct zt_chardev *dev);
+
+#ifdef CONFIG_ZAPATA_NET
+struct zt_hdlc {
+#ifdef LINUX26	
+	struct net_device *netdev;
+#else
+	hdlc_device netdev;
+#endif
+	struct zt_chan *chan;
+};
+#endif
+
+/* Echo cancellation */
+struct echo_can_state;
+#if 0
+/* echo can API consists of these functions */
+void echo_can_init(void);
+void echo_chan_shutdown(void);
+void echo_can_identify(char *buf, size_t len);
+int echo_can_create(struct zt_echocanparams *ecp, struct zt_echocanparam *p, struct echo_can_state **ec);
+void echo_can_free(struct echo_can_state *ec);
+short echo_can_update(struct echo_can_state *ec, short iref, short isig);
+void echo_can_array_update(struct echo_can_state *ec, short *iref, short *isig);
+int echo_can_traintap(struct echo_can_state *ec, int pos, short val);
+#endif
+
+/* Conference queue stucture */
+struct confq {
+	u_char buffer[ZT_CHUNKSIZE * ZT_CB_SIZE];
+	u_char *buf[ZT_CB_SIZE];
+	int inbuf;
+	int outbuf;
+};
+
+typedef struct
+{
+	long	x1;
+	long	x2;
+	long	y1;
+	long	y2;
+	long	e1;
+	long	e2;
+	int	samps;
+	int	lastdetect;
+} sf_detect_state_t;
+
+struct zt_chan {
+#ifdef CONFIG_ZAPATA_NET
+	/* Must be first */
+	struct zt_hdlc *hdlcnetdev;
+#endif
+#ifdef CONFIG_ZAPATA_PPP
+	struct ppp_channel *ppp;
+	struct tasklet_struct ppp_calls;
+	int do_ppp_wakeup;
+	int do_ppp_error;
+	struct sk_buff_head ppp_rq;
+#endif
+	spinlock_t lock;
+	char name[40];		/* Name */
+	/* Specified by zaptel */
+	int channo;			/* Zaptel Channel number */
+	int chanpos;
+	unsigned long flags;
+	long rxp1;
+	long rxp2;
+	long rxp3;
+	int txtone;
+	int tx_v2;
+	int tx_v3;
+	int v1_1;
+	int v2_1;
+	int v3_1;
+	int toneflags;
+	sf_detect_state_t rd;
+
+	struct zt_chan *master;	/* Our Master channel (could be us) */
+	/* Next slave (if appropriate) */
+	int nextslave;
+
+	u_char *writechunk;						/* Actual place to write to */
+	u_char swritechunk[ZT_MAX_CHUNKSIZE];	/* Buffer to be written */
+	u_char *readchunk;						/* Actual place to read from */
+	u_char sreadchunk[ZT_MAX_CHUNKSIZE];	/* Preallocated static area */
+	short *readchunkpreec;
+
+	/* Pointer to tx and rx gain tables */
+	u_char *rxgain;
+	u_char *txgain;
+	
+	/* Whether or not we have allocated gains or are using the default */
+	int gainalloc;
+
+	/* Specified by driver, readable by zaptel */
+	void *pvt;			/* Private channel data */
+	struct file *file;	/* File structure */
+	
+	
+	struct zt_span	*span;			/* Span we're a member of */
+	int		sig;			/* Signalling */
+	int		sigcap;			/* Capability for signalling */
+	__u32		chan_alarms;		/* alarms status */
+
+	/* Used only by zaptel -- NO DRIVER SERVICEABLE PARTS BELOW */
+	/* Buffer declarations */
+	u_char		*readbuf[ZT_MAX_NUM_BUFS];	/* read buffer */
+	int		inreadbuf;
+	int		outreadbuf;
+	wait_queue_head_t readbufq; /* read wait queue */
+
+	u_char		*writebuf[ZT_MAX_NUM_BUFS]; /* write buffers */
+	int		inwritebuf;
+	int		outwritebuf;
+	wait_queue_head_t writebufq; /* write wait queue */
+	
+	int		blocksize;	/* Block size */
+
+	int		eventinidx;  /* out index in event buf (circular) */
+	int		eventoutidx;  /* in index in event buf (circular) */
+	unsigned int	eventbuf[ZT_MAX_EVENTSIZE];  /* event circ. buffer */
+	wait_queue_head_t eventbufq; /* event wait queue */
+	
+	wait_queue_head_t txstateq;	/* waiting on the tx state to change */
+	
+	int		readn[ZT_MAX_NUM_BUFS];  /* # of bytes ready in read buf */
+	int		readidx[ZT_MAX_NUM_BUFS];  /* current read pointer */
+	int		writen[ZT_MAX_NUM_BUFS];  /* # of bytes ready in write buf */
+	int		writeidx[ZT_MAX_NUM_BUFS];  /* current write pointer */
+	
+	int		numbufs;			/* How many buffers in channel */
+	int		txbufpolicy;			/* Buffer policy */
+	int		rxbufpolicy;			/* Buffer policy */
+	int		txdisable;				/* Disable transmitter */
+	int 	rxdisable;				/* Disable receiver */
+	
+	
+	/* Tone zone stuff */
+	struct zt_zone *curzone;		/* Zone for selecting tones */
+	int 	tonezone;				/* Tone zone for this channel */
+	struct zt_tone *curtone;		/* Current tone we're playing (if any) */
+	int		tonep;					/* Current position in tone */
+	struct zt_tone_state ts;		/* Tone state */
+
+	/* Pulse dial stuff */
+	int	pdialcount;			/* pulse dial count */
+
+	/* Ring cadence */
+	int ringcadence[ZT_MAX_CADENCE];
+	int firstcadencepos;				/* Where to restart ring cadence */
+
+	/* Digit string dialing stuff */
+	int		digitmode;			/* What kind of tones are we sending? */
+	char	txdialbuf[ZT_MAX_DTMF_BUF];
+	int 	dialing;
+	int	afterdialingtimer;
+	int		cadencepos;				/* Where in the cadence we are */
+
+	/* I/O Mask */	
+	int		iomask;  /* I/O Mux signal mask */
+	wait_queue_head_t sel;	/* thingy for select stuff */
+	
+	/* HDLC state machines */
+	struct fasthdlc_state txhdlc;
+	struct fasthdlc_state rxhdlc;
+	int infcs;
+
+	/* Conferencing stuff */
+	int		confna;	/* conference number (alias) */
+	int		_confn;	/* Actual conference number */
+	int		confmode;  /* conference mode */
+	int		confmute; /* conference mute mode */
+
+	/* Incoming and outgoing conference chunk queues for
+	   communicating between zaptel master time and
+	   other boards */
+	struct confq confin;
+	struct confq confout;
+
+	short	getlin[ZT_MAX_CHUNKSIZE];			/* Last transmitted samples */
+	unsigned char getraw[ZT_MAX_CHUNKSIZE];		/* Last received raw data */
+	short	getlin_lastchunk[ZT_MAX_CHUNKSIZE];	/* Last transmitted samples from last chunk */
+	short	putlin[ZT_MAX_CHUNKSIZE];			/* Last received samples */
+	unsigned char putraw[ZT_MAX_CHUNKSIZE];		/* Last received raw data */
+	short	conflast[ZT_MAX_CHUNKSIZE];			/* Last conference sample -- base part of channel */
+	short	conflast1[ZT_MAX_CHUNKSIZE];		/* Last conference sample  -- pseudo part of channel */
+	short	conflast2[ZT_MAX_CHUNKSIZE];		/* Previous last conference sample -- pseudo part of channel */
+	
+
+	/* Is echo cancellation enabled or disabled */
+	int		echocancel;
+	struct echo_can_state	*ec;
+	echo_can_disable_detector_state_t txecdis;
+	echo_can_disable_detector_state_t rxecdis;
+	
+	int		echostate;		/* State of echo canceller */
+	int		echolastupdate;		/* Last echo can update pos */
+	int		echotimer;		/* Timer for echo update */
+
+	/* RBS timings  */
+	int		prewinktime;  /* pre-wink time (ms) */
+	int		preflashtime;	/* pre-flash time (ms) */
+	int		winktime;  /* wink time (ms) */
+	int		flashtime;  /* flash time (ms) */
+	int		starttime;  /* start time (ms) */
+	int		rxwinktime;  /* rx wink time (ms) */
+	int		rxflashtime; /* rx flash time (ms) */
+	int		debouncetime;  /* FXS GS sig debounce time (ms) */
+	int		pulsebreaktime; /* pulse line open time (ms) */
+	int		pulsemaketime;  /* pulse line closed time (ms) */
+	int		pulseaftertime; /* pulse time between digits (ms) */
+
+	/* RING debounce timer */
+	int	ringdebtimer;
+	
+	/* RING trailing detector to make sure a RING is really over */
+	int ringtrailer;
+
+	/* PULSE digit receiver stuff */
+	int	pulsecount;
+	int	pulsetimer;
+
+	/* RBS timers */
+	int 	itimerset;		/* what the itimer was set to last */
+	int 	itimer;
+	int 	otimer;
+	
+	/* RBS state */
+	int gotgs;
+	int txstate;
+	int rxsig;
+	int txsig;
+	int rxsigstate;
+
+	/* non-RBS rx state */
+	int rxhooksig;
+	int txhooksig;
+	int kewlonhook;
+
+	/* Idle signalling if CAS signalling */
+	int idlebits;
+
+	int deflaw;		/* 1 = mulaw, 2=alaw, 0=undefined */
+	short *xlaw;
+#ifdef	OPTIMIZE_CHANMUTE
+	int chanmute;		/*!< no need for PCM data */
+#endif
+#ifdef CONFIG_CALC_XLAW
+	unsigned char (*lineartoxlaw)(short a);
+#else
+	unsigned char *lin2x;
+#endif
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_handle_t fhandle;  /* File handle in devfs for the channel */
+	devfs_handle_t fhandle_symlink;
+#endif /* CONFIG_DEVFS_FS */
+};
+
+/* defines for transmit signalling */
+typedef enum {
+	ZT_TXSIG_ONHOOK,			/* On hook */
+	ZT_TXSIG_OFFHOOK,			/* Off hook */
+	ZT_TXSIG_START,				/* Start / Ring */
+	ZT_TXSIG_KEWL				/* Drop battery if possible */
+} zt_txsig_t;
+
+typedef enum {
+	ZT_RXSIG_ONHOOK,
+	ZT_RXSIG_OFFHOOK,
+	ZT_RXSIG_START,
+	ZT_RXSIG_RING,
+	ZT_RXSIG_INITIAL
+} zt_rxsig_t;
+	
+/* Span flags */
+#define ZT_FLAG_REGISTERED		(1 << 0)
+#define ZT_FLAG_RUNNING			(1 << 1)
+#define ZT_FLAG_RBS			(1 << 12)	/* Span uses RBS signalling */
+
+/* Channel flags */
+#define ZT_FLAG_DTMFDECODE		(1 << 2)	/* Channel supports native DTMF decode */
+#define ZT_FLAG_MFDECODE		(1 << 3)	/* Channel supports native MFr2 decode */
+#define ZT_FLAG_ECHOCANCEL		(1 << 4)	/* Channel supports native echo cancellation */
+
+#define ZT_FLAG_HDLC			(1 << 5)	/* Perform HDLC */
+#define ZT_FLAG_NETDEV			(1 << 6)	/* Send to network */
+#define ZT_FLAG_PSEUDO			(1 << 7)	/* Pseudo channel */
+#define ZT_FLAG_CLEAR			(1 << 8)	/* Clear channel */
+#define ZT_FLAG_AUDIO			(1 << 9)	/* Audio mode channel */
+
+#define ZT_FLAG_OPEN			(1 << 10)	/* Channel is open */
+#define ZT_FLAG_FCS			(1 << 11)	/* Calculate FCS */
+/* Reserve 12 for uniqueness with span flags */
+#define ZT_FLAG_LINEAR			(1 << 13)	/* Talk to user space in linear */
+#define ZT_FLAG_PPP			(1 << 14)	/* PPP is available */
+#define ZT_FLAG_T1PPP			(1 << 15)
+#define ZT_FLAG_SIGFREEZE		(1 << 16)	/* Freeze signalling */
+#define ZT_FLAG_NOSTDTXRX		(1 << 17)	/* Do NOT do standard transmit and receive on every interrupt */
+#define ZT_FLAG_LOOPED			(1 << 18)	/* Loopback the receive data from the channel to the transmit */
+#define ZT_FLAG_MTP2			(1 << 19)	/* Repeats last message in buffer and also discards repeating messages sent to us */
+
+/* This is a redefinition of the flags from above to allow use of the kernel atomic bit testing and changing routines.
+ * See the above descriptions for ZT_FLAG_....  for documentation about function. */
+enum {
+	ZT_FLAGBIT_REGISTERED = 0,
+	ZT_FLAGBIT_RUNNING    = 1,
+	ZT_FLAGBIT_RBS	      = 12,
+	ZT_FLAGBIT_DTMFDECODE = 2,
+	ZT_FLAGBIT_MFDECODE   = 3,
+	ZT_FLAGBIT_ECHOCANCEL = 4,
+	ZT_FLAGBIT_HDLC	      = 5,
+	ZT_FLAGBIT_NETDEV     = 6,
+	ZT_FLAGBIT_PSEUDO     = 7,
+	ZT_FLAGBIT_CLEAR      = 8,
+	ZT_FLAGBIT_AUDIO      = 9,
+	ZT_FLAGBIT_OPEN	      = 10,
+	ZT_FLAGBIT_FCS	      = 11,
+	ZT_FLAGBIT_LINEAR     = 13,
+	ZT_FLAGBIT_PPP	      = 14,
+	ZT_FLAGBIT_T1PPP      = 15,
+	ZT_FLAGBIT_SIGFREEZE  = 16,
+	ZT_FLAGBIT_NOSTDTXRX  = 17,
+	ZT_FLAGBIT_LOOPED     = 18,
+	ZT_FLAGBIT_MTP2       = 19,
+};
+
+struct zt_span {
+	spinlock_t lock;
+	void *pvt;			/* Private stuff */
+	char name[40];			/* Span name */
+	char desc[80];			/* Span description */
+	const char *spantype;		/* span type in text form */
+	const char *manufacturer;	/* span's device manufacturer */
+	char devicetype[80];		/* span's device type */
+	char location[40];		/* span device's location in system */
+	int deflaw;			/* Default law (ZT_MULAW or ZT_ALAW) */
+	int alarms;			/* Pending alarms on span */
+	int flags;
+	int irq;			/* IRQ for this span's hardware */
+	int lbo;			/* Span Line-Buildout */
+	int lineconfig;			/* Span line configuration */
+	int linecompat;			/* Span line compatibility */
+	int channels;			/* Number of channels in span */
+	int txlevel;			/* Tx level */
+	int rxlevel;			/* Rx level */
+	int syncsrc;			/* current sync src (gets copied here) */
+	unsigned int bpvcount;		/* BPV counter */
+	unsigned int crc4count;	        /* CRC4 error counter */
+	unsigned int ebitcount;		/* current E-bit error count */
+	unsigned int fascount;		/* current FAS error count */
+
+	int maintstat;			/* Maintenance state */
+	wait_queue_head_t maintq;	/* Maintenance queue */
+	int mainttimer;			/* Maintenance timer */
+	
+	int irqmisses;			/* Interrupt misses */
+
+	int timingslips;			/* Clock slips */
+
+	struct zt_chan *chans;		/* Member channel structures */
+
+	/*   ==== Span Callback Operations ====   */
+	/* Req: Set the requested chunk size.  This is the unit in which you must
+	   report results for conferencing, etc */
+	int (*setchunksize)(struct zt_span *span, int chunksize);
+
+	/* Opt: Configure the span (if appropriate) */
+	int (*spanconfig)(struct zt_span *span, struct zt_lineconfig *lc);
+	
+	/* Opt: Start the span */
+	int (*startup)(struct zt_span *span);
+	
+	/* Opt: Shutdown the span */
+	int (*shutdown)(struct zt_span *span);
+	
+	/* Opt: Enable maintenance modes */
+	int (*maint)(struct zt_span *span, int mode);
+
+#ifdef	ZAPTEL_SYNC_TICK
+	/* Opt: send sync to spans */
+	int (*sync_tick)(struct zt_span *span, int is_master);
+#endif
+
+	/* ====  Channel Callback Operations ==== */
+	/* Opt: Set signalling type (if appropriate) */
+	int (*chanconfig)(struct zt_chan *chan, int sigtype);
+
+	/* Opt: Prepare a channel for I/O */
+	int (*open)(struct zt_chan *chan);
+
+	/* Opt: Close channel for I/O */
+	int (*close)(struct zt_chan *chan);
+	
+	/* Opt: IOCTL */
+	int (*ioctl)(struct zt_chan *chan, unsigned int cmd, unsigned long data);
+	
+	/* Opt: Native echo cancellation (simple) */
+	int (*echocan)(struct zt_chan *chan, int ecval);
+
+	int (*echocan_with_params)(struct zt_chan *chan, struct zt_echocanparams *ecp, struct zt_echocanparam *p);
+
+	/* Okay, now we get to the signalling.  You have several options: */
+
+	/* Option 1: If you're a T1 like interface, you can just provide a
+	   rbsbits function and we'll assert robbed bits for you.  Be sure to 
+	   set the ZT_FLAG_RBS in this case.  */
+
+	/* Opt: If the span uses A/B bits, set them here */
+	int (*rbsbits)(struct zt_chan *chan, int bits);
+	
+	/* Option 2: If you don't know about sig bits, but do have their
+	   equivalents (i.e. you can disconnect battery, detect off hook,
+	   generate ring, etc directly) then you can just specify a
+	   sethook function, and we'll call you with appropriate hook states
+	   to set.  Still set the ZT_FLAG_RBS in this case as well */
+	int (*hooksig)(struct zt_chan *chan, zt_txsig_t hookstate);
+	
+	/* Option 3: If you can't use sig bits, you can write a function
+	   which handles the individual hook states  */
+	int (*sethook)(struct zt_chan *chan, int hookstate);
+	
+	/* Opt: Dacs the contents of chan2 into chan1 if possible */
+	int (*dacs)(struct zt_chan *chan1, struct zt_chan *chan2);
+
+	/* Opt: Used to tell an onboard HDLC controller that there is data ready to transmit */
+	void (*hdlc_hard_xmit)(struct zt_chan *chan);
+
+	/* Used by zaptel only -- no user servicable parts inside */
+	int spanno;			/* Span number for zaptel */
+	int offset;			/* Offset within a given card */
+	int lastalarms;		/* Previous alarms */
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_handle_t dhandle;  /* Directory name */
+#endif	
+	/* If the watchdog detects no received data, it will call the
+	   watchdog routine */
+	int (*watchdog)(struct zt_span *span, int cause);
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+	int watchcounter;
+	int watchstate;
+#endif	
+};
+
+struct zt_transcoder_channel {
+	void *pvt;
+	struct zt_transcoder *parent;
+	wait_queue_head_t ready;
+	int errorstatus;
+	int offset;
+	unsigned int chan_built;
+	unsigned int built_fmts;
+	unsigned int flags;
+	unsigned int srcfmt;
+	unsigned int dstfmt;
+	struct zt_transcode_header *tch;
+};
+
+#define ZT_TC_FLAG_BUSY       (1 << 0)
+#define ZT_TC_FLAG_TRANSIENT  (1 << 1)
+
+
+struct zt_transcoder {
+	struct zt_transcoder *next;
+	char name[80];
+	int numchannels;
+	unsigned int srcfmts;
+	unsigned int dstfmts;
+	int (*operation)(struct zt_transcoder_channel *channel, int op);
+	/* Transcoder channels */
+	struct zt_transcoder_channel channels[0];
+};
+
+#define ZT_WATCHDOG_NOINTS		(1 << 0)
+
+#define ZT_WATCHDOG_INIT			1000
+
+#define ZT_WATCHSTATE_UNKNOWN		0
+#define ZT_WATCHSTATE_OK			1
+#define ZT_WATCHSTATE_RECOVERING	2
+#define ZT_WATCHSTATE_FAILED		3
+
+
+struct zt_dynamic_driver {
+	/* Driver name (e.g. Eth) */
+	char name[20];
+
+	/* Driver description */
+	char desc[80];
+
+	/* Create a new transmission pipe */
+	void *(*create)(struct zt_span *span, char *address);
+
+	/* Destroy a created transmission pipe */
+	void (*destroy)(void *tpipe);
+
+	/* Transmit a given message */
+	int (*transmit)(void *tpipe, unsigned char *msg, int msglen);
+
+	/* Flush any pending messages */
+	int (*flush)(void);
+
+	struct zt_dynamic_driver *next;
+};
+
+/* Receive a dynamic span message */
+void zt_dynamic_receive(struct zt_span *span, unsigned char *msg, int msglen);
+
+/* Register a dynamic driver */
+int zt_dynamic_register(struct zt_dynamic_driver *driver);
+
+/* Unregister a dynamic driver */
+void zt_dynamic_unregister(struct zt_dynamic_driver *driver);
+
+/* Receive on a span.  The zaptel interface will handle all the calculations for
+   all member channels of the span, pulling the data from the readchunk buffer */
+int zt_receive(struct zt_span *span);
+
+/* Prepare writechunk buffers on all channels for this span */
+int zt_transmit(struct zt_span *span);
+
+/* Abort the buffer currently being receive with event "event" */
+void zt_hdlc_abort(struct zt_chan *ss, int event);
+
+/* Indicate to zaptel that the end of frame was received and rotate buffers */
+void zt_hdlc_finish(struct zt_chan *ss);
+
+/* Put a chunk of data into the current receive buffer */
+void zt_hdlc_putbuf(struct zt_chan *ss, unsigned char *rxb, int bytes);
+
+/* Get a chunk of data from the current transmit buffer.  Returns -1 if no data
+ * is left to send, 0 if there is data remaining in the current message to be sent
+ * and 1 if the currently transmitted message is now done */
+int zt_hdlc_getbuf(struct zt_chan *ss, unsigned char *bufptr, unsigned int *size);
+
+
+/* Register a span.  Returns 0 on success, -1 on failure.  Pref-master is non-zero if
+   we should have preference in being the master device */
+int zt_register(struct zt_span *span, int prefmaster);
+
+/* Allocate / free memory for a transcoder */
+struct zt_transcoder *zt_transcoder_alloc(int numchans);
+void zt_transcoder_free(struct zt_transcoder *ztc);
+
+/* Register a transcoder */
+int zt_transcoder_register(struct zt_transcoder *tc);
+
+/* Unregister a transcoder */
+int zt_transcoder_unregister(struct zt_transcoder *tc);
+
+/* Alert a transcoder */
+int zt_transcoder_alert(struct zt_transcoder_channel *ztc);
+
+/* Unregister a span */
+int zt_unregister(struct zt_span *span);
+
+/* Gives a name to an LBO */
+char *zt_lboname(int lbo);
+
+/* Tell Zaptel about changes in received rbs bits */
+void zt_rbsbits(struct zt_chan *chan, int bits);
+
+/* Tell Zaptel abou changes in received signalling */
+void zt_hooksig(struct zt_chan *chan, zt_rxsig_t rxsig);
+
+/* Queue an event on a channel */
+void zt_qevent_nolock(struct zt_chan *chan, int event);
+
+/* Queue an event on a channel, locking it first */
+void zt_qevent_lock(struct zt_chan *chan, int event);
+
+/* Notify a change possible change in alarm status on a channel */
+void zt_alarm_channel(struct zt_chan *chan, int alarms);
+
+/* Notify a change possible change in alarm status on a span */
+void zt_alarm_notify(struct zt_span *span);
+
+/* Initialize a tone state */
+void zt_init_tone_state(struct zt_tone_state *ts, struct zt_tone *zt);
+
+/* Get a given MF tone struct, suitable for zt_tone_nextsample. */
+struct zt_tone *zt_mf_tone(const struct zt_chan *chan, char digit, int digitmode);
+
+/* Echo cancel a receive and transmit chunk for a given channel.  This
+   should be called by the low-level driver as close to the interface
+   as possible.  ECHO CANCELLATION IS NO LONGER AUTOMATICALLY DONE
+   AT THE ZAPTEL LEVEL.  zt_ec_chunk will not echo cancel if it should
+   not be doing so.  rxchunk is modified in-place */
+
+void zt_ec_chunk(struct zt_chan *chan, unsigned char *rxchunk, const unsigned char *txchunk);
+void zt_ec_span(struct zt_span *span);
+
+extern struct file_operations *zt_transcode_fops;
+
+/* Don't use these directly -- they're not guaranteed to
+   be there. */
+extern short __zt_mulaw[256];
+extern short __zt_alaw[256];
+#ifdef CONFIG_CALC_XLAW
+u_char __zt_lineartoulaw(short a);
+u_char __zt_lineartoalaw(short a);
+#else
+extern u_char __zt_lin2mu[16384];
+extern u_char __zt_lin2a[16384];
+#endif
+
+/* Used by dynamic zaptel -- don't use directly */
+void zt_set_dynamic_ioctl(int (*func)(unsigned int cmd, unsigned long data));
+
+/* Used privately by zaptel.  Avoid touching directly */
+struct zt_tone {
+	int fac1;
+	int init_v2_1;
+	int init_v3_1;
+
+	int fac2;
+	int init_v2_2;
+	int init_v3_2;
+
+	int tonesamples;		/* How long to play this tone before 
+					   going to the next (in samples) */
+	struct zt_tone *next;		/* Next tone in this sequence */
+
+	int modulate;
+};
+
+static inline short zt_tone_nextsample(struct zt_tone_state *ts, struct zt_tone *zt)
+{
+	/* follow the curves, return the sum */
+
+	int p;
+
+	ts->v1_1 = ts->v2_1;
+	ts->v2_1 = ts->v3_1;
+	ts->v3_1 = (zt->fac1 * ts->v2_1 >> 15) - ts->v1_1;
+
+	ts->v1_2 = ts->v2_2;
+	ts->v2_2 = ts->v3_2;
+	ts->v3_2 = (zt->fac2 * ts->v2_2 >> 15) - ts->v1_2;
+
+	/* Return top 16 bits */
+	if (!ts->modulate) return ts->v3_1 + ts->v3_2;
+	/* we are modulating */
+	p = ts->v3_2 - 32768;
+	if (p < 0) p = -p;
+	p = ((p * 9) / 10) + 1;
+	return (ts->v3_1 * p) >> 15;
+
+}
+
+static inline short zt_txtone_nextsample(struct zt_chan *ss)
+{
+	/* follow the curves, return the sum */
+
+	ss->v1_1 = ss->v2_1;
+	ss->v2_1 = ss->v3_1;
+	ss->v3_1 = (ss->txtone * ss->v2_1 >> 15) - ss->v1_1;
+	return ss->v3_1;
+}
+
+/* These are the right functions to use.  */
+
+#define ZT_MULAW(a) (__zt_mulaw[(a)])
+#define ZT_ALAW(a) (__zt_alaw[(a)])
+#define ZT_XLAW(a,c) (c->xlaw[(a)])
+
+#ifdef CONFIG_CALC_XLAW
+#define ZT_LIN2MU(a) (__zt_lineartoulaw((a)))
+#define ZT_LIN2A(a) (__zt_lineartoalaw((a)))
+
+#define ZT_LIN2X(a,c) ((c)->lineartoxlaw((a)))
+
+#else
+/* Use tables */
+#define ZT_LIN2MU(a) (__zt_lin2mu[((unsigned short)(a)) >> 2])
+#define ZT_LIN2A(a) (__zt_lin2a[((unsigned short)(a)) >> 2])
+
+/* Manipulate as appropriate for x-law */
+#define ZT_LIN2X(a,c) ((c)->lin2x[((unsigned short)(a)) >> 2])
+
+#endif /* CONFIG_CALC_XLAW */
+
+#endif /* __KERNEL__ */
+
+/* The following is for the PCI RADIO interface only. This is specified in
+this file because external processes need to interact with the device.
+Some devices have private functions used for test/diagnostic only, but
+this is not the case here. */
+
+struct zt_radio_stat {
+	unsigned short ctcode_rx;	/* code of currently received CTCSS 
+					   or DCS, 0 for none */
+	unsigned short ctclass;		/* class of currently received CTCSS or
+					    DCS code */
+	unsigned short ctcode_tx;	/* code of currently encoded CTCSS or
+					   DCS, 0 for none */
+	unsigned char radstat;		/* status bits of radio */
+};
+
+#define	RAD_SERIAL_BUFLEN 128
+
+struct zt_radio_param {
+	unsigned short radpar;	/* param identifier */
+	unsigned short index;	/* tone number */
+	int data;		/* param */
+	int data2;		/* param 2 */
+	unsigned char buf[RAD_SERIAL_BUFLEN];
+};
+
+
+/* Get current status IOCTL */
+#define	ZT_RADIO_GETSTAT	_IOR (ZT_CODE, 57, struct zt_radio_stat)
+/* Set a channel parameter IOCTL */
+#define	ZT_RADIO_SETPARAM	_IOW (ZT_CODE, 58, struct zt_radio_param)
+/* Get a channel parameter IOCTL */
+#define	ZT_RADIO_GETPARAM	_IOR (ZT_CODE, 59, struct zt_radio_param)
+
+
+/* Defines for Radio Status (zt_radio_stat.radstat) bits */
+
+#define	ZT_RADSTAT_RX	1	/* currently "receiving " */
+#define	ZT_RADSTAT_TX	2	/* currently "transmitting" */
+#define	ZT_RADSTAT_RXCT	4	/* currently receiving continuous tone with 
+				   current settings */
+#define	ZT_RADSTAT_RXCOR	8	/* currently receiving COR (irrelevant of COR
+				   ignore) */
+#define	ZT_RADSTAT_IGNCOR	16	/* currently ignoring COR */
+#define	ZT_RADSTAT_IGNCT	32	/* currently ignoring CTCSS/DCS decode */
+#define	ZT_RADSTAT_NOENCODE 64	/* currently blocking CTCSS/DCS encode */
+
+/* Defines for Radio Parameters (zt_radio_param.radpar) */
+
+#define	ZT_RADPAR_INVERTCOR 1	/* invert the COR signal (0/1) */
+#define	ZT_RADPAR_IGNORECOR 2	/* ignore the COR signal (0/1) */
+#define	ZT_RADPAR_IGNORECT 3	/* ignore the CTCSS/DCS decode (0/1) */
+#define	ZT_RADPAR_NOENCODE 4	/* block the CTCSS/DCS encode (0/1) */
+#define	ZT_RADPAR_CORTHRESH 5	/* COR trigger threshold (0-7) */
+
+#define	ZT_RADPAR_EXTRXTONE 6	/* 0 means use internal decoder, 1 means UIOA
+				   logic true is CT decode, 2 means UIOA logic
+				   false is CT decode */
+#define	ZT_RADPAR_NUMTONES	7	/* returns maximum tone index (curently 15) */
+#define	ZT_RADPAR_INITTONE	8	/* init all tone indexes to 0 (no tones) */
+#define	ZT_RADPAR_RXTONE	9	/* CTCSS tone, (1-32) or DCS tone (1-777),
+				   or 0 meaning no tone, set index also (1-15) */
+#define	ZT_RADPAR_RXTONECLASS 10	/* Tone class (0-65535), set index also (1-15) */
+#define	ZT_RADPAR_TXTONE 11	/* CTCSS tone (1-32) or DCS tone (1-777) or 0
+				   to indicate no tone, to transmit 
+				   for this tone index (0-32, 0 disables
+				   transmit CTCSS), set index also (0-15) */
+#define	ZT_RADPAR_DEBOUNCETIME 12	/* receive indication debounce time, 
+				   milliseconds (1-999) */
+#define	ZT_RADPAR_BURSTTIME 13	/* end of transmit with no CT tone in
+				   milliseconds (0-999) */
+
+
+#define	ZT_RADPAR_UIODATA 14	/* read/write UIOA and UIOB data. Bit 0 is
+				   UIOA, bit 1 is UIOB */
+#define	ZT_RADPAR_UIOMODE 15	/* 0 means UIOA and UIOB are both outputs, 1
+				   means UIOA is input, UIOB is output, 2 
+				   means UIOB is input and UIOA is output,
+				   3 means both UIOA and UIOB are inputs. Note
+				   mode for UIOA is overridden when in
+				   EXTRXTONE mode. */
+
+#define	ZT_RADPAR_REMMODE 16	/* Remote control data mode */
+	#define	ZT_RADPAR_REM_NONE 0 	/* no remote control data mode */
+	#define	ZT_RADPAR_REM_RBI1 1	/* Doug Hall RBI-1 data mode */
+	#define	ZT_RADPAR_REM_SERIAL 2	/* Serial Data, 9600 BPS */
+	#define	ZT_RADPAR_REM_SERIAL_ASCII 3	/* Serial Ascii Data, 9600 BPS */
+
+#define	ZT_RADPAR_REMCOMMAND 17	/* Remote conrtol write data block & do cmd */
+
+/* Data formats for capabilities and frames alike (from Asterisk) */
+/*! G.723.1 compression */
+#define ZT_FORMAT_G723_1	(1 << 0)
+/*! GSM compression */
+#define ZT_FORMAT_GSM		(1 << 1)
+/*! Raw mu-law data (G.711) */
+#define ZT_FORMAT_ULAW		(1 << 2)
+/*! Raw A-law data (G.711) */
+#define ZT_FORMAT_ALAW		(1 << 3)
+/*! ADPCM (G.726, 32kbps) */
+#define ZT_FORMAT_G726		(1 << 4)
+/*! ADPCM (IMA) */
+#define ZT_FORMAT_ADPCM		(1 << 5)
+/*! Raw 16-bit Signed Linear (8000 Hz) PCM */
+#define ZT_FORMAT_SLINEAR	(1 << 6)
+/*! LPC10, 180 samples/frame */
+#define ZT_FORMAT_LPC10		(1 << 7)
+/*! G.729A audio */
+#define ZT_FORMAT_G729A		(1 << 8)
+/*! SpeeX Free Compression */
+#define ZT_FORMAT_SPEEX		(1 << 9)
+/*! iLBC Free Compression */
+#define ZT_FORMAT_ILBC		(1 << 10)
+/*! Maximum audio format */
+#define ZT_FORMAT_MAX_AUDIO	(1 << 15)
+/*! Maximum audio mask */
+#define ZT_FORMAT_AUDIO_MASK	((1 << 16) - 1)
+
+#define	ZT_RADPAR_DEEMP 18 /* Audio De-empahsis (on or off) */ 
+
+#define	ZT_RADPAR_PREEMP 19 /* Audio Pre-empahsis (on or off) */ 
+
+#define	ZT_RADPAR_RXGAIN 20 /* Audio (In to system) Rx Gain */ 
+
+#define	ZT_RADPAR_TXGAIN 21 /* Audio (Out from system) Tx Gain */ 
+
+struct torisa_debug {
+	unsigned int txerrors;
+	unsigned int irqcount;
+	unsigned int taskletsched;
+	unsigned int taskletrun;
+	unsigned int taskletexec;
+	int span1flags;
+	int span2flags;
+};
+
+/* Special torisa ioctl */
+#define TORISA_GETDEBUG		_IOW (ZT_CODE, 60, struct torisa_debug)
+
+/*!
+	\brief Size-limited null-terminating string copy.
+	\param dst The destination buffer
+	\param src The source string
+	\param size The size of the destination buffer
+	\return Nothing.
+
+	This is similar to \a strncpy, with two important differences:
+	- the destination buffer will \b always be null-terminated
+	- the destination buffer is not filled with zeros past the copied string length
+	These differences make it slightly more efficient, and safer to use since it will
+	not leave the destination buffer unterminated. There is no need to pass an artificially
+	reduced buffer size to this function (unlike \a strncpy), and the buffer does not need
+	to be initialized to zeroes prior to calling this function.
+*/
+static inline void zap_copy_string(char *dst, const char *src, unsigned int size)
+{
+	while (*src && size) {
+		*dst++ = *src++;
+		size--;
+	}
+	if (__builtin_expect(!size, 0))
+		dst--;
+	*dst = '\0';
+}
+
+#endif /* _LINUX_ZAPTEL_H */
diff -urN zaptel-1.4.11.org/kernel/zconfig.h zaptel-1.4.11/kernel/zconfig.h
--- zaptel-1.4.11.org/kernel/zconfig.h	2008-02-05 00:00:48.000000000 +0100
+++ zaptel-1.4.11/kernel/zconfig.h	2008-07-16 22:06:17.204532637 +0200
@@ -194,4 +194,10 @@
  */
 /* #define	OPTIMIZE_CHANMUTE */
 
+/*
+ * Uncomment the following for BRI D channels
+ *
+ */
+#define CONFIG_ZAPATA_BRI_DCHANS
+
 #endif
diff -urN zaptel-1.4.11.org/kernel/zconfig.h.orig zaptel-1.4.11/kernel/zconfig.h.orig
--- zaptel-1.4.11.org/kernel/zconfig.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/zconfig.h.orig	2008-07-16 22:06:17.204532637 +0200
@@ -0,0 +1,197 @@
+/*
+ * Zaptel configuration options 
+ *
+ */
+#ifndef _ZCONFIG_H
+#define _ZCONFIG_H
+
+#ifdef __KERNEL__
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#endif
+
+/* Zaptel compile time options */
+
+/*
+ * Uncomment if you have a European phone, or any other phone with a 
+ *  short flash time.
+ * This will stop the flash being mis-detected as a pulse dial "1" on
+ *  phones with short flashes
+ */
+/* #define SHORT_FLASH_TIME */
+
+/*
+ * Uncomment to disable calibration and/or DC/DC converter tests
+ * (not generally recommended)
+ */
+/* #define NO_CALIBRATION */
+/* #define NO_DCDC */
+
+/*
+ * Boost ring voltage (Higher ring voltage, takes more power)
+ * Note: this only affects the wcfxsusb and wcusb drivers; all other
+ *       drivers have a 'boostringer' module parameter.
+ */
+/* #define BOOST_RINGER */
+
+/*
+ * Define CONFIG_CALC_XLAW if you have a small number of channels and/or
+ * a small level 2 cache, to optimize for few channels
+ *
+ */
+/* #define CONFIG_CALC_XLAW */
+
+/*
+ * Define if you want MMX optimizations in zaptel
+ *
+ * Note: CONFIG_ZAPTEL_MMX is generally incompatible with AMD 
+ * processors and can cause system instability!
+ * 
+ */
+/* #define CONFIG_ZAPTEL_MMX */
+
+/** If defined: the user must define exactly one ECHO_CAN_ var: */
+#ifndef ECHO_CAN_FROMENV 
+
+/*
+ * Pick your echo canceller: MARK2, MARK3, STEVE, or STEVE2 :)
+ * 
+ */ 
+/* #define ECHO_CAN_STEVE */
+/* #define ECHO_CAN_STEVE2 */
+/* #define ECHO_CAN_KB1 */
+/* This is the new latest and greatest */
+#define ECHO_CAN_MG2
+
+/*
+ * This is only technically an "echo canceller"...
+ * It purposely drops 2 out of 3 samples and sounds horrible.
+ * You really only want this for testing "echo cancelled" audio.
+ */
+/* #define ECHO_CAN_JP1 */
+
+/*
+ * Uncomment for aggressive residual echo suppression under 
+ * MARK2, KB1, and MG2 echo canceler
+ */
+/* #define AGGRESSIVE_SUPPRESSOR */
+#endif /* ifndef ECHO_CAN_FROMENV */
+/*
+ * Define to turn off the echo canceler disable tone detector,
+ * which will cause zaptel to ignore the 2100 Hz echo cancel disable
+ * tone.
+ */
+/* #define NO_ECHOCAN_DISABLE */
+
+/* udev support */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,1)
+#define CONFIG_ZAP_UDEV
+#endif
+
+/* We now use the linux kernel config to detect which options to use */
+/* You can still override them below */
+#if defined(CONFIG_HDLC) || defined(CONFIG_HDLC_MODULE)
+/* #define CONFIG_ZAPATA_NET */  /* NEVER implicitly turn on ZAPATA_NET */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,20)
+#define CONFIG_OLD_HDLC_API
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,23)
+/* Starting with 2.4.23 the kernel hdlc api changed again */
+/* Now we have to use hdlc_type_trans(skb, dev) instead of htons(ETH_P_HDLC) */
+#define ZAP_HDLC_TYPE_TRANS
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3)
+#define HDLC_MAINTAINERS_ARE_MORE_STUPID_THAN_I_THOUGHT
+#endif
+#endif
+#endif
+#ifdef CONFIG_PPP
+#define CONFIG_ZAPATA_PPP
+#endif
+
+/*
+ * Uncomment CONFIG_ZAPATA_NET to enable SyncPPP, CiscoHDLC, and Frame Relay
+ * support.
+ */
+/* #define CONFIG_ZAPATA_NET */
+
+/*
+ * Uncomment CONFIG_OLD_HDLC_API if your are compiling with ZAPATA_NET
+ * defined and you are using the old kernel HDLC interface (or if you get
+ * an error about ETH_P_HDLC while compiling).
+ */
+/* #define CONFIG_OLD_HDLC_API */
+
+/*
+ * Uncomment for Generic PPP support (i.e. ZapRAS)
+ */
+/* #define CONFIG_ZAPATA_PPP */
+/*
+ * Uncomment to enable "watchdog" to monitor if interfaces
+ * stop taking interrupts or otherwise misbehave
+ */
+/* #define CONFIG_ZAPTEL_WATCHDOG */
+
+/*
+ * Uncomment for Non-standard FXS groundstart start state (A=Low, B=Low)
+ * particularly for CAC channel bank groundstart FXO ports.
+ */
+/* #define CONFIG_CAC_GROUNDSTART */
+
+/* 
+ * Uncomment if you happen have an early TDM400P Rev H which 
+ * sometimes forgets its PCI ID to have wcfxs match essentially all
+ * subvendor ID's
+ */
+/* #define TDM_REVH_MATCHALL */
+
+/* 
+ * Uncomment the following if you want to support E&M trunks being
+ * able to "flash" after going off-hook (dont ask why, just nod :-) ).
+ *
+ * NOTE: *DO NOT* Enable "EMFLASH" and "EMPULSE" at the same time!!
+ *
+ */
+/* #define EMFLASH */
+
+/* 
+ * Uncomment the following if you want to support E&M trunks being
+ * able to recognize Dial Pulse digits. This can validly be enabled
+ * so that either Dial Pulse or DTMF/MF tones will be recognized, but
+ * the drawback is that the ONHOOK will take an extra {rxwinktime}
+ * to be recognized.
+ *
+ * NOTE: *DO NOT* Enable "EMFLASH" and "EMPULSE" at the same time!!
+ *
+ */
+/* #define EMPULSE */
+
+/* 
+ * Comment out the following if you dont want events to indicate the
+ * beginning of an incoming ring. Most non-Asterisk applications will
+ * want this commented out.
+ */
+#define RINGBEGIN
+
+/* 
+ * Uncomment the following if you need to support FXS Flash events.
+ * Most applications will want this commented out.
+ */
+/* #define FXSFLASH */
+
+/*
+ * Enable sync_tick() calls. Allows low-level drivers to synchronize
+ * their internal clocks to the zaptel master clock.
+ */
+#define ZAPTEL_SYNC_TICK
+
+/*
+ * Skip processing PCM if low-level driver won't use it anyway
+ */
+/* #define	OPTIMIZE_CHANMUTE */
+
+#endif
diff -urN zaptel-1.4.11.org/kernel/ztgsm/Kbuild zaptel-1.4.11/kernel/ztgsm/Kbuild
--- zaptel-1.4.11.org/kernel/ztgsm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/Kbuild	2008-07-16 22:22:15.004384560 +0200
@@ -0,0 +1,9 @@
+obj-m += ztgsm.o
+
+FIRM_DIR	:= ../../firmware
+
+EXTRA_CFLAGS := -I$(src)/.. -Wno-undef -DSTANDALONE_ZAPATA -DBUILDING_TONEZONE -DHOTPLUG_FIRMWARE
+
+
+
+
diff -urN zaptel-1.4.11.org/kernel/ztgsm/Makefile zaptel-1.4.11/kernel/ztgsm/Makefile
--- zaptel-1.4.11.org/kernel/ztgsm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/Makefile	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,51 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel")
+
+CFLAGS+=-I. $(ZAP) -O2 -g -Wall -DBUILDING_TONEZONE  #-DTONEZONE_DRIVER
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP)
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+OBJS=ztgsm.o
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+MODULES=ztgsm
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+linux26:
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+obj-m := $(OBJS)
+
+ztgsm.o: ztgsm.c ztgsm.h 
+	$(CC) -c ztgsm.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	rm -rf .tmp_versions
+
+install:	install$(BUILDVER)
+
+installlinux26: all
+	install -D -m 644 ztgsm.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/ztgsm.ko
+
+installlinux24: all
+	install -D -m 644 ztgsm.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/ztgsm.o
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.duoGSM zaptel-1.4.11/kernel/ztgsm/zapata.conf.duoGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.duoGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zapata.conf.duoGSM	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,23 @@
+[channels]
+txgain = -10.0
+rxgain = 0.0
+
+signalling = gsm
+context = from-gsm
+
+;group=1
+
+; phone number for SIM card in slot A
+;exten=016012345671
+; PIN for SIM card in slot A
+;pin=1234
+
+;channel => 1
+
+; phone number for SIM card in slot B
+;exten=016012345672
+; PIN for SIM card in slot B
+;pin=1234
+
+;channel => 3
+
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.quadGSM zaptel-1.4.11/kernel/ztgsm/zapata.conf.quadGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.quadGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zapata.conf.quadGSM	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,36 @@
+[channels]
+txgain = -10.0
+rxgain = 0.0
+
+signalling = gsm
+context = from-gsm
+
+;group=1
+
+; phone number for SIM card in slot A
+;exten=016012345671
+; PIN for SIM card in slot A
+;pin=1234
+
+;channel => 1
+
+; phone number for SIM card in slot B
+;exten=016012345672
+; PIN for SIM card in slot B
+;pin=1234
+
+;channel => 3
+
+; phone number for SIM card in slot C
+;exten=016012345673
+; PIN for SIM card in slot C
+;pin=1234
+
+;channel => 5
+
+; phone number for SIM card in slot D
+;exten=016012345674
+; PIN for SIM card in slot D
+;pin=1234
+
+;channel => 7
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.unoGSM zaptel-1.4.11/kernel/ztgsm/zapata.conf.unoGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zapata.conf.unoGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zapata.conf.unoGSM	2008-07-16 22:06:17.257813844 +0200
@@ -0,0 +1,15 @@
+[channels]
+txgain = -10.0
+rxgain = 0.0
+
+signalling = gsm
+context = from-gsm
+
+;group=1
+
+; phone number for SIM card in slot A
+;exten=016012345671
+; PIN for SIM card in slot A
+;pin=1234
+
+;channel => 1
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.duoGSM zaptel-1.4.11/kernel/ztgsm/zaptel.conf.duoGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.duoGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zaptel.conf.duoGSM	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,11 @@
+loadzone=nl
+defaultzone=nl
+
+alaw=1,3
+
+span=1,1,3,ccs,ami
+span=2,2,3,ccs,ami
+
+bchan=1,3
+dchan=2,4
+
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.quadGSM zaptel-1.4.11/kernel/ztgsm/zaptel.conf.quadGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.quadGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zaptel.conf.quadGSM	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,13 @@
+loadzone=nl
+defaultzone=nl
+
+alaw=1,3,5,7
+
+span=1,1,3,ccs,ami
+span=2,2,3,ccs,ami
+span=3,3,3,ccs,ami
+span=4,4,3,ccs,ami
+
+bchan=1,3,5,7
+dchan=2,4,6,8
+
diff -urN zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.unoGSM zaptel-1.4.11/kernel/ztgsm/zaptel.conf.unoGSM
--- zaptel-1.4.11.org/kernel/ztgsm/zaptel.conf.unoGSM	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/zaptel.conf.unoGSM	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,10 @@
+loadzone=nl
+defaultzone=nl
+
+alaw=1
+
+span=1,1,3,ccs,ami
+
+bchan=1
+dchan=2
+
diff -urN zaptel-1.4.11.org/kernel/ztgsm/ztgsm.c zaptel-1.4.11/kernel/ztgsm/ztgsm.c
--- zaptel-1.4.11.org/kernel/ztgsm/ztgsm.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/ztgsm.c	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,1308 @@
+/*
+ * ztgsm.c - Zaptel driver for the uno/duo/quad GSM PCI cards
+ *
+ * Copyright (C) 2005, 2006 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <zaptel.h>
+#include "ztgsm.h"
+
+#ifdef LINUX26
+#include <linux/moduleparam.h>
+#endif
+
+#if CONFIG_PCI
+
+static int debug=0;
+static int pcm_xbar=0;
+static int sim = 0;
+static struct ztgsm_card *ztgsm_dev_list = NULL;
+static int ztgsm_dev_count = 0;
+static int ztgsm_spans = 0;
+static struct pci_dev *multi_gsm = NULL;
+static spinlock_t registerlock = SPIN_LOCK_UNLOCKED;
+static long baudrate=19200;
+
+void ztgsm_init_xbar(struct ztgsm_card *gsmtmp) {
+    int i = 0;
+    for (i=0; i <= 0x01FF; i++) {
+	ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x00000182 | i);
+    }
+}
+
+void ztgsm_switch_on(struct ztgsm_card *gsmtmp, int span) {
+    unsigned long flags;
+    
+    printk(KERN_INFO "ztgsm: Powering up span %d ...", span);
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	gsmtmp->gsmspan[span].led = 0xC1;
+	gsmtmp->dtr_on_off &= ~ (1 << span); 	/* on_off_n low */
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((1000 * HZ) / 1000);
+
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+        gsmtmp->dtr_on_off |= 1 << span;	/* on_off_n high */
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+
+	gsmtmp->power[span] = 1;
+	gsmtmp->gsmspan[span].led = 0x81;
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+    printk(" done.\n");
+    gsmtmp->gsmspan[span].span.alarms = ZT_ALARM_NONE;
+    zt_alarm_notify(&gsmtmp->gsmspan[span].span);
+}
+
+void ztgsm_switch_off(struct ztgsm_card *gsmtmp, int span) {
+    unsigned long flags;
+    gsmtmp->gsmspan[span].span.alarms = ZT_ALARM_RED;
+    zt_alarm_notify(&gsmtmp->gsmspan[span].span);
+
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	gsmtmp->gsmspan[span].led = 0xC0;
+    
+	gsmtmp->dtr_on_off &= ~ (1 << span);	/* on_off_n low */
+	printk(KERN_INFO "ztgsm: Powering down span %d (SER_DTR_ON_OFF %x)...", span, gsmtmp->dtr_on_off);
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((2500 * HZ) / 1000);
+
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+        gsmtmp->dtr_on_off |= (1 << span);	/* on_off_n high */
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+	gsmtmp->power[span] = 0;
+	gsmtmp->gsmspan[span].led = 0x80;
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+    printk(" done.\n");
+}
+
+void ztgsm_switch_on_all(struct ztgsm_card *gsmtmp, int verbose) {
+    unsigned long flags;
+    if (verbose)
+	printk(KERN_INFO "ztgsm: Powering up all spans...");
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	gsmtmp->gsmspan[0].led = 0xC1;
+        gsmtmp->gsmspan[1].led = 0xC1;
+	gsmtmp->gsmspan[2].led = 0xC1;
+        gsmtmp->gsmspan[3].led = 0xC1;
+
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, 0xf0);	/* set ON_OFF_N to low for 1000 ms */
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((1000 * HZ) / 1000);
+
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, 0x0f);	/* set ON_OFF_N to high, DTR to low */
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_RTS_O, 0x0); 		
+
+	gsmtmp->power[0] = 1;
+	gsmtmp->power[1] = 1;
+        gsmtmp->power[2] = 1;
+	gsmtmp->power[3] = 1;
+
+	gsmtmp->gsmspan[0].led = 0x81;
+	gsmtmp->gsmspan[1].led = 0x81;
+	gsmtmp->gsmspan[2].led = 0x81;
+	gsmtmp->gsmspan[3].led = 0x81;
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+    if (verbose)
+	printk(" done.\n");
+}
+
+void ztgsm_switch_off_all(struct ztgsm_card *gsmtmp, int verbose) {
+    unsigned long flags;
+
+    if (gsmtmp->power[0] || gsmtmp->power[1] || gsmtmp->power[2] || gsmtmp->power[3]) { 
+    if (verbose)
+        printk(KERN_INFO "ztgsm: Powering down all spans...");
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	gsmtmp->gsmspan[0].led = 0xC0;
+        gsmtmp->gsmspan[1].led = 0xC0;
+	gsmtmp->gsmspan[2].led = 0xC0;
+        gsmtmp->gsmspan[3].led = 0xC0;
+	
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, 0xf0);
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((2500 * HZ) / 1000);
+
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, 0xff);
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_RTS_O, 0xF); 
+
+	gsmtmp->power[0] = 0;
+	gsmtmp->power[1] = 0;
+        gsmtmp->power[2] = 0;
+	gsmtmp->power[3] = 0;
+
+	gsmtmp->gsmspan[0].led = 0x80;
+	gsmtmp->gsmspan[1].led = 0x80;
+        gsmtmp->gsmspan[2].led = 0x80;
+	gsmtmp->gsmspan[3].led = 0x80;
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+    if (verbose)
+        printk(" done.\n");
+    }
+}
+
+
+void ztgsm_shutdownCard(struct ztgsm_card *gsmtmp) {
+    unsigned long flags;
+    struct ztgsm_span *gsmspan = NULL;
+    int i = 0;
+    unsigned long ioport;
+    unsigned long pci_io_phys;
+    unsigned long iomem_size;
+    void *pci_io;
+
+    if (gsmtmp == NULL) {
+	printk(KERN_INFO "ztgsm: shutting down NULL card!\n");
+	return;
+    }
+    ztgsm_switch_off_all(gsmtmp, 1);
+
+    spin_lock_irqsave(&gsmtmp->lock,flags);
+
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_TX_EN, 0x0);
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_RX_EN, 0x0);
+
+	gsmtmp->dead = 1;
+
+        if ((!gsmtmp->pci_io) || (gsmtmp->ioport == 0)) {
+	    return;
+	}
+	ztgsm_outdw_io(gsmtmp, ztgsm_SER_INT_MASK, 0x0);
+	ztgsm_outdw_io(gsmtmp, ztgsm_PCM_FC_TOG_BIT, 0x0);
+	ztgsm_outdw_io(gsmtmp, ztgsm_PCM_SAP_EN, 0x0);
+
+	ztgsm_outdw_io(gsmtmp, ztgsm_LED_DUAL, 0xFF00);
+
+	ioport = gsmtmp->ioport;
+	pci_io = gsmtmp->pci_io;
+	pci_io_phys = gsmtmp->pci_io_phys;
+        iomem_size = gsmtmp->iomem_size;
+
+	gsmtmp->pci_io = 0;
+	gsmtmp->ioport = 0;
+
+    spin_unlock_irqrestore(&gsmtmp->lock,flags);
+
+
+    for (i=0; i < gsmtmp->gsmspans; i++) {
+	gsmspan = &gsmtmp->gsmspan[i];
+        if(gsmspan->span.flags & ZT_FLAG_RUNNING) {
+	    if (debug)
+	        printk(KERN_INFO "ztgsm: shutdown card %d span %d.\n",gsmtmp->cardno,i);
+	}
+        if(gsmspan->span.flags & ZT_FLAG_REGISTERED) {
+	    zt_unregister(&gsmspan->span);
+	    if (debug)
+	        printk(KERN_INFO "ztgsm: unregistered card %d span %d.\n",gsmtmp->cardno,i);
+	}
+    }
+
+
+    release_region(ioport, 0x100);
+    iounmap((void *) pci_io);
+    release_mem_region(pci_io_phys, iomem_size);
+
+
+    spin_lock_irqsave(&gsmtmp->lock,flags);
+
+	free_irq(gsmtmp->irq,gsmtmp);
+
+	pci_write_config_word(gsmtmp->pcidev, PCI_COMMAND, 0);	
+
+	if (gsmtmp->pcidev != NULL) {
+    	    pci_disable_device(gsmtmp->pcidev);
+	}
+
+    spin_unlock_irqrestore(&gsmtmp->lock,flags);
+}
+
+void ztgsm_register_card(struct ztgsm_card *gsmtmp) {
+    spin_lock(&registerlock);
+    if (gsmtmp != NULL) {
+	gsmtmp->prev = NULL;
+	gsmtmp->next = ztgsm_dev_list;
+	if (ztgsm_dev_list) {
+	    ztgsm_dev_list->prev = gsmtmp;
+	}
+	ztgsm_dev_list = gsmtmp;
+	gsmtmp->cardno = ++ztgsm_dev_count;
+    } else {
+	printk(KERN_INFO "ztgsm: trying to register NULL card.\n");
+    }
+    spin_unlock(&registerlock);
+}
+
+
+void ztgsm_resetCard(struct ztgsm_card *gsmtmp) {
+    unsigned long flags;
+    int i;
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+//    pci_write_config_word(gsmtmp->pcidev, PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+    
+    switch (baudrate) {
+	case 9600:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0xD5);
+	    break;
+	case 19200:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0x6B);
+	    break;
+	case 38400:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0x35);
+	    break;
+	case 57600:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0x24);
+	    break;
+	case 115200:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0x12);
+	    break;
+	default:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_DIV, 0x6B);	/* 19200 */
+    }
+
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_PRE_DIV, 0x06);
+//    ztgsm_outdw_io(gsmtmp, ztgsm_SER_CLK_PRE_DIV, 0x03);
+//    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_CLK_PRE_DIV, 0x06);
+    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_CLK_PRE_DIV, 0x0C);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_INT_MASK, 0x0);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_IDLE_VAL, 0x01);
+
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_TX_EN, 0x0);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_RX_EN, 0x0);
+
+
+    gsmtmp->ticks = 0;
+    gsmtmp->clicks = 0;
+    
+    for (i=0; i<4; i++)
+	gsmtmp->ton_off_toggle[i] = -1;
+
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+}
+
+void ztgsm_startCard(struct ztgsm_card *gsmtmp) {
+    unsigned long flags;
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_FC_TOG_BIT, 0x03);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_INT_MASK, 0x1FFFF);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_RX_WATERMARK, 0x0);
+    if (sim) {
+	gsmtmp->sim_sel = sim;
+	ztgsm_outdw_io(gsmtmp, ztgsm_SIM_SEL, gsmtmp->sim_sel);
+    } else {
+	gsmtmp->sim_sel = 0;
+	ztgsm_outdw_io(gsmtmp, ztgsm_SIM_SEL, gsmtmp->sim_sel);
+    }
+    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_SAP_EN, 0x0);
+    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_MASK_LAST, 0x001F0000 | 0x1F); /* PCM32 0x100 frames */
+//    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_MASK_LAST, (0x001FC000 | 0x1F)); /* PCM32 0x40 frames */
+
+    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_SAP_EN, 0x1F);
+    switch (gsmtmp->gsmspans) {
+	case 4:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01010186); /* GSM_A (alaw) -> pci slot 0x01 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01840101); /* pci slot 0x01 -> GSM_A */
+
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x0103018A); /* GSM_B (alaw) -> pci slot 0x03 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01880103); /* pci slot 0x03 -> GSM_B */
+
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x0105018E); /* GSM_C (alaw) -> pci slot 0x05 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x018C0105); /* pci slot 0x05 -> GSM_C */
+
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01070192); /* GSM_D (alaw) -> pci slot 0x07 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01900107); /* pci slot 0x07 -> GSM_D */
+	    break;
+	case 2:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01010186); /* GSM_A (alaw) -> pci slot 0x01 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01840101); /* pci slot 0x01 -> GSM_A */
+
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x0103018A); /* GSM_B (alaw) -> pci slot 0x03 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01880103); /* pci slot 0x03 -> GSM_B */
+	    break;
+	case 1:
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01010186); /* GSM_A (alaw) -> pci slot 0x01 */
+	    ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG, 0x01840101); /* pci slot 0x01 -> GSM_A */
+	    break;
+    }
+
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_RX_EN, 0x0F);
+    ztgsm_outdw_io(gsmtmp, ztgsm_SER_TX_EN, 0x0F);
+    if (debug)
+	printk(KERN_INFO "ztgsm: SER_TX_EN %d SER_RX_EN %d \n", ztgsm_indw_io(gsmtmp, ztgsm_SER_TX_EN), ztgsm_indw_io(gsmtmp, ztgsm_SER_RX_EN));
+    gsmtmp->jitter_offset = 0;
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+}
+
+static void ztgsm_xbar(struct ztgsm_card *gsmtmp, int dst, int src, int slin) {
+    unsigned long flags;
+    int format = 0;
+    
+    if (!gsmtmp) return;
+
+    if (slin) format = 0x2000;
+    spin_lock_irqsave(&(gsmtmp->lock), flags);
+	if (debug > 1)
+	    printk(KERN_INFO "ztgsm: ztgsm_PCM_VECTOR_CFG %4x \n", (dst << 16) | src | format);
+	ztgsm_outdw_io(gsmtmp, ztgsm_PCM_VECTOR_CFG,  (dst << 16) | src | format);
+    spin_unlock_irqrestore(&(gsmtmp->lock), flags);
+}
+
+static int ztgsm_dacs(struct zt_chan *dst, struct zt_chan *src) {
+    struct ztgsm_span *src_span;
+    struct ztgsm_span *dst_span;
+    
+    dst_span = dst->pvt;
+    if (dst->chanpos == 2) return -1;
+
+    if (src) {
+	if (src->chanpos == 2) return -1;
+	src_span = src->pvt;
+	if (debug > 1)
+	    printk(KERN_INFO "linking channel %d span %d to channel %d span %d\n", src->chanpos, src_span->span.offset, dst->chanpos, dst_span->span.offset);
+	/* ALAW */
+	ztgsm_xbar(dst->span->pvt, 0x184 + (4 * dst_span->span.offset), 0x186 + (4 * src_span->span.offset), 0);
+
+	/* SLIN */
+/*	ztgsm_xbar(dst->span->pvt, 0x184 + (4 * dst_span->span.offset), 0x184 + (4 * src_span->span.offset), 1);
+	ztgsm_xbar(dst->span->pvt, 0x185 + (4 * dst_span->span.offset), 0x185 + (4 * src_span->span.offset), 1); */
+
+    } else {
+	if (debug > 1)
+	    printk(KERN_INFO "unlinking channel %d span %d\n", dst->chanpos, dst_span->span.offset);
+	/* reassign pci source */
+	ztgsm_xbar(dst->span->pvt, 0x184 + (4 * dst_span->span.offset), 0x100 | ((dst_span->span.offset * 2)+1), 0);
+	/* reassign pci destination */
+	ztgsm_xbar(dst->span->pvt, 0x100 | ((dst_span->span.offset * 2)+1), 0x186 + (4 * dst_span->span.offset), 0);
+    }
+
+    return 0;
+}
+
+static int ztgsm_ser_rx(struct ztgsm_card *gsmtmp, int span) {
+    unsigned int rxcreg = 0;
+    unsigned int rxdreg = 0;
+    int rx_count = 0;
+    int i = 0;
+    unsigned char data = 0;
+    unsigned int count_reg = 0;
+    int rd_ptr = 0;
+    int wr_ptr = 0;
+    switch (span) {
+	case 0:	rxcreg = ztgsm_SER_RX_COUNT_A;
+		rxdreg = ztgsm_SER_RX_DATA_A;
+		break;
+	case 1:	rxcreg = ztgsm_SER_RX_COUNT_B;
+		rxdreg = ztgsm_SER_RX_DATA_B;
+		break;
+	case 2:	rxcreg = ztgsm_SER_RX_COUNT_C;
+		rxdreg = ztgsm_SER_RX_DATA_C;
+		break;
+	case 3:	rxcreg = ztgsm_SER_RX_COUNT_D;
+		rxdreg = ztgsm_SER_RX_DATA_D;
+		break;
+    }
+    count_reg = ztgsm_indw_io(gsmtmp, rxcreg);
+    rx_count = count_reg & 0x1F;
+    if (rx_count) {
+	rd_ptr = (count_reg & 0x03E0) >> 5;
+	wr_ptr = (count_reg & 0x7C00) >> 10;
+//	if (debug) 
+//	    printk(KERN_CRIT "ztgsm: SER_RX_COUNT_%d [wr_ptr %d rd_ptr %d count %d]\n", span, wr_ptr, rd_ptr, rx_count);
+	if ((gsmtmp->ser_rx_idx[span] + rx_count) < ztgsm_SER_BUF_SIZE) {
+	    if (debug) printk(KERN_INFO "ztgsm: span %d SER_RX [ ", span);
+	    for (i=0;i<rx_count; i++) {
+		data = ztgsm_indw_io(gsmtmp, rxdreg);
+		if (debug) {
+		    if (data == 0xd) {
+			printk("\\r");
+		    } else if (data == 0xa) {
+			printk("\\n");
+		    } else {
+			printk("%c", data);
+		    }
+		}
+		if (gsmtmp->gsmspan[span].span.flags & ZT_FLAG_RUNNING)
+		    gsmtmp->ser_rx_buf[span][gsmtmp->ser_rx_idx[span]++] = data;
+	    }
+    	    if (debug) printk(" ]\n");
+	} else {
+	    printk(KERN_INFO "ztgsm: RX buffer overflow on span %d\n", span);
+	}
+    }
+    return rx_count;
+}
+
+static int ztgsm_zap_rx(struct ztgsm_card *gsmtmp, int span) {
+    int i = 0;
+        
+    if (gsmtmp->ser_rx_idx[span]) {
+	memcpy(gsmtmp->drxbuf[span], &gsmtmp->ser_rx_buf[span], gsmtmp->ser_rx_idx[span]);
+	if (debug > 1) {
+	    printk(KERN_INFO "ztgsm: span %d RX [ ", span);
+	    for (i=0;i<gsmtmp->ser_rx_idx[span]; i++) {
+		if (gsmtmp->ser_rx_buf[span][i] == 0xd) {
+		    printk("\\r");
+		} else if (gsmtmp->ser_rx_buf[span][i] == 0xa) {
+		    printk("\\n");
+		} else {
+		    printk("%c", gsmtmp->ser_rx_buf[span][i]);
+		}
+	    }
+    	    printk(" ]\n");
+	}
+	gsmtmp->gsmspan[span].chans[1].eofrx = 1;
+	gsmtmp->gsmspan[span].chans[1].bytes2receive = gsmtmp->ser_rx_idx[span];
+	gsmtmp->ser_rx_idx[span] = 0;
+    }
+    return 0;
+}
+
+static int ztgsm_ser_tx(struct ztgsm_card *gsmtmp, int span) {
+    unsigned int txcreg = 0;
+    unsigned int txdreg = 0;
+    unsigned int tx_wm_sen = 0;
+    int left = 0;
+    int i = 0;
+    int count = 0;
+    unsigned int count_reg = 0;
+    int rd_ptr = 0;
+    int wr_ptr = 0;
+    struct ztgsm_span *gsmspan = NULL;
+
+    switch (span) {
+	case 0:	txcreg = ztgsm_SER_TX_COUNT_A;
+		txdreg = ztgsm_SER_TX_DATA_A;
+		break;
+	case 1:	txcreg = ztgsm_SER_TX_COUNT_B;
+		txdreg = ztgsm_SER_TX_DATA_B;
+		break;
+	case 2:	txcreg = ztgsm_SER_TX_COUNT_C;
+		txdreg = ztgsm_SER_TX_DATA_C;
+		break;
+	case 3:	txcreg = ztgsm_SER_TX_COUNT_D;
+		txdreg = ztgsm_SER_TX_DATA_D;
+		break;
+    }
+    gsmspan = &gsmtmp->gsmspan[span];
+    if (gsmspan) {
+	count_reg = ztgsm_indw_io(gsmtmp, txcreg);
+	left = ztgsm_FIFO_SIZE - (count_reg & 0x1F);
+	if (left >= 1 ) {
+	    rd_ptr = (count_reg & 0x03E0) >> 5;
+	    wr_ptr = (count_reg & 0x7C00) >> 10;
+	    if (debug) 
+		printk(KERN_CRIT "ztgsm: SER_TX_COUNT_%d [wr_ptr %d rd_ptr %d free %d]\n", span, wr_ptr, rd_ptr, left);
+	    if (gsmtmp->ser_tx_idx[span] < left) {
+		count = gsmtmp->ser_tx_idx[span];
+    	    } else {
+		count = left;
+	    }
+	    if (debug)
+		printk(KERN_INFO "ztgsm: span %d SER_TX [ ", span);
+	    for (i=0;i<count; i++) {
+		if (debug && (gsmtmp->ser_tx_buf[span][i] > 0x10))
+	    	    printk("%c", gsmtmp->ser_tx_buf[span][i]);
+		ztgsm_outdw_io(gsmtmp, txdreg, gsmtmp->ser_tx_buf[span][i]);
+	    }
+	    if (debug)
+	        printk(" ]\n");
+	    gsmtmp->ser_tx_idx[span] -= count;
+	    if (gsmtmp->ser_tx_idx[span] > 0) {
+		memmove(&gsmtmp->ser_tx_buf[span][0], &gsmtmp->ser_tx_buf[span][i], gsmtmp->ser_tx_idx[span]);
+	    }
+	    tx_wm_sen = (ztgsm_indw_io(gsmtmp, ztgsm_SER_TX_WM_SEN) & 0xF) | (1 << span);
+	    ztgsm_outdw_io(gsmtmp, ztgsm_SER_TX_WM_SEN, tx_wm_sen);
+//	    printk(KERN_INFO "ztgsm: span %d TX_IDX %d count %d tx_wm_send %d\n", span, gsmtmp->ser_tx_idx[span], count, tx_wm_sen);
+	} else {
+	    if (debug) {
+		printk(KERN_INFO "ztgsm: span %d wanted to TX %d bytes but only %d bytes free fifo space\n", span, gsmtmp->ser_tx_idx[span], left);
+	    }
+	}
+    }
+    return i;
+}
+
+static int ztgsm_zap_tx(struct ztgsm_card *gsmtmp, int span) {
+    struct ztgsm_span *gsmspan = NULL;
+    int i = 0;
+    int poweroff_cmd = 0;
+    int poweron_cmd = 0;
+    gsmspan = &gsmtmp->gsmspan[span];
+    if (!gsmspan)
+	 return -1;
+	if (gsmspan->chans[1].bytes2transmit) {
+	    if (debug > 1) {
+		printk(KERN_INFO "ztgsm: span %d TX [ ", span);
+		for (i=0;i<gsmspan->chans[1].bytes2transmit; i++) {
+		    if (gsmtmp->dtxbuf[span][i] > 0x10)
+			printk("%c", gsmtmp->dtxbuf[span][i]);
+		}
+	        printk(" ]\n");
+	    }
+	    if ((gsmtmp->dtxbuf[span][0] == 'A') && (gsmtmp->dtxbuf[span][1] == 'T') && (gsmtmp->dtxbuf[span][2] == '+') && (gsmtmp->dtxbuf[span][3] == 'P') && (gsmtmp->dtxbuf[span][4] == 'O') && (gsmtmp->dtxbuf[span][5] == 'W') && (gsmtmp->dtxbuf[span][6] == 'E') && (gsmtmp->dtxbuf[span][7] == 'R') && (gsmtmp->dtxbuf[span][8] == '=') && (gsmtmp->dtxbuf[span][9] == '1') && (gsmtmp->dtxbuf[span][10] == '\r')) {
+		if (debug) printk(KERN_INFO "ztgsm: span %d received power on AT command\n", span);
+		gsmtmp->dtr_on_off &= ~(1 << span); 	/* on_off_n low */
+		ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+		gsmtmp->ton_off_toggle[span] = 700;
+		gsmtmp->gsmspan[span].led = 0xC1;
+		gsmtmp->power[span] = 1;
+		poweron_cmd = 1;
+	    } else if ((gsmtmp->dtxbuf[span][0] == 'A') && (gsmtmp->dtxbuf[span][1] == 'T') && (gsmtmp->dtxbuf[span][2] == '+') && (gsmtmp->dtxbuf[span][3] == 'M') && (gsmtmp->dtxbuf[span][4] == 'R') && (gsmtmp->dtxbuf[span][5] == 'S') && (gsmtmp->dtxbuf[span][6] == 'T') && (gsmtmp->dtxbuf[span][7] == '\r')) {
+		if (debug) printk(KERN_INFO "ztgsm: span %d received power off AT command\n", span);
+		gsmtmp->gsmspan[span].led = 0x80;
+		gsmtmp->power[span] = 0;
+		poweroff_cmd = 1;
+	    } else if ((gsmtmp->dtxbuf[span][0] == 'a') && (gsmtmp->dtxbuf[span][1] == 't') && (gsmtmp->dtxbuf[span][2] == '+') && (gsmtmp->dtxbuf[span][3] == 'm') && (gsmtmp->dtxbuf[span][4] == 'r') && (gsmtmp->dtxbuf[span][5] == 's') && (gsmtmp->dtxbuf[span][6] == 't') && (gsmtmp->dtxbuf[span][7] == '\r')) {
+		if (debug) printk(KERN_INFO "ztgsm: span %d received power off AT command\n", span);
+		gsmtmp->gsmspan[span].led = 0x80;
+		gsmtmp->power[span] = 0;
+		poweroff_cmd = 1;
+	    } else if ((gsmtmp->dtxbuf[span][0] == 'A') && (gsmtmp->dtxbuf[span][1] == 'T') && (gsmtmp->dtxbuf[span][2] == '+') && (gsmtmp->dtxbuf[span][3] == 'P') && (gsmtmp->dtxbuf[span][4] == 'O') && (gsmtmp->dtxbuf[span][5] == 'W') && (gsmtmp->dtxbuf[span][6] == 'E') && (gsmtmp->dtxbuf[span][7] == 'R') && (gsmtmp->dtxbuf[span][8] == '=') && (gsmtmp->dtxbuf[span][9] == '0') && (gsmtmp->dtxbuf[span][10] == '\r')) {
+		if (debug) printk(KERN_INFO "ztgsm: span %d received power off AT command\n", span);
+		gsmtmp->dtr_on_off &= ~(1 << span); 	/* on_off_n low */
+		ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+		gsmtmp->gsmspan[span].led = 0xC0;
+		gsmtmp->ton_off_toggle[span] = 2200;
+		gsmtmp->power[span] = 0;
+	    } else if ((gsmtmp->dtxbuf[span][0] == 'A') && (gsmtmp->dtxbuf[span][1] == 'T') && (gsmtmp->dtxbuf[span][2] == '+') && (gsmtmp->dtxbuf[span][3] == 'S') && (gsmtmp->dtxbuf[span][4] == 'I') && (gsmtmp->dtxbuf[span][5] == 'M') && (gsmtmp->dtxbuf[span][6] == '=') && (gsmtmp->dtxbuf[span][8] == '\r')) {
+		if (debug) printk(KERN_INFO "ztgsm: span %d received SIM select AT command, sim = %c\n", span, gsmtmp->dtxbuf[span][7]);
+		if (gsmtmp->dtxbuf[span][7] == '0') {
+		    gsmtmp->sim_sel &= ~(1 << span);
+		    ztgsm_outdw_io(gsmtmp, ztgsm_SIM_SEL, gsmtmp->sim_sel);
+		    if (debug) printk(KERN_INFO "ztgsm: span %d now using onboard SIM card reader. Setting sim_sel to %d.\n", span, gsmtmp->sim_sel);
+		} else if (gsmtmp->dtxbuf[span][7] == '1') {
+		    gsmtmp->sim_sel |= (1 << span);
+		    ztgsm_outdw_io(gsmtmp, ztgsm_SIM_SEL, gsmtmp->sim_sel);
+		    if (debug) printk(KERN_INFO "ztgsm: span %d now using external SIM card reader. Setting sim_sel to %d.\n", span, gsmtmp->sim_sel);
+		} else {
+		    printk(KERN_INFO "ztgsm: span %d received invalied SIM select AT command, sim = %c\n", span,  gsmtmp->dtxbuf[span][7]);
+		}
+		poweron_cmd = 1;
+	    }
+	    if ((gsmtmp->power[span] || poweroff_cmd) && (!poweron_cmd)) {
+		if (gsmtmp->ser_tx_idx[span] + gsmspan->chans[1].bytes2transmit < ztgsm_SER_BUF_SIZE) {
+		    memcpy(&gsmtmp->ser_tx_buf[span][gsmtmp->ser_tx_idx[span]], gsmtmp->dtxbuf[span], gsmspan->chans[1].bytes2transmit);
+		    gsmtmp->ser_tx_idx[span] += gsmspan->chans[1].bytes2transmit;
+		    ztgsm_ser_tx(gsmtmp, span);
+		} else {
+		    printk(KERN_INFO "ztgsm: TX buffer overflow on span %d (TX_IDX %d BTT %d)\n", span, gsmtmp->ser_tx_idx[span] , gsmspan->chans[1].bytes2transmit);
+		}
+	    }
+	}
+		
+	gsmspan->chans[1].bytes2receive = 0;
+	gsmspan->chans[1].bytes2transmit = 0;
+	gsmspan->chans[1].eofrx = 0;
+	gsmspan->chans[1].eoftx = 0;
+    return 0;
+}
+
+
+static int ztgsm_span_rx(struct ztgsm_card *gsmtmp, int span) {
+    struct ztgsm_span *gsmspan = NULL;
+    unsigned int addr = 0;
+    unsigned int framecnt = 0;
+    unsigned int pcmframecnt = 0;
+    unsigned int fraddr = 0;
+    unsigned int data = 0;
+    int start = 0;
+    int len = 0;
+    int i = 0;
+    unsigned int slot = 0;
+    
+    switch(span) {
+	case 0: 
+	    slot = 1;
+	    break;
+	case 1: 
+	    slot = 3;
+	    break;
+	case 2: 
+	    slot = 5;
+	    break;
+	case 3: 
+	    slot = 7;
+	    break;
+    }
+//    slot = span;
+    gsmspan = &gsmtmp->gsmspan[span];
+    if (gsmspan) {
+	framecnt = gsmtmp->framecnt - gsmtmp->jitter_offset;
+	pcmframecnt = framecnt;
+    	framecnt &= ztgsm_FRAMES - 1;
+	start = framecnt - 16;
+	if (start < 0) {
+	    len = -start;
+	    if (len > ZT_CHUNKSIZE) len = ZT_CHUNKSIZE;
+	    fraddr = ztgsm_FRAMES + start;
+	} else {
+	    len = ZT_CHUNKSIZE;
+	    fraddr = start;
+	}
+
+	if (fraddr & 3) {
+	    if (debug > 1)
+	        printk(KERN_INFO "ztgsm: RX span %d unaligned word address %#x (fraddr & 3 = %d)\n", span, fraddr, (fraddr & 3));
+	    fraddr -= fraddr & 3; /* align */
+	} 
+	if (len == ZT_CHUNKSIZE) {
+    	    addr = (slot << 8) | fraddr;
+//    	    addr = ((span+1) << 8) | fraddr;
+//    ztgsm_outdw_io(gsmtmp, ztgsm_LED_DUAL, addr & 0x4);
+	    data = ztgsm_indw(gsmtmp, addr);
+	    *((unsigned int *)&gsmtmp->rxbuf[span][0]) = data;
+
+
+//    ztgsm_outdw_io(gsmtmp, ztgsm_LED_DUAL, addr & 0x4);
+    	    addr = (slot << 8) | (fraddr + 4);
+//    	    addr = ((span+1) << 8) | (fraddr + 4);
+	    data = ztgsm_indw(gsmtmp, addr);
+	    *((unsigned int *)&gsmtmp->rxbuf[span][4]) = data;
+//    ztgsm_outdw_io(gsmtmp, ztgsm_LED_DUAL, 0xf);
+	} else {
+	    if (debug > 2)
+		printk(KERN_INFO "ztgsm: dropped audio span %d fraddr %d addr %d\n", span, fraddr, addr);
+	}
+if (!(gsmtmp->ticks % 1000) && (debug > 4)) {
+	printk(KERN_INFO "ztgsm: RX DATA:");
+	for (i=0; i < ZT_CHUNKSIZE; i++) {
+	    printk("%x", gsmtmp->rxbuf[span][i]);
+	}
+	printk("\n");
+}
+
+    }
+    return 0;
+}
+
+static int ztgsm_span_tx(struct ztgsm_card *gsmtmp, int span) {
+    struct ztgsm_span *gsmspan = NULL;
+    unsigned int addr = 0;
+    unsigned int framecnt = 0;
+    unsigned int fraddr = 0;
+    int start = 0;
+    int len = 0;
+    unsigned int slot = 0;
+    
+    switch(span) {
+	case 0: 
+	    slot = 1;
+	    break;
+	case 1: 
+	    slot = 3;
+	    break;
+	case 2: 
+	    slot = 5;
+	    break;
+	case 3: 
+	    slot = 7;
+	    break; 
+    }
+//    slot = span;
+
+    gsmspan = &gsmtmp->gsmspan[span];
+    if (gsmspan) {
+	framecnt = gsmtmp->framecnt - gsmtmp->jitter_offset;
+    	framecnt &= ztgsm_FRAMES - 1;
+	start = framecnt + ztgsm_MAX_FC_DIFF + ztgsm_FRAME_SIZE;
+
+	if (start < 0x0) {
+	    len = -start;
+	    if (len > ZT_CHUNKSIZE) len = ZT_CHUNKSIZE;
+	    fraddr = ztgsm_FRAMES + start;
+	} else {
+	    len = ZT_CHUNKSIZE;
+	    fraddr = start;
+	}
+
+	if (fraddr & 3) {
+	    if (debug > 2)
+		printk(KERN_INFO "ztgsm: span_tx unaligned word address %#x\n", fraddr);
+	    fraddr -= fraddr & 3; /* align */
+	}
+	if (len == ZT_CHUNKSIZE) {
+	    addr =(slot << 8 ) | fraddr;
+//	    addr =( (span+1) << 8 ) | fraddr;
+	    ztgsm_outdw(gsmtmp, addr, *((unsigned int*)&(gsmtmp->txbuf[span][0])));
+//    	    addr =( (span+1) << 8 ) | (fraddr + 4);
+    	    addr =(slot << 8 ) | (fraddr + 4);
+	    ztgsm_outdw(gsmtmp, addr, *((unsigned int*)&(gsmtmp->txbuf[span][4])));
+	}
+
+    }
+    return 0;
+}
+
+static void ztgsm_leds(struct ztgsm_card *gsmtmp, int tick) {
+    int i = 0;
+    unsigned int leds = 0;
+    unsigned int color = 0;
+    for (i=0; i<gsmtmp->gsmspans; i++) {
+//	printk(KERN_INFO "ztgsm: led = %x\n",gsmtmp->gsmspan[i].led);
+	color = gsmtmp->gsmspan[i].led & 0x1;
+	leds |= (color << i);
+	if (!(gsmtmp->gsmspan[i].led & 0x80)) {
+	    leds |= (1 << (i+8));
+	}
+	if ((gsmtmp->gsmspan[i].led & 0x40)) {
+	    if (tick == 300)
+		leds |= (1 << (i+8));
+	}
+
+    }
+//    printk(KERN_INFO "ztgsm: leds = %d\n",leds);
+    ztgsm_outdw_io(gsmtmp, ztgsm_LED_DUAL, leds);
+}
+
+static inline void ztgsm_run(struct ztgsm_card *gsmtmp) {
+    int s=0;
+    struct ztgsm_span *gsmspan = NULL;
+
+
+    for (s=0;s<gsmtmp->gsmspans;s++) {
+        gsmspan = &gsmtmp->gsmspan[s];
+        if (gsmspan) {
+	    if (gsmspan->span.flags & ZT_FLAG_RUNNING) {
+		/* oh zaptel! tell us what to transmit... */
+    		zt_transmit(&gsmspan->span);
+		if ((debug > 1) && (gsmspan->chans[1].bytes2transmit > 0))
+		    printk(KERN_CRIT "ztgsm: span %d bytes2transmit = %d\n", s, gsmspan->chans[1].bytes2transmit);
+		ztgsm_span_tx(gsmtmp, s);
+		ztgsm_zap_tx(gsmtmp, s);
+	    }
+
+	    if (gsmspan->span.flags & ZT_FLAG_RUNNING) {
+	        ztgsm_zap_rx(gsmtmp, s);
+	    	ztgsm_span_rx(gsmtmp, s);
+		/* oh zaptel! thou shall receive! */
+		zt_receive(&gsmspan->span);
+	    }
+	} 
+    }
+}
+
+
+
+ZAP_IRQ_HANDLER(ztgsm_interrupt) {
+    struct ztgsm_card *gsmtmp = dev_id;
+    unsigned int ser_status = 0;
+    unsigned char mods = 0;
+    int s = 0;
+    int rx_count = 0;
+    int dtr_on_off = 0;
+    unsigned long flags;
+    signed int jitter = 0;
+    
+    if (!gsmtmp || gsmtmp->dead) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    if ((!gsmtmp->pci_io) || (!gsmtmp->ioport)) {
+	    printk(KERN_CRIT "ztgsm: no pci mem/io\n");
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    
+    spin_lock_irqsave(&(gsmtmp->lock),flags);
+//	    printk(KERN_INFO "gsm: irq\n");
+    gsmtmp->last_framecnt = gsmtmp->framecnt;
+    gsmtmp->framecnt = ztgsm_indw_io(gsmtmp, ztgsm_PCM_FRAME_CNT);
+    ser_status = ztgsm_indw_io(gsmtmp, ztgsm_SER_STATUS);
+    if (ser_status) {
+	if (ser_status & 0x10000) {
+	    gsmtmp->ticks++;
+	    jitter = gsmtmp->framecnt - gsmtmp->last_framecnt - ztgsm_FRAME_SIZE;
+	    if (abs(gsmtmp->jitter_offset + jitter) > ztgsm_MAX_FC_DIFF) {
+		if (debug > 1)
+		    printk(KERN_INFO "ztgsm: missed IRQ, framecnt %d last_framecnt %d (diff %d)\n", gsmtmp->framecnt, gsmtmp->last_framecnt, (gsmtmp->framecnt - gsmtmp->last_framecnt));
+		gsmtmp->jitter_offset = 0;
+	    } else {
+		if (gsmtmp->jitter_offset > 0) {
+		    gsmtmp->jitter_offset += jitter;
+		}
+		if ((debug > 1) && gsmtmp->jitter_offset)
+		    printk(KERN_INFO "ztgsm: lagged IRQ, framecnt %d last_framecnt %d (offset %d)\n", gsmtmp->framecnt, gsmtmp->last_framecnt, gsmtmp->jitter_offset);
+	    }
+
+	    if (gsmtmp->jitter_offset >= 0) {
+		ztgsm_run(gsmtmp);
+	    }
+	    if (!(gsmtmp->ticks % 100)) {
+		for (s=0; s < gsmtmp->gsmspans; s++) {
+		    if (gsmtmp->ton_off_toggle[s] >= 0) {
+			gsmtmp->ton_off_toggle[s] -= 100;
+			if (gsmtmp->ton_off_toggle[s] <= 0) {
+			    /* timer expired */ 
+			    gsmtmp->ton_off_toggle[s] = -1;
+			    dtr_on_off = gsmtmp->dtr_on_off & (1 << s);
+			    if (dtr_on_off) {
+				if (debug)
+				    printk(KERN_INFO "ztgsm: setting on_off to low for span %d\n",s);
+				gsmtmp->dtr_on_off &= ~(1 << s); 	/* on_off_n low */
+				ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+			    } else {
+				if (debug)
+				    printk(KERN_INFO "ztgsm: setting on_off to high for span %d\n",s);
+    				gsmtmp->dtr_on_off |= 1 << s;		/* on_off_n high */
+				ztgsm_outdw_io(gsmtmp, ztgsm_SER_DTR_ON_OFF, gsmtmp->dtr_on_off);
+			    }
+			    if (gsmtmp->power[s]) {
+				gsmtmp->gsmspan[s].led = 0x81;
+			    } else {
+				gsmtmp->gsmspan[s].led = 0x80;
+			    }
+			}
+		    }
+		}
+	    }
+
+	    if (!(gsmtmp->ticks % 300))
+	        ztgsm_leds(gsmtmp, gsmtmp->ticks);
+
+	    if (!(gsmtmp->ticks % 1000)) {
+		if (debug > 2)
+		    printk(KERN_INFO "ztgsm: TICK\n");
+	        gsmtmp->ticks = 0;
+    	    }
+	}
+	if (ser_status & 0x0F) {
+	    mods = (ser_status & 0x0F);
+	    for (s=0; s<gsmtmp->gsmspans; s++) {
+		if (mods & (1 << s)) {
+		    rx_count = ztgsm_ser_rx(gsmtmp, s);
+//		    if (debug) 
+			printk(KERN_INFO "ztgsm: TX fifo overrun on span %d\n", s);
+		}
+	    }
+	}
+	if (ser_status & 0xF0) {
+	    mods = (ser_status & 0xF0) >> 4;
+	    for (s=0; s<gsmtmp->gsmspans; s++) {
+		if (mods & (1 << s)) {
+		    rx_count = ztgsm_ser_rx(gsmtmp, s);
+		    if (debug > 1) 
+			printk(KERN_INFO "ztgsm: HWIRQ RX %d bytes on span %d.\n", rx_count, s);
+		}
+	    }
+	}
+	if (ser_status & 0xF00) {
+	    mods = (ser_status & 0xF00) >> 8;
+	    for (s=0; s<gsmtmp->gsmspans; s++) {
+		if (mods & (1 << s)) {
+		    rx_count = ztgsm_ser_rx(gsmtmp, s);
+//		    if (debug) 
+			printk(KERN_INFO "ztgsm: RX fifo overrun on span %d\n", s);
+		}
+	    }
+	}
+	if (ser_status & 0xF000) {
+	    mods = (ser_status & 0xF000) >> 12;
+	    for (s=0; s<gsmtmp->gsmspans; s++) {
+		if (mods & (1 << s)) {
+		    if (gsmtmp->ser_tx_idx[s]) {
+			/* sumfin left to transmit */
+			ztgsm_ser_tx(gsmtmp, s);
+		    }
+		    if (debug) 
+			printk(KERN_INFO "ztgsm: TX low water status %#x\n", ser_status);
+		}
+	    }
+	}
+    }
+    spin_unlock_irqrestore(&(gsmtmp->lock),flags);
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+
+static int ztgsm_open(struct zt_chan *chan) {
+//    printk(KERN_INFO "ztgsm: channel %d opened.\n",chan->channo);
+#ifndef LINUX26
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztgsm_close(struct zt_chan *chan) {
+//    printk(KERN_INFO "ztgsm: channel %d closed.\n",chan->channo);
+#ifndef LINUX26
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztgsm_chanconfig(struct zt_chan *chan,int sigtype) {
+//    printk(KERN_INFO "chan_config sigtype=%d\n",sigtype);
+    return 0;
+}
+
+static int ztgsm_spanconfig(struct zt_span *span,struct zt_lineconfig *lc) {
+//    span->lineconfig = lc->lineconfig;
+    return 0;
+}
+
+
+static int ztgsm_startup(struct zt_span *span) {
+    struct ztgsm_card *gsmtmp = span->pvt;
+    int running;
+    
+    if (gsmtmp == NULL) {
+	printk(KERN_INFO "ztgsm: no card for span at startup!\n");
+    }
+    
+    running = span->flags & ZT_FLAG_RUNNING;
+
+    if (!running) {
+	span->chans[1].flags &= ~ZT_FLAG_HDLC;
+	span->chans[1].flags |= ZT_FLAG_BRIDCHAN;
+	if (!gsmtmp->power[span->offset]) 
+	    ztgsm_switch_on(gsmtmp, span->offset);
+	span->flags |= ZT_FLAG_RUNNING;
+    } else {
+	printk(KERN_INFO "ztgsm: already running\n");
+	return 0;
+    }
+    return 0;
+}
+
+static int ztgsm_shutdown(struct zt_span *span) {
+    int running;
+    struct ztgsm_card *gsmtmp = span->pvt;
+
+    if (gsmtmp == NULL) {
+	printk(KERN_INFO "ztgsm: no card for span at shutdown!\n");
+    }
+
+    running = span->flags & ZT_FLAG_RUNNING;
+
+    if (running) {
+	span->flags &= ~ZT_FLAG_RUNNING;
+	if (gsmtmp->power[span->offset]) {
+	    ztgsm_switch_off(gsmtmp, span->offset);
+	}
+    }
+    return 0;
+}
+
+static int ztgsm_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+
+static int ztgsm_init(struct ztgsm_span *gsmspan, struct ztgsm_card *gsmtmp, int offset) {
+    memset(&gsmspan->span,0,sizeof(struct zt_span)); // you never can tell...
+    sprintf(gsmspan->span.name,"ztgsm/%d",gsmtmp->cardno);
+    switch (gsmtmp->type) {
+        case 0xb55d:
+		sprintf(gsmspan->span.desc,"Junghanns.NET unoGSM PCI Card %d",gsmtmp->cardno);
+	    break;
+	case 0xb55e:
+		sprintf(gsmspan->span.desc,"Junghanns.NET duoGSM PCI Card %d",gsmtmp->cardno);
+	    break;
+	case 0xb55f:
+		sprintf(gsmspan->span.desc,"Junghanns.NET quadGSM PCI Card %d",gsmtmp->cardno);
+	    break;
+    }
+    
+    gsmspan->span.spanconfig = ztgsm_spanconfig;
+    gsmspan->span.chanconfig = ztgsm_chanconfig;
+    gsmspan->span.startup = ztgsm_startup;
+    gsmspan->span.shutdown = ztgsm_shutdown;
+    gsmspan->span.maint = NULL;
+    gsmspan->span.rbsbits = NULL;
+    gsmspan->span.open = ztgsm_open;
+    gsmspan->span.close = ztgsm_close;
+    gsmspan->span.ioctl = ztgsm_ioctl;
+
+    if (pcm_xbar == 1) 
+	gsmspan->span.dacs = ztgsm_dacs;
+
+    gsmspan->span.chans = gsmspan->chans;
+    gsmspan->span.channels = 2;
+    gsmspan->span.deflaw = ZT_LAW_ALAW;
+    gsmspan->span.linecompat = ZT_CONFIG_CCS | ZT_CONFIG_AMI; 
+    init_waitqueue_head(&gsmspan->span.maintq);
+    gsmspan->span.pvt = gsmtmp;
+    gsmspan->span.offset = offset;
+
+    memset(&(gsmspan->chans[0]),0x0,sizeof(struct zt_chan));
+    sprintf(gsmspan->chans[0].name,"ztgsm/%d", 0);
+    gsmspan->chans[0].pvt = gsmspan;
+    gsmspan->chans[0].sigcap =  ZT_SIG_CLEAR;
+    gsmspan->chans[0].chanpos = 1; 
+
+    memset(&(gsmspan->chans[1]),0x0,sizeof(struct zt_chan));
+    sprintf(gsmspan->chans[1].name,"ztgsm/%d", 1);
+    gsmspan->chans[1].pvt = gsmspan;
+    gsmspan->chans[1].sigcap =  ZT_SIG_CLEAR;
+    gsmspan->chans[1].chanpos = 2; 
+
+	
+    if (zt_register(&gsmspan->span,0)) {
+        printk(KERN_INFO "ztgm: unable to register zaptel span!\n");
+        return -1;
+    }
+
+    /* setup B channel buffers (8 bytes each) */
+    memset(gsmtmp->rxbuf[offset],0x0,sizeof(gsmtmp->rxbuf[offset]));
+    gsmspan->span.chans[0].readchunk = gsmtmp->rxbuf[offset];
+    memset(gsmtmp->txbuf[offset],0x0,sizeof(gsmtmp->txbuf[offset]));
+    gsmspan->span.chans[0].writechunk = gsmtmp->txbuf[offset];
+
+    /* setup D channel buffer */
+    memset(gsmtmp->dtxbuf[offset],0x0,sizeof(gsmtmp->dtxbuf[offset]));
+    gsmspan->span.chans[1].writechunk = gsmtmp->dtxbuf[offset];
+    gsmspan->span.chans[1].maxbytes2transmit = sizeof(gsmtmp->dtxbuf[offset]);
+
+    memset(gsmtmp->drxbuf[offset],0x0,sizeof(gsmtmp->drxbuf[offset]));
+    gsmspan->span.chans[1].readchunk = gsmtmp->drxbuf[offset];
+
+    return 0;
+}
+
+
+int ztgsm_findCards(unsigned int pcidid) {
+    struct pci_dev *tmp;
+    struct ztgsm_card *gsmtmp = NULL;
+    struct ztgsm_span *gsmspan = NULL;
+    unsigned int ioport_size = 0;
+    int i=0;
+    int cid=0;
+    tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,NULL);
+    while (tmp != NULL) {
+	multi_gsm = tmp;
+
+	if (pci_enable_device(tmp)) {
+	    return -1;
+	}
+
+	gsmtmp = kmalloc(sizeof(struct ztgsm_card),GFP_KERNEL);
+	if (!gsmtmp) {
+	    printk(KERN_WARNING "ztgsm: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    return -ENOMEM;
+	}
+	memset(gsmtmp, 0x0, sizeof(struct ztgsm_card));
+	
+	spin_lock_init(&gsmtmp->lock);
+	gsmtmp->pcidev = tmp;
+	gsmtmp->pcibus = tmp->bus->number;
+	gsmtmp->pcidevfn = tmp->devfn; 
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "ztgsm: no irq!\n");
+	} else {
+	    gsmtmp->irq = tmp->irq;
+	}
+
+	gsmtmp->pci_io_phys = tmp->resource[1].start;
+	if (!gsmtmp->pci_io_phys) {
+	    printk(KERN_WARNING "ztgsm: no iomem!\n");
+	    pci_disable_device(tmp);
+	    return -EIO;
+	}
+	gsmtmp->iomem_size = (tmp->resource[1].end - tmp->resource[1].start + 1);
+	printk(KERN_INFO "ztgsm: iomem at %lx size %ld\n", gsmtmp->pci_io_phys, gsmtmp->iomem_size);
+
+	if (check_mem_region(gsmtmp->pci_io_phys, gsmtmp->iomem_size)) {
+	    printk(KERN_INFO "ztgsm: iomem already in use!\n");;
+	    pci_disable_device(tmp);
+	    return -EBUSY;
+	}
+	
+	request_mem_region(gsmtmp->pci_io_phys, gsmtmp->iomem_size, "ztgsm");
+
+	gsmtmp->pci_io = ioremap(gsmtmp->pci_io_phys, gsmtmp->iomem_size); /* 8kb */
+
+	gsmtmp->ioport = tmp->resource[0].start;
+	if (!gsmtmp->ioport) {
+	    printk(KERN_WARNING "ztgsm: no ioport!\n");
+	    pci_disable_device(tmp);
+	    return -EIO;
+	}
+	ioport_size = (tmp->resource[0].end - tmp->resource[0].start + 1);
+	printk(KERN_INFO "ztgsm: ioport size %d\n", ioport_size);
+
+	if (!request_region(gsmtmp->ioport, 0x100, "ztgsm")) {
+	    printk(KERN_WARNING "ztgsm: couldnt request io range!\n");
+	    release_mem_region(gsmtmp->pci_io_phys, gsmtmp->iomem_size);
+	    pci_disable_device(tmp);
+	    return -EIO;
+	}
+	
+	if (request_irq(gsmtmp->irq, ztgsm_interrupt, ZAP_IRQ_SHARED, "ztgsm", gsmtmp)) {
+	    printk(KERN_WARNING "ztgsm: unable to register irq\n");
+	    release_region(gsmtmp->ioport, 0x100);
+	    release_mem_region(gsmtmp->pci_io_phys, gsmtmp->iomem_size);
+	    kfree(gsmtmp);
+	    pci_disable_device(tmp);
+	    return -EIO;
+	}
+	
+	pci_write_config_word(gsmtmp->pcidev, PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+
+	// disable ints
+
+	gsmtmp->type = tmp->subsystem_device;
+
+	switch (gsmtmp->type) {
+	    case 0xb55d:
+		    printk(KERN_INFO
+    			"ztgsm: Junghanns.NET unoGSM card configured at io port %x IRQ %d io mem %lx HZ %d CardID %d\n",
+        		 (u_int) gsmtmp->ioport, gsmtmp->irq, (u_long) gsmtmp->pci_io, HZ, cid);
+		break;
+	    case 0xb55e:
+		    printk(KERN_INFO
+    			"ztgsm: Junghanns.NET duoGSM card configured at io port %x IRQ %d io mem %lx HZ %d CardID %d\n",
+        		 (u_int) gsmtmp->ioport, gsmtmp->irq, (u_long) gsmtmp->pci_io, HZ, cid);
+		break;
+	    case 0xb55f:
+		    printk(KERN_INFO
+    			"ztgsm: Junghanns.NET quadGSM card configured at io port %x IRQ %d io mem %lx HZ %d CardID %d\n",
+        		 (u_int) gsmtmp->ioport, gsmtmp->irq, (u_long) gsmtmp->pci_io, HZ, cid);
+		break;
+	}
+
+	ztgsm_resetCard(gsmtmp);
+	ztgsm_init_xbar(gsmtmp);
+
+	switch (ztgsm_indw_io(gsmtmp, ztgsm_SER_G20_ACTIVATED)) {
+	    case 0xf:
+		gsmtmp->gsmspans = 4;
+		break;
+	    case 0x3:
+		gsmtmp->gsmspans = 2;
+		break;
+	    case 0x1:
+		gsmtmp->gsmspans = 1;
+		break;
+	}
+	ztgsm_spans += gsmtmp->gsmspans;
+
+	for (i=0; i < gsmtmp->gsmspans; i++) {
+	    gsmspan = &gsmtmp->gsmspan[i];
+	    ztgsm_init(gsmspan, gsmtmp, i);
+	    gsmspan->led = 0x80;
+	}
+        ztgsm_leds(gsmtmp, 0);
+
+	gsmtmp->dtr_on_off = 0x0f;
+
+	gsmtmp->version = ztgsm_indw_io(gsmtmp, ztgsm_VERS_A);
+	printk(KERN_INFO "ztgsm: VERSION %x\n", gsmtmp->version);
+	if (debug) {
+	    printk(KERN_INFO "ztgsm: G20_ACTIVATED %d\n", ztgsm_indw_io(gsmtmp, ztgsm_SER_G20_ACTIVATED));
+	    printk(KERN_INFO "ztgsm: DIPS %#x\n", ztgsm_indw_io(gsmtmp, ztgsm_DIP_SWITCH));
+	    printk(KERN_INFO "ztgsm: tx_wm_sen %d\n", ztgsm_indw_io(gsmtmp, ztgsm_SER_TX_WM_SEN));
+	}
+	
+	ztgsm_register_card(gsmtmp);
+
+	ztgsm_startCard(gsmtmp);
+
+	if (sim >= 0x10) {
+	    printk(KERN_INFO "ztgsm: Invalid value for parameter sim.\n");
+	    sim = 0;
+	}
+
+	if (sim) {
+	    ztgsm_switch_off_all(gsmtmp, 0);
+	    printk(KERN_INFO "ztgsm: Initializing SIM extensions...");
+	    set_current_state(TASK_UNINTERRUPTIBLE);
+	    schedule_timeout((2000 * HZ) / 1000);
+	    ztgsm_switch_on_all(gsmtmp, 0);
+	    printk("done\n");
+	} else {
+	    ztgsm_switch_on_all(gsmtmp, 1);
+	}
+	tmp = pci_get_device(PCI_VENDOR_ID_CCD,pcidid,multi_gsm);
+    }
+    return 0;
+}
+
+
+int init_module(void) {
+    ztgsm_findCards(0xf001);
+    if (ztgsm_dev_count == 0) {
+	printk(KERN_INFO "ztgsm: no multiGSM cards found.\n");
+    } else {
+	printk(KERN_INFO "ztgsm: %d multiGSM card(s) in this box, %d GSM spans total.\n",ztgsm_dev_count, ztgsm_spans);
+    }
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct ztgsm_card *tmpcard,*tmplist;
+    int i=0;
+    tmplist = ztgsm_dev_list;
+    while (tmplist != NULL) {
+	ztgsm_shutdownCard(tmplist);
+	tmplist = tmplist->next;
+    }
+    tmplist = ztgsm_dev_list;
+    spin_lock(&registerlock);
+    while (tmplist != NULL) {
+	tmpcard = tmplist->next;
+	kfree(tmplist);
+	i++;
+	tmplist = tmpcard;
+    }
+    spin_unlock(&registerlock);
+    printk(KERN_INFO "ztgsm: shutdown %d multiGSM cards.\n", i);
+}
+#endif
+
+#ifdef LINUX26
+module_param(debug, int, 0600);
+module_param(pcm_xbar, int, 0600);
+module_param(sim, int, 0600);
+module_param(baudrate, long, 0600);
+#else
+MODULE_PARM(debug,"i");
+MODULE_PARM(pcm_xbar,"i");
+MODULE_PARM(sim,"i");
+MODULE_PARM(baudrate,"l");
+#endif
+
+MODULE_DESCRIPTION("uno/duao/quad GSM zaptel driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urN zaptel-1.4.11.org/kernel/ztgsm/ztgsm.h zaptel-1.4.11/kernel/ztgsm/ztgsm.h
--- zaptel-1.4.11.org/kernel/ztgsm/ztgsm.h	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/kernel/ztgsm/ztgsm.h	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,139 @@
+#define ztgsm_RX_MAX	1000
+#define ztgsm_FIFO_SIZE	16
+#define ztgsm_SPANS	4
+#define ztgsm_SER_BUF_SIZE	1000
+#define ztgsm_FRAMES	0x100
+#define ztgsm_MAX_FC_DIFF 32
+#define ztgsm_FRAME_SIZE ZT_CHUNKSIZE
+
+typedef struct ztgsm_span {
+    int led;	/* 0 == RED 1 == GREEN  0x80 == on 0x40 == blink */
+    int sim_led;
+    /* zaptel resources */
+    struct zt_span span;
+    struct zt_chan chans[2];
+
+    /* more zaptel stuff */
+    unsigned int usecount;
+    int spantype;
+    int spanflags;
+} ztgsm_span;
+
+typedef struct ztgsm_card {
+    spinlock_t lock;
+    unsigned char power[ztgsm_SPANS];
+    unsigned int dtr_on_off;
+    int cardID;
+    int dead;
+    unsigned char cardno;
+    unsigned int irq;
+    unsigned int iomem;
+    void *pci_io;
+    unsigned int framecnt;
+    unsigned int last_framecnt;
+    signed int jitter_offset;
+    unsigned long pci_io_phys;
+    unsigned int version;
+    unsigned long iomem_size;
+    unsigned long ioport;
+    struct ztgsm_span gsmspan[ztgsm_SPANS];
+    unsigned int gsmspans;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    unsigned char gsms;
+    unsigned int ticks;
+    unsigned int clicks;
+    unsigned int type;
+    unsigned int sim_sel;
+    int ton_off_toggle[ztgsm_SPANS];
+    unsigned char rxbuf[ztgsm_SPANS][ZT_CHUNKSIZE];
+    unsigned char txbuf[ztgsm_SPANS][ZT_CHUNKSIZE];
+    unsigned char drxbuf[ztgsm_SPANS][ztgsm_SER_BUF_SIZE];
+    unsigned char dtxbuf[ztgsm_SPANS][ztgsm_FIFO_SIZE];
+    unsigned short rxbufi[ztgsm_SPANS];
+
+    unsigned char ser_rx_buf[ztgsm_SPANS][ztgsm_SER_BUF_SIZE];
+    unsigned char ser_tx_buf[ztgsm_SPANS][ztgsm_SER_BUF_SIZE];
+    unsigned short ser_rx_idx[ztgsm_SPANS];
+    unsigned short ser_tx_idx[ztgsm_SPANS];
+    unsigned char tx_wm_sen;
+    struct ztgsm_card *next;
+    struct ztgsm_card *prev;
+} ztgsm_card;
+
+#define ztgsm_outb_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outb((c), ((a)->ioport));
+
+#define ztgsm_inb_io(a,b) ({ outw((b), (a)->ioport+4); inb((a)->ioport); })
+
+#define ztgsm_outw_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outw((c), ((a)->ioport));
+
+#define ztgsm_inw_io(a,b) ({ outw((b), (a)->ioport+4); inw((a)->ioport); })
+
+#define _ztgsm_outdw_io(a,b,c) \
+    outw((b), ((a)->ioport+4)); \
+    outl((c), ((a)->ioport));
+
+#define ztgsm_outdw_io(a,b,c) (outl((c), ((a)->ioport+b)))
+
+#define ztgsm_indw_io(a,b) (inl((a)->ioport+b))
+
+#define ztgsm_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define ztgsm_inb(a,b) (readb((a)->pci_io+(b)))
+
+#define ztgsm_outw(a,b,c) (writew((c),(a)->pci_io+(b)))
+#define ztgsm_inw(a,b) (readw((a)->pci_io+(b)))
+
+#define ztgsm_outdw(a,b,c) (writel((c),(a)->pci_io+(b)))
+#define ztgsm_indw(a,b) (readl((a)->pci_io+(b)))
+
+#define ztgsm_IO_BASE		0x0
+#define ztgsm_VERS_A		ztgsm_IO_BASE
+#define ztgsm_SER_CLK_DIV	ztgsm_IO_BASE + 4
+#define ztgsm_SER_CLK_PRE_DIV	ztgsm_IO_BASE + (4 * 0x02)
+#define ztgsm_PCM_CLK_PRE_DIV	ztgsm_IO_BASE + (4 * 0x03)
+#define ztgsm_SER_IDLE_VAL	ztgsm_IO_BASE + (4 * 0x04)
+#define ztgsm_SER_RTS_O 	ztgsm_IO_BASE + (4 * 0x05)
+#define ztgsm_SER_TX_EN		ztgsm_IO_BASE + (4 * 0x06)
+#define ztgsm_SER_RX_EN		ztgsm_IO_BASE + (4 * 0x07)
+#define ztgsm_SER_DTR_ON_OFF 	ztgsm_IO_BASE + (4 * 0x08)
+#define ztgsm_DIP_SWITCH 	ztgsm_IO_BASE + (4 * 0x09)
+#define ztgsm_LED_DUAL 		ztgsm_IO_BASE + (4 * 0x0A)
+#define ztgsm_SER_G20_ACTIVATED	ztgsm_IO_BASE + (4 * 0x0B)
+#define ztgsm_SIM_SEL 		ztgsm_IO_BASE + (4 * 0x0C)
+#define ztgsm_PCM_DIR 		ztgsm_IO_BASE + (4 * 0x0D)
+
+#define ztgsm_SER_TX_DATA_A	ztgsm_IO_BASE + (4 * 0x10)
+#define ztgsm_SER_TX_COUNT_A	ztgsm_IO_BASE + (4 * 0x11)
+#define ztgsm_SER_TX_DATA_B	ztgsm_IO_BASE + (4 * 0x12)
+#define ztgsm_SER_TX_COUNT_B	ztgsm_IO_BASE + (4 * 0x13)
+#define ztgsm_SER_TX_DATA_C	ztgsm_IO_BASE + (4 * 0x14)
+#define ztgsm_SER_TX_COUNT_C	ztgsm_IO_BASE + (4 * 0x15)
+#define ztgsm_SER_TX_DATA_D	ztgsm_IO_BASE + (4 * 0x16)
+#define ztgsm_SER_TX_COUNT_D	ztgsm_IO_BASE + (4 * 0x17)
+#define ztgsm_SER_RX_DATA_A	ztgsm_IO_BASE + (4 * 0x18)
+#define ztgsm_SER_RX_COUNT_A	ztgsm_IO_BASE + (4 * 0x19)
+#define ztgsm_SER_RX_DATA_B	ztgsm_IO_BASE + (4 * 0x1a)
+#define ztgsm_SER_RX_COUNT_B	ztgsm_IO_BASE + (4 * 0x1b)
+#define ztgsm_SER_RX_DATA_C	ztgsm_IO_BASE + (4 * 0x1c)
+#define ztgsm_SER_RX_COUNT_C	ztgsm_IO_BASE + (4 * 0x1d)
+#define ztgsm_SER_RX_DATA_D	ztgsm_IO_BASE + (4 * 0x1e)
+#define ztgsm_SER_RX_COUNT_D	ztgsm_IO_BASE + (4 * 0x1f)
+#define ztgsm_SER_STATUS	ztgsm_IO_BASE + (4 * 0x20)
+#define ztgsm_SER_INT_MASK	ztgsm_IO_BASE + (4 * 0x21)
+#define ztgsm_SER_RX_WATERMARK	ztgsm_IO_BASE + (4 * 0x22)
+#define ztgsm_SER_TX_WATERMARK	ztgsm_IO_BASE + (4 * 0x23)
+#define ztgsm_SER_TX_WM_SEN	ztgsm_IO_BASE + (4 * 0x24)
+
+#define ztgsm_PCM_SAP_EN	ztgsm_IO_BASE + (4 * 0x30)
+#define ztgsm_PCM_MASK_LAST	ztgsm_IO_BASE + (4 * 0x31)
+#define ztgsm_PCM_FRAME_CNT	ztgsm_IO_BASE + (4 * 0x32)
+#define ztgsm_PCM_FC_TOG_BIT	ztgsm_IO_BASE + (4 * 0x33)
+#define ztgsm_PCM_SIGNAL_CFG	ztgsm_IO_BASE + (4 * 0x34)
+#define ztgsm_PCM_VECTOR_CFG	ztgsm_IO_BASE + (4 * 0x35)
+
+
diff -urN zaptel-1.4.11.org/Makefile zaptel-1.4.11/Makefile
--- zaptel-1.4.11.org/Makefile	2008-05-13 20:01:28.000000000 +0200
+++ zaptel-1.4.11/Makefile	2008-07-16 22:06:17.204532637 +0200
@@ -116,8 +116,8 @@
 endif
 #SUBDIRS_UTILS	+= ppp
 
-TOPDIR_MODULES:=pciradio tor2 torisa wcfxo wct1xxp wctdm wcte11xp wcusb zaptel ztd-eth ztd-loc ztdummy ztdynamic zttranscode
-SUBDIR_MODULES:=wct4xxp wctc4xxp xpp wctdm24xxp wcte12xp
+TOPDIR_MODULES:=pciradio tor2 torisa wcfxo wct1xxp wctdm wcte11xp wcusb zaptel ztd-eth ztd-loc ztdummy ztdynamic zttranscode opvxa1200 wcopenpci
+SUBDIR_MODULES:=wct4xxp wctc4xxp xpp wctdm24xxp wcte12xp cwain qozap vzaphfc zaphfc ztgsm
 TOPDIR_MODULES+=$(MODULES_EXTRA)
 SUBDIR_MODULES+=$(SUBDIRS_EXTRA)
 BUILD_TOPDIR_MODULES:=$(filter-out $(MENUSELECT_MODULES),$(TOPDIR_MODULES))
@@ -419,6 +419,20 @@
 	tar -zxf mISDNuser-$(MISDNUSERVERSION).tar.gz
 	$(MAKE) -C mISDNuser-$(MISDNUSERVERSION) install
 
+# copy bristuff files from subdirectories
+# provide zaphfc.[ch] from zaphfc/zaphfc.[ch] etc. Any better way?
+ztgsm.%: ztgsm/ztgsm.%
+	cp $^ $@
+
+zaphfc.%: zaphfc/zaphfc.%
+	cp $^ $@
+
+qozap.%: qozap/qozap.%
+	cp $^ $@
+
+cwain.%: cwain/cwain.%
+	cp $^ $@
+
 $(UTILS): %: %.o
 	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS) $(LDLIBS)
 
diff -urN zaptel-1.4.11.org/ztpty.c zaptel-1.4.11/ztpty.c
--- zaptel-1.4.11.org/ztpty.c	1970-01-01 01:00:00.000000000 +0100
+++ zaptel-1.4.11/ztpty.c	2008-07-16 22:06:17.261146627 +0200
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/signal.h>
+#include <sys/select.h>
+#include <math.h>
+#include "kernel/zaptel.h"
+
+#define SIZE 8000
+
+
+void doit(int fd, int stdinfd) {
+    fd_set fds;
+    char inbuffer[4096];
+    char outbuffer[4096];
+    int res = 0;
+    int i = 0;
+
+//    fprintf(stderr, "fd %d stdin fd %d\n", fd, stdinfd);
+
+    for (;;) {
+	FD_ZERO(&fds);
+        FD_SET(fd, &fds);
+	FD_SET(stdinfd, &fds);
+        /* Wait for *some* sort of I/O */
+        res = select(stdinfd + 1, &fds, NULL, NULL, NULL);
+        if (res < 0) {
+                fprintf(stderr, "Error in select: %s\n", strerror(errno));
+                return;
+        }
+        if (FD_ISSET(stdinfd, &fds)) {
+            res = read(stdinfd, inbuffer, sizeof(inbuffer));
+	    if (res > 0) {
+//		fprintf(stderr, "read %d bytes from stdin\n", res);
+		if (res > 0) {
+		    for (i=0; i < res ; i++) {
+			if (inbuffer[i] == '\n') {
+			    if ((i > 0) && (inbuffer[i-1] == ' ')) {
+				inbuffer[i-1] = 0x1a;
+			    }
+			    inbuffer[i] = 0xd;
+			}
+		    }
+		res = write(fd, inbuffer, res+2);
+//		res = write(STDOUT_FILENO, inbuffer, res);
+//		fprintf(stderr, "wrote %d bytes to stdout\n", res);
+		}
+	    }
+        }
+        if (FD_ISSET(fd, &fds)) {
+            res = read(fd, outbuffer, sizeof(outbuffer));
+//	    fprintf(stderr, "read %d bytes from fd\n", res);
+	    if (res > 0) {
+		res = write(STDOUT_FILENO, outbuffer, res);
+//		fprintf(stderr, "wrote %d bytes to stdout\n", res);
+	    }
+        }
+    }
+
+
+}
+
+int main(int argc, char *argv[])
+{
+	int fd;
+	int stdinfd;
+	struct zt_params p;
+	struct zt_bufferinfo bi;
+	int blocksize=0;
+	fd = open(argv[1], O_RDWR | O_NONBLOCK);
+	if (fd < 0) {
+		fprintf(stderr, "Unable to open zap interface: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (ioctl(fd, ZT_GET_PARAMS, &p)) {
+		fprintf(stderr, "Unable to get parameters on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	}
+	if ((p.sigtype != ZT_SIG_HDLCRAW) && (p.sigtype != ZT_SIG_HDLCFCS)) {
+		fprintf(stderr, "%s is in %d signalling, not FCS HDLC or RAW HDLC mode\n", argv[1], p.sigtype);
+		exit(1);
+	}
+
+	if (ioctl(fd, ZT_GET_BLOCKSIZE, &blocksize)) {
+		fprintf(stderr, "Unable to get blocksize on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	} else {
+//		fprintf(stderr, "blocksize %d\n", blocksize);
+	}
+
+	bi.txbufpolicy = ZT_POLICY_IMMEDIATE;
+        bi.rxbufpolicy = ZT_POLICY_IMMEDIATE;
+	bi.numbufs = 16;
+	bi.bufsize = 1024;
+	if (ioctl(fd, ZT_SET_BUFINFO, &bi)) {
+		fprintf(stderr, "Unable to set buffer info on '%s': %s\n", argv[1], strerror(errno));
+		exit(1);
+	}
+
+	stdinfd = open("/dev/stdin", O_RDONLY | O_NONBLOCK);
+
+
+	doit(fd, stdinfd);
+	close(stdinfd);
+	close(fd);
+	return 0;
+}
